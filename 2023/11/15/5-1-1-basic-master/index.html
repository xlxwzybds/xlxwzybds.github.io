<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>5-1 basic_master(中) | 冰蒂斯のformula</title><meta name="author" content="冰蒂斯"><meta name="copyright" content="冰蒂斯"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. AXI Master Logic前言： ​	As we do this walk through, you’ll see a couple big differences from the conceptual logic we quickly sketched above.  The first big difference is that we use a skid buffer on">
<meta property="og:type" content="article">
<meta property="og:title" content="5-1 basic_master(中)">
<meta property="og:url" content="http://more_study@163.com/2023/11/15/5-1-1-basic-master/index.html">
<meta property="og:site_name" content="冰蒂斯のformula">
<meta property="og:description" content="1. AXI Master Logic前言： ​	As we do this walk through, you’ll see a couple big differences from the conceptual logic we quickly sketched above.  The first big difference is that we use a skid buffer on">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://more_study@163.com/img/chainsaw_makima04.jpg">
<meta property="article:published_time" content="2023-11-15T13:17:06.000Z">
<meta property="article:modified_time" content="2023-11-28T09:09:32.380Z">
<meta property="article:author" content="冰蒂斯">
<meta property="article:tag" content="AXI">
<meta property="article:tag" content="master">
<meta property="article:tag" content="wishbone">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://more_study@163.com/img/chainsaw_makima04.jpg"><link rel="shortcut icon" href="/img/bloodborn_lib.png"><link rel="canonical" href="http://more_study@163.com/2023/11/15/5-1-1-basic-master/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '5-1 basic_master(中)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-28 17:09:32'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/reze.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="冰蒂斯のformula"><span class="site-name">冰蒂斯のformula</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">5-1 basic_master(中)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-15T13:17:06.000Z" title="发表于 2023-11-15 21:17:06">2023-11-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-28T09:09:32.380Z" title="更新于 2023-11-28 17:09:32">2023-11-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/AXI/">AXI</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/AXI/master/">master</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="5-1 basic_master(中)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-AXI-Master-Logic"><a href="#1-AXI-Master-Logic" class="headerlink" title="1. AXI Master Logic"></a>1. AXI Master Logic</h1><p><strong>前言</strong>：</p>
<p>​	As we do this walk through, you’ll see a couple big differences from the conceptual logic we quickly sketched above.</p>
<ul>
<li>The first big difference is that we use <strong>a skid buffer</strong> on the input to <strong>reduce the timing burden</strong> on the actual <code>o_wb_stall</code> signal. </li>
<li>The second big difference is that <a target="_blank" rel="noopener" href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v">this core</a> can <strong>handle an upsizing data width conversion</strong>. This would be really easy, save for selecting the correct subword from the returned data word. </li>
<li>The last big difference is that several of the <strong>transaction counter flags are registered</strong>.</li>
</ul>
<p><strong><font color="red">Perhaps these differences really aren’t all that big. Either way, let’s start our walk through in detail.</font></strong></p>
<h1 id="2-param-signals-wire"><a href="#2-param-signals-wire" class="headerlink" title="2. param &amp; signals &amp;wire"></a>2. param &amp; signals &amp;wire</h1><h2 id="2-1-parameters"><a href="#2-1-parameters" class="headerlink" title="2.1 parameters"></a>2.1 parameters</h2><p>WB 线和 AXI 线是分开的，<code>address width</code> 和 <code>data width</code>都不相同。这里的大段和小端问题都可以暂时忽略掉，这个设计对 AXI master的主要设计没有太大影响；</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> wbm2axisp #(</span><br><span class="line">	<span class="keyword">parameter</span> C_AXI_DATA_WIDTH	= <span class="number">128</span>,<span class="comment">// Width of the AXI R&amp;W data</span></span><br><span class="line">	<span class="keyword">parameter</span> C_AXI_ADDR_WIDTH	=  <span class="number">28</span>,	<span class="comment">// AXI Address width (log wordsize)</span></span><br><span class="line">	<span class="keyword">parameter</span> C_AXI_ID_WIDTH	=   <span class="number">1</span>,</span><br><span class="line">	<span class="keyword">parameter</span> DW			=  <span class="number">32</span>,	<span class="comment">// Wishbone data width</span></span><br><span class="line">	<span class="keyword">parameter</span> AW			=  <span class="number">26</span>,	<span class="comment">// Wishbone address width (log wordsize)</span></span><br><span class="line">	<span class="keyword">parameter</span> [C_AXI_ID_WIDTH-<span class="number">1</span>:<span class="number">0</span>] AXI_WRITE_ID = <span class="number">1&#x27;b0</span>,</span><br><span class="line">	<span class="keyword">parameter</span> [C_AXI_ID_WIDTH-<span class="number">1</span>:<span class="number">0</span>] AXI_READ_ID  = <span class="number">1&#x27;b1</span>,</span><br><span class="line">  	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// OPT_LITTLE_ENDIAN controls which word has the greatest address</span></span><br><span class="line">	<span class="comment">// when the bus size is adjusted.  If OPT_LITTLE_ENDIAN is true,</span></span><br><span class="line">	<span class="comment">// the biggest address is in the most significant word(s), otherwise</span></span><br><span class="line">	<span class="comment">// the least significant word(s).  This parameter is ignored if</span></span><br><span class="line">	<span class="comment">// C_AXI_DATA_WIDTH == DW.</span></span><br><span class="line">	<span class="keyword">parameter</span> [<span class="number">0</span>:<span class="number">0</span>]			OPT_LITTLE_ENDIAN = <span class="number">1&#x27;b1</span>,</span><br><span class="line">	<span class="keyword">parameter</span> LGFIFO		=   <span class="number">6</span></span><br><span class="line">	) (</span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>			i_clk,	<span class="comment">// System clock</span></span><br><span class="line">	<span class="keyword">input</span>	<span class="keyword">wire</span>			i_reset,<span class="comment">// Reset signal,drives AXI rst</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ID</strong> ： The two IDs, <code>AXI_WRITE_ID</code> and <code>AXI_READ_ID</code>, will contain our constant <a target="_blank" rel="noopener" href="https://zipcpu.com/doc/axi-spec.pdf">AXI</a> ID values–assuming the interconnect even uses them.</li>
<li><strong>LGFIFO</strong>：The <code>LGFIFO</code> parameter captures the size of the FIFO above. You can think of this as <strong>the log of the number of transactions</strong> you might have <strong>outstanding</strong>, the bit width of our transaction counter if you will.</li>
</ul>
<h2 id="2-2-AXI-signals"><a href="#2-2-AXI-signals" class="headerlink" title="2.2 AXI signals"></a>2.2 AXI signals</h2><p>下面的部分还是对 <code>parameter</code>、 <code>axi</code>信号的重复，如果对相关信号比较熟悉可以直接忽略。如果不熟悉也不要紧，慢慢就熟悉了，不要死记硬背。<font color="red">这里需要注意的一点是 axi bus signal type</font>，是 <code>reg</code>还是 <code>wire</code>。按照协议相关信号都需要被 <code>registered</code>！！！</p>
<blockquote>
<p>AXI write address channel signals</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// axi-lite signal</span></span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">reg</span>			o_axi_awvalid,	<span class="comment">// Write address valid</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>			i_axi_awready, <span class="comment">// Slave is ready to accept</span></span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">reg</span>	[C_AXI_ADDR_WIDTH-<span class="number">1</span>:<span class="number">0</span>]	o_axi_awaddr,	<span class="comment">// Write address</span></span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">wire</span>	[<span class="number">2</span>:<span class="number">0</span>]		o_axi_awprot,	<span class="comment">// Write Protection type</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// axi full signal</span></span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">wire</span>	[<span class="number">7</span>:<span class="number">0</span>]		o_axi_awlen,	<span class="comment">// Write Burst Length</span></span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">wire</span>	[C_AXI_ID_WIDTH-<span class="number">1</span>:<span class="number">0</span>]	o_axi_awid,	<span class="comment">// Write ID</span></span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">wire</span>	[<span class="number">2</span>:<span class="number">0</span>]		o_axi_awsize,	<span class="comment">// Write Burst size</span></span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">wire</span>	[<span class="number">1</span>:<span class="number">0</span>]		o_axi_awburst,	<span class="comment">// Write Burst type</span></span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">wire</span>	[<span class="number">0</span>:<span class="number">0</span>]		o_axi_awlock,	<span class="comment">// Write lock type</span></span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">wire</span>	[<span class="number">3</span>:<span class="number">0</span>]		o_axi_awcache,	<span class="comment">// Write Cache type</span></span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">wire</span>	[<span class="number">3</span>:<span class="number">0</span>]		o_axi_awqos,	<span class="comment">// Write Quality of Svc</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>AXI write data channel signals</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// axi-lite signal</span></span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">reg</span>			o_axi_wvalid,	<span class="comment">// Write valid</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>			i_axi_wready,  <span class="comment">// Write data ready</span></span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">reg</span>	[C_AXI_DATA_WIDTH-<span class="number">1</span>:<span class="number">0</span>]	o_axi_wdata,	<span class="comment">// Write data</span></span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">reg</span>	[C_AXI_DATA_WIDTH/<span class="number">8</span>-<span class="number">1</span>:<span class="number">0</span>] o_axi_wstrb,	<span class="comment">// Write strobes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// axi full signal</span></span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">wire</span>			o_axi_wlast,	<span class="comment">// Last write transaction</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p> AXI write response channel signals</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// axi-lite signal</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>			i_axi_bvalid,  <span class="comment">// Write reponse valid</span></span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">wire</span>			o_axi_bready,  <span class="comment">// Response ready</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span> [<span class="number">1</span>:<span class="number">0</span>]		i_axi_bresp,	<span class="comment">// Write response</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// axi full signal</span></span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> [C_AXI_ID_WIDTH-<span class="number">1</span>:<span class="number">0</span>]	i_axi_bid,	<span class="comment">// Response ID</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>AXI read address channel signals</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// axi-lite signal</span></span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">reg</span>			o_axi_arvalid,	<span class="comment">// Read address valid</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>			i_axi_arready,	<span class="comment">// Read address ready</span></span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">wire</span>	[<span class="number">2</span>:<span class="number">0</span>]		o_axi_arprot,	<span class="comment">// Read Protection type</span></span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">reg</span>	[C_AXI_ADDR_WIDTH-<span class="number">1</span>:<span class="number">0</span>]	o_axi_araddr,	<span class="comment">// Read address</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// axi full signal</span></span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">wire</span>	[<span class="number">7</span>:<span class="number">0</span>]		o_axi_arlen,	<span class="comment">// Read Burst Length</span></span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">wire</span>	[<span class="number">2</span>:<span class="number">0</span>]		o_axi_arsize,	<span class="comment">// Read Burst size</span></span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">wire</span>	[<span class="number">1</span>:<span class="number">0</span>]		o_axi_arburst,	<span class="comment">// Read Burst type</span></span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">wire</span>	[<span class="number">0</span>:<span class="number">0</span>]		o_axi_arlock,	<span class="comment">// Read lock type</span></span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">wire</span>	[<span class="number">3</span>:<span class="number">0</span>]		o_axi_arcache,	<span class="comment">// Read Cache type</span></span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">wire</span>	[C_AXI_ID_WIDTH-<span class="number">1</span>:<span class="number">0</span>]	o_axi_arid,	<span class="comment">// Read ID</span></span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">wire</span>	[<span class="number">3</span>:<span class="number">0</span>]		o_axi_arqos,	<span class="comment">// Read Protection type</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>AXI read data channel signals</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// axi-lite signal</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>			i_axi_rvalid,  <span class="comment">// Read reponse valid</span></span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">wire</span>			o_axi_rready,  <span class="comment">// Read Response ready</span></span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> [C_AXI_DATA_WIDTH-<span class="number">1</span>:<span class="number">0</span>] i_axi_rdata,    <span class="comment">// Read data</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[<span class="number">1</span>:<span class="number">0</span>]		i_axi_rresp,   <span class="comment">// Read response</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// axi full signal</span></span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> [C_AXI_ID_WIDTH-<span class="number">1</span>:<span class="number">0</span>]	i_axi_rid,     <span class="comment">// Response ID</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>			i_axi_rlast,    <span class="comment">// Read last</span></span><br></pre></td></tr></table></figure>



<h2 id="2-3-WB-signals"><a href="#2-3-WB-signals" class="headerlink" title="2.3 WB signals"></a>2.3 WB signals</h2><p>关于 wb 的协议，初学者可能并不清楚？分明就是冲着AXI协议来的，为什么又要花费额外的时间进行 <code>WB</code>的信号相关学习。我也是这么想的，那就暂时忽略他们，需要用的时候查一下相关手册就行了。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We&#x27;ll share the clock and the reset</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>			i_wb_cyc,</span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>			i_wb_stb,</span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>			i_wb_we,</span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[(AW-<span class="number">1</span>):<span class="number">0</span>]	i_wb_addr,</span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[(DW-<span class="number">1</span>):<span class="number">0</span>]	i_wb_data,</span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[(DW/<span class="number">8</span>-<span class="number">1</span>):<span class="number">0</span>]	i_wb_sel,</span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">reg</span>			o_wb_stall,</span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">reg</span>			o_wb_ack,</span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">reg</span>	[(DW-<span class="number">1</span>):<span class="number">0</span>]	o_wb_data,</span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">reg</span>			o_wb_err</span><br></pre></td></tr></table></figure>




<h2 id="2-4-address-data-width-conversion"><a href="#2-4-address-data-width-conversion" class="headerlink" title="2.4 address &amp; data width conversion"></a>2.4 address &amp; data width conversion</h2><p>在 <code>bridge</code>之前使用的总线可能是 <code>a word based address</code>，转换后可能是 <code>byte based address</code>。中间的转换过程可以使用 <code>localparam</code>进行简化帮助。</p>
<blockquote>
<p>In particular, the conversion from a word based address to a byte based address on a bus that might not be the same size is going to take a bit of help. These <code>localparam</code>s will help simplify that conversion.</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">localparam</span>	LG_AXI_DW	= <span class="built_in">$clog2</span>(C_AXI_DATA_WIDTH);</span><br><span class="line"><span class="keyword">localparam</span>	LG_WB_DW	= <span class="built_in">$clog2</span>(DW);</span><br><span class="line"><span class="keyword">localparam</span>	FIFOLN = (<span class="number">1</span>&lt;&lt;LGFIFO);</span><br><span class="line"><span class="keyword">localparam</span>	SUBW = LG_AXI_DW-LG_WB_DW;</span><br></pre></td></tr></table></figure>

<p><code>SUBW</code>可以简单理解为<em>axi</em> 数据位宽对 <em>wb</em> 数据位宽的倍数，这个倍数使用了 <code>$clog2()</code>.</p>
<p>在了解两种协议的 <code>address width </code>转换之前，需要先了解：AXI和Wishbone总线的设计理念不同。</p>
<ul>
<li>在AXI总线中，<strong>地址是以字节为单位的</strong>，这意味着无论总线的数据宽度如何，地址总是以字节为单位进行寻址。因此，当总线的数据宽度改变时，AXI的地址宽度并不会改变</li>
<li>然而，Wishbone总线的设计理念不同。在Wishbone总线中，<strong>地址是以总线数据宽度的单位进行寻址的</strong>。因此，当总线的数据宽度改变时，Wishbone的地址宽度也会相应地改变</li>
</ul>
<blockquote>
<p>In particular, the AXI address width must be equal to the Wishbone address width plus the number of subword address bits. (<em>Note that the AXI address width doesn’t change as the bus changes data widths, unlike the Wishbone address width</em>.) </p>
</blockquote>
<p>实现的代码如下，可以使用verilog的 <code>$stop</code>命令保证参数转换的正确性。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">	<span class="comment">// 检查AXI总线的数据宽度是否小于Wishbone总线的数据宽度</span></span><br><span class="line">	<span class="comment">// 如果是，那么仿真将停止</span></span><br><span class="line">	<span class="keyword">if</span> (C_AXI_DATA_WIDTH &lt; DW)</span><br><span class="line">		<span class="built_in">$stop</span>;</span><br><span class="line">	<span class="comment">// 检查AXI总线的地址宽度是否等于Wishbone总线的地址宽度加上子字地址位的数量</span></span><br><span class="line">	<span class="comment">// 如果不是，那么仿真将停止</span></span><br><span class="line">	<span class="keyword">if</span> (C_AXI_ADDR_WIDTH != AW + <span class="built_in">$clog2</span>(DW)-<span class="number">3</span>)</span><br><span class="line">		<span class="built_in">$stop</span>;</span><br><span class="line">	<span class="comment">// 检查AXI总线的数据宽度是否是Wishbone总线的数据宽度的整数倍</span></span><br><span class="line">	<span class="comment">// 并且这个倍数必须是2的幂（即1, 2, 4, 8, 16, 32）</span></span><br><span class="line">	<span class="comment">// 如果不是，那么仿真将停止</span></span><br><span class="line">	<span class="keyword">if</span> (	  (C_AXI_DATA_WIDTH / DW !=<span class="number">32</span>)</span><br><span class="line">		&amp;&amp;(C_AXI_DATA_WIDTH / DW !=<span class="number">16</span>)</span><br><span class="line">		&amp;&amp;(C_AXI_DATA_WIDTH / DW != <span class="number">8</span>)</span><br><span class="line">		&amp;&amp;(C_AXI_DATA_WIDTH / DW != <span class="number">4</span>)</span><br><span class="line">		&amp;&amp;(C_AXI_DATA_WIDTH / DW != <span class="number">2</span>)</span><br><span class="line">		&amp;&amp;(C_AXI_DATA_WIDTH      != DW))</span><br><span class="line">		<span class="built_in">$stop</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>作者设置了一个专门用于 WB 总线复位的信号.</p>
<p>(<strong>更正</strong>：首先查看该信号的名字，<code>lsb</code>，<code>low singnificant bits</code>， 将 wishbone bus 的 data width 处理用作 axi bus 的 address 信号的 LSB。在 wb转axi的时候，wb的addr是基于总线位宽的，axi地址是基于byte的。所以每次wb给出一个wb_data和与之相对应的 wb_addr的时候，该wb_addr对应了axi总线的低 axi_lsbs 位宽。<font color="red">换句话说，axi应该与axi_lsbs 位宽的地址保持 <code>align</code></font> )</p>
<blockquote>
<p>I’d need to know the number of bits that needed to be set to convert a WB address to an AXI address. In order to avoid setting these bits to <code>&#123;($clog2(DW)-3)&#123;1&#39;b0&#125;&#125;</code> every time, I’ve created a simple helper value in <code>axi_lsbs</code>.</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span>	[<span class="built_in">$clog2</span>(DW)-<span class="number">4</span>:<span class="number">0</span>]	axi_lsbs;</span><br><span class="line"><span class="keyword">assign</span>	axi_lsbs = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<h2 id="2-5-fixed-value"><a href="#2-5-fixed-value" class="headerlink" title="2.5 fixed value"></a>2.5 fixed value</h2><p>The more values we fix like this, the simpler our logic will be below.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">localparam</span>	DWSIZE = <span class="built_in">$clog2</span>(DW)-<span class="number">3</span>;</span><br><span class="line"><span class="keyword">assign</span> o_axi_awid    = AXI_WRITE_ID;</span><br><span class="line"><span class="keyword">assign</span> o_axi_awlen   = <span class="number">8&#x27;h0</span>;	<span class="comment">// Burst length is one</span></span><br><span class="line"><span class="keyword">assign</span> o_axi_awsize  = DWSIZE[<span class="number">2</span>:<span class="number">0</span>];</span><br><span class="line"><span class="keyword">assign</span> o_axi_wlast   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">assign</span> o_axi_awburst = <span class="number">2&#x27;b01</span>;	<span class="comment">// Incrementing address (ignored)</span></span><br><span class="line"><span class="keyword">assign</span> o_axi_awlock  = <span class="number">1&#x27;b0</span>;	<span class="comment">// Normal signaling</span></span><br><span class="line"><span class="keyword">assign</span> o_axi_arlock  = <span class="number">1&#x27;b0</span>;	<span class="comment">// Normal signaling</span></span><br><span class="line"><span class="keyword">assign</span> o_axi_awcache = <span class="number">4&#x27;h2</span>;	<span class="comment">// Normal: no cache, no buffer</span></span><br><span class="line"><span class="keyword">assign</span> o_axi_awprot  = <span class="number">3&#x27;b010</span>;	<span class="comment">// Unpriviledged, unsecure, data access</span></span><br><span class="line"><span class="keyword">assign</span> o_axi_awqos   = <span class="number">4&#x27;h0</span>;	<span class="comment">// Lowest quality of service (unused)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">assign</span> o_axi_arid    = AXI_READ_ID;</span><br><span class="line"><span class="keyword">assign</span> o_axi_arlen   = <span class="number">8&#x27;h0</span>;	<span class="comment">// Burst length is one</span></span><br><span class="line"><span class="keyword">assign</span> o_axi_arsize  = DWSIZE[<span class="number">2</span>:<span class="number">0</span>];</span><br><span class="line"><span class="keyword">assign</span> o_axi_arburst = <span class="number">2&#x27;b01</span>;	<span class="comment">// Incrementing address (ignored)</span></span><br><span class="line"><span class="keyword">assign</span> o_axi_arcache = <span class="number">4&#x27;h2</span>;	<span class="comment">// Normal: no cache, no buffer</span></span><br><span class="line"><span class="keyword">assign</span> o_axi_arprot  = <span class="number">3&#x27;b010</span>;	<span class="comment">// Unpriviledged, unsecure, data access</span></span><br><span class="line"><span class="keyword">assign</span> o_axi_arqos   = <span class="number">4&#x27;h0</span>;	<span class="comment">// Lowest quality of service (unused)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>AxID</code> ：held the <code>AxID</code> values constant;</p>
</li>
<li><p><code>AxLEN == 0</code>：the burst length is 1 , which is equal to the axi-lite;</p>
</li>
<li><p><code>WLAST</code>：因为每次都只发送一个数据，所以不需要计算每次发送数据的最后一个在哪里，直接设置为 <code>high state</code>。</p>
<blockquote>
<p>These are the two defining characteristics of this particular class of AXI master. They also allow me to simplify the <code>WLAST</code> calculation, and simply hold that signal high above. </p>
</blockquote>
</li>
<li><p><code>AxSIZE</code>: the  parameter is set based upon the size of the Wishbone , <code>$clog2(DW)-3</code>.</p>
</li>
</ul>
<h2 id="2-6-register-declarations"><a href="#2-6-register-declarations" class="headerlink" title="2.6 register declarations"></a>2.6 register declarations</h2><p>作者说他自己发现了一个主要的 <code>vendor tool</code>并不能处理靠后声明的 <code>register</code>，所以作者会在每次设计的开头声明所有的 <code>register</code>。</p>
<blockquote>
<p>After <strong>finding one major vendor tool that couldn’t properly handle a reference to a register that was defined later in a design</strong>, I’ve been slowly converting all of my designs so that the register or wire declarations are all done at the top of every module and before any logic that might reference them.</p>
</blockquote>
<p>这里提到了一个经典问题：面向 EDA vendor 的编程！</p>
<blockquote>
<p>this simple “language feature” that was treated differently by diffferent tools led to <a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2018/08/04/sim-mismatch.html">simulation&#x2F;synthesis mismatch</a>.</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>			direction, full, empty, flushing, nearfull;</span><br><span class="line"><span class="keyword">reg</span>	[LGFIFO:<span class="number">0</span>]	npending;</span><br><span class="line"></span><br><span class="line"><span class="comment">// skidbuffer signals</span></span><br><span class="line"><span class="keyword">wire</span>				skid_ready, m_valid, m_we;</span><br><span class="line"><span class="keyword">reg</span>					m_ready;</span><br><span class="line"><span class="keyword">wire</span>	[AW-<span class="number">1</span>:<span class="number">0</span>]	m_addr;</span><br><span class="line"><span class="keyword">wire</span>	[DW-<span class="number">1</span>:<span class="number">0</span>]	m_data;</span><br><span class="line"><span class="keyword">wire</span>	[DW/<span class="number">8</span>-<span class="number">1</span>:<span class="number">0</span>]	m_sel;</span><br></pre></td></tr></table></figure>

<p>这些信号的一一映射关系如下：</p>
<blockquote>
<p>The second thing to comment on are the <code>m_*</code> signals. In order to simplify the Wb bus, I added a <a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2019/05/22/skidbuffer.html">skid buffer</a>. As we’ll see further down, these <code>m_*</code> signals capture the outputs of that <a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2019/05/22/skidbuffer.html">skid buffer</a>, so they should (roughly) mirror the <code>i_wb_*</code> signals. (The names aren’t perfect matches, though, since I’m using <code>m_value</code> to mirror <code>i_wb_stb</code>.)</p>
</blockquote>
<p><font color="red">Q：这里的 npending 信号应该是 wb bus 一端 transaction stall number 的计数器</font></p>
<h1 id="3-Overarching-command-logic"><a href="#3-Overarching-command-logic" class="headerlink" title="3. Overarching command logic"></a>3. Overarching command logic</h1><h2 id="3-1-change-direction"><a href="#3-1-change-direction" class="headerlink" title="3.1 change direction"></a>3.1 change direction</h2><p>在第二小节的 <code>2.3</code>中我们讨论过相关的概念。最重要的一点便是： <strong>count the outgoing transaction</strong></p>
<blockquote>
<p>Here’s the first big change from above. Remember the count of outstanding transactions? Here’s that count again, only this time we’re going to keep track of and register all of the other associated signals along the way.</p>
</blockquote>
<p>代码如下：这部分的代码让我觉得十分收益。尤其是与空满有关的四个寄存器的使用。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	npending = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">initial</span>	empty    = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">initial</span>	full     = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">initial</span>	nearfull = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (i_reset)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	npending &lt;= <span class="number">0</span>;</span><br><span class="line">	empty    &lt;= <span class="number">1</span>;</span><br><span class="line">	full     &lt;= <span class="number">0</span>;</span><br><span class="line">	nearfull &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">case</span> (&#123;m_valid &amp;&amp; m_ready, i_axi_bvalid||i_axi_rvalid&#125;)</span><br><span class="line">     <span class="number">2&#x27;b10</span>: <span class="keyword">begin</span></span><br><span class="line">         npending &lt;= npending + <span class="number">1</span>;			<span class="comment">//握手no返回，wb阻塞 +1</span></span><br><span class="line">         empty &lt;= <span class="number">0</span>;						<span class="comment">//空</span></span><br><span class="line">         nearfull &lt;= &amp;(npending[LGFIFO-<span class="number">1</span>:<span class="number">1</span>]);<span class="comment">//不查看最低位</span></span><br><span class="line">         full &lt;= &amp;(npending[LGFIFO-<span class="number">1</span>:<span class="number">0</span>]);</span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line">     <span class="number">2&#x27;b01</span>: <span class="keyword">begin</span></span><br><span class="line">         nearfull &lt;= full; 	   <span class="comment">//如果上次是full，那么这次就是nearfull</span></span><br><span class="line">         npending &lt;= npending - <span class="number">1</span>;</span><br><span class="line">         empty &lt;= (npending == <span class="number">1</span>);<span class="comment">//上次outstanding == 1， 这次就空</span></span><br><span class="line">         full &lt;= <span class="number">0</span>;  			   <span class="comment">//无论如何不可能是满</span></span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line"><span class="keyword">default</span>: <span class="keyword">begin</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>



<p>关于这部分设计的更多细节说明。不要对 <code>(m_valid &amp;&amp; m_ready)</code>这些信号感到才接触的新颖，这些信号不过是 WB总线信号在 <code>skidbuffer</code>另一端的变形。</p>
<blockquote>
<p>Don’t let the the <code>m_valid</code> signal look new at all. It’s simply a replacement for the <code>i_wb_stb</code> signal but on the other side of the Skidbuffer, since I used the AXI handshaking terminology when building my Skidbuffer. For that reasons, the <code>m_ready</code> signal is a <code>!stall</code> indicator at the same interface.</p>
</blockquote>
<p>如果真的感到疑惑，可以跳转到 3.7小结。</p>
<h2 id="3-2-flushing-logic"><a href="#3-2-flushing-logic" class="headerlink" title="3.2 flushing logic"></a>3.2 flushing logic</h2><blockquote>
<p>The <code>flushing</code> logic matches what we discussed above. We start flushing the design on any Bus error. Bus abort condition, and then keep flushing until there are no more outstanding transactions. We’ll use the formal tools to make certain we have this and our counter right along the way.</p>
<p>下面代码中实现的 flush 逻辑和第二大章节中实现的方式保持一致。</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	flushing = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">	<span class="keyword">if</span> (i_reset)</span><br><span class="line">		flushing &lt;= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ((i_axi_rvalid &amp;&amp; i_axi_rresp[<span class="number">1</span>])</span><br><span class="line">		||(i_axi_bvalid &amp;&amp; i_axi_bresp[<span class="number">1</span>])</span><br><span class="line">		||(!i_wb_cyc &amp;&amp; !empty))</span><br><span class="line">		flushing &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (empty)</span><br><span class="line">		flushing &lt;= <span class="number">1&#x27;b0</span>;</span><br></pre></td></tr></table></figure>

<p><font color="red">这一部分的时序逻辑，需要重点仿真一下查看波形图，后续进行补充</font></p>
<h2 id="3-3-old-friend-skidbuffer"><a href="#3-3-old-friend-skidbuffer" class="headerlink" title="3.3 old friend: skidbuffer"></a>3.3 old friend: skidbuffer</h2><p><code>!i_wb_cyc</code>信号在<code>skidbuffer</code>模块的复位输入中的作用。这是为了在总线中止的情况下清空设计。如果<code>i_wb_cyc</code>信号为假，那么任何还没有发送到AXI总线的数据都需要被清除。<font color="red">我一直没有弄清楚i_wb_cyc信号有什么作用？相当于last信号吗？</font></p>
<p>首先看看代码实现：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">skidbuffer <span class="variable">#(.DW(1+AW+DW+(DW/8))</span>,</span><br><span class="line">	<span class="variable">.OPT_OUTREG</span>(<span class="number">1&#x27;b0</span>))</span><br><span class="line">skid (i_clk, i_reset || !i_wb_cyc,</span><br><span class="line">	i_wb_stb, skid_ready,</span><br><span class="line">		&#123; i_wb_we, i_wb_addr, i_wb_data, i_wb_sel &#125;,</span><br><span class="line">	m_valid, m_ready,</span><br><span class="line">		&#123; m_we, m_addr, m_data, m_sel &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line">	o_wb_stall = !skid_ready;</span><br></pre></td></tr></table></figure>

<p><code>skidbuffer</code>进行<code>wb </code>总线和 <code>axi</code>总线信号转换的缓冲。 <code>wb</code>总线需要处理的 <code>skid_ready </code>信号来自于 <code>m_ready</code>信号。那么 <code>m_ready</code>信号来自于哪里，经过什么信号的逻辑计算得到的。</p>
<p>当遇到如下情况的时候，需要将 <code>m_ready</code>信号拉低：</p>
<ul>
<li>去除所有outstanding 、counter will full ， we want to the opposite operation but there is still transaction chould be handled</li>
<li><code>AW W AR</code>三个通道有存在 <code>valid before ready</code>的情况。</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	m_ready = <span class="number">1</span>;</span><br><span class="line">     </span><br><span class="line">	<span class="keyword">if</span> (flushing || nearfull || ((m_we != direction)&amp;&amp;(!empty)))</span><br><span class="line">		m_ready = <span class="number">1&#x27;b0</span>;</span><br><span class="line">	<span class="keyword">if</span> (o_axi_awvalid &amp;&amp; !i_axi_awready)</span><br><span class="line">		m_ready = <span class="number">1&#x27;b0</span>;</span><br><span class="line">	<span class="keyword">if</span> (o_axi_wvalid &amp;&amp; !i_axi_wready)</span><br><span class="line">		m_ready = <span class="number">1&#x27;b0</span>;</span><br><span class="line">	<span class="keyword">if</span> (o_axi_arvalid &amp;&amp; !i_axi_arready)</span><br><span class="line">		m_ready = <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><code>m_ready</code>信号是一个 <code>wire</code>信号，相对应的 <code>skid_ready</code>信号需要 <code>register</code>。</p>
<blockquote>
<p>this ready signal was a key part of the simplified AXI-lite design. It fulfills the same basic function here, even though we’ve combined both read and write channels when building it. </p>
<p>The goal is simply that we know we are <strong>accepting a Wishbone signal into the AXI side</strong> of the interface anytime <code>m_valid &amp;&amp; m_ready</code> are true together.</p>
</blockquote>
<h1 id="4-AXI-Signaling"><a href="#4-AXI-Signaling" class="headerlink" title="4. AXI Signaling"></a>4. AXI Signaling</h1><h2 id="4-1-Write-transactions-Partial"><a href="#4-1-Write-transactions-Partial" class="headerlink" title="4.1 Write transactions (Partial)"></a>4.1 Write transactions (Partial)</h2><p>该部分分为 <code>awvalid 、 wvalid</code>的设置逻辑，不同位宽情况下<code>wdata</code>的处理方式，不同的数据存储方法下（big-endian 、little-endian）<em>w channel</em>的<code>strb</code>信号的设置方式。</p>
<h3 id="1-awvalid-wvalid"><a href="#1-awvalid-wvalid" class="headerlink" title="1. awvalid &amp; wvalid"></a>1. awvalid &amp; wvalid</h3><p>现在看 <em>axi</em> 一侧，是如何控制 <code>valid </code>信号的。</p>
<blockquote>
<p>Once each of these gets accepted, we’ll clear it to prepare for the next transaction.</p>
<p>虽然 <code>aw_valid</code>和<code>w_valid信号</code>都是同时设置为高电平，但是两个通道可以在接受到各自的 <code>ready</code>信号后进行拉低。（不由自主的想到了xilinx demo design中的 ready信号设计，也和这个一样一高一低，总吞吐量最大只能保存在 <code>50%</code>）</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	o_axi_awvalid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">initial</span>	o_axi_wvalid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (i_reset)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	o_axi_awvalid &lt;= <span class="number">0</span>;</span><br><span class="line">	o_axi_wvalid  &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (m_valid &amp;&amp; m_we &amp;&amp; m_ready)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	o_axi_awvalid &lt;= <span class="number">1</span>;</span><br><span class="line">	o_axi_wvalid  &lt;= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span> (i_axi_awready)</span><br><span class="line">		o_axi_awvalid &lt;= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (i_axi_wready)</span><br><span class="line">		o_axi_wvalid &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>更多的细节请见：<font color="red">这部分的实现和 <code>2.3.2小结</code>的实现保持一致。</font></p>
<h3 id="2-wdata"><a href="#2-wdata" class="headerlink" title="2. wdata"></a>2. wdata</h3><p>在 <code>write data</code>的处理上有些许不同。假设两个总线的数据位宽存在 <code>data size upsizing</code>。</p>
<blockquote>
<p>We also know that bus sizes are only ever powers of two. This allows us to just repeat our data register across <code>o_axi_wdata</code>. The alternative, shifting <code>m_data</code> by an amount given in the low order bits of <code>m_addr</code>, would be annoying to do and get right. Duplicating everything is just the simple way to handle it.</p>
<p>翻译：在AXI总线的写数据(<code>o_axi_wdata</code>)上实现数据扩展的。这里的假设是我们正在进行数据宽度的扩大，也就是说，我们正在将较小的数据宽度扩大到较大的数据宽度。在每个时钟上升沿，如果不存在  <code>valdi before ready</code>的情况， 那么就会更新AXI总线的写数据<code>(o_axi_wdata)</code>。</p>
<p>更新的方式是将<code>m_data</code>重复<code>C_AXI_DATA_WIDTH/DW</code>次。这里，<code>C_AXI_DATA_WIDTH</code>是AXI总线的数据宽度，<code>DW</code>是Wishbone总线的数据宽度。因为我们知道总线的数据宽度总是2的幂，所以<code>C_AXI_DATA_WIDTH/DW</code>就是我们需要重复的次数。</p>
<p>这种方法的优点是简单易行。如果我们选择另一种方法，即通过<code>m_addr</code>的低位来决定<code>m_data</code>的移位量，那么实现起来就会比较麻烦，而且容易出错。所以，选择重复的方法来处理这个问题是更简单的方式。。</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (!o_axi_wvalid || i_axi_wready)</span><br><span class="line">	o_axi_wdata   &lt;= &#123;(C_AXI_DATA_WIDTH/DW)&#123;m_data&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>更多的细节请见：<font color="red">这部分的实现和 <code>2.3.3小结</code>的实现保持一致。</font></p>
<h3 id="3-wstrb"><a href="#3-wstrb" class="headerlink" title="3. wstrb"></a>3. wstrb</h3><blockquote>
<p>When it comes to setting <code>WSTRB</code>, I chose a rather verbose approach（详细的，冗长的方法）.</p>
<ul>
<li>If the two data widths are the same, <code>m_sel</code> can just be copied to <code>WSTRB</code>. </li>
<li>If not, you need to be careful which <code>WSTRB</code> bits get set–since these indicate which bytes will actually be written as part of the AXI transaction.</li>
</ul>
</blockquote>
<p>对于不同的位宽， <code>sel</code>信号转 <code>axi_wstrb</code>信号有不同的逻辑转换方法：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">generate</span> <span class="keyword">if</span> (DW == C_AXI_DATA_WIDTH)</span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">		<span class="keyword">if</span> (!o_axi_wvalid || i_axi_wready)</span><br><span class="line">			o_axi_wstrb   &lt;= m_sel;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (DW*<span class="number">2</span> == C_AXI_DATA_WIDTH)</span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">		<span class="keyword">if</span> (!o_axi_wvalid || i_axi_wready)</span><br><span class="line">		<span class="keyword">begin</span></span><br><span class="line">			<span class="keyword">if</span> (m_addr[<span class="number">0</span>])</span><br><span class="line">				o_axi_wstrb   &lt;= &#123; m_sel, &#123;(DW/<span class="number">8</span>)&#123;<span class="number">1&#x27;b0</span>&#125;&#125; &#125;;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				o_axi_wstrb   &lt;= &#123; &#123;(DW/<span class="number">8</span>)&#123;<span class="number">1&#x27;b0</span>&#125;&#125;, m_sel &#125;;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> <span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">endgenerate</span></span><br></pre></td></tr></table></figure>

<p>在位宽不一样， <code>axi data width</code>和 <code>wishbone data width</code>呈现2的次方倍数的时候，根据地址地位的电平选择 <code>axi bus</code>中 <code>strb</code>的有效数据选择。</p>
<p>这部分代码区分了 <em>AXI</em> 中的数据存储方式： <code>little_endian</code>和 <code>big_endian</code>.虽然现在不会马上使用，但是不妨把这当做一个了解大端小端数据存储的机会。</p>
<ul>
<li><em>Situation-1</em>:<code>(DW == C_AXI_DATA_WIDTH)</code></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果数据宽度等于AXI数据宽度</span></span><br><span class="line"><span class="keyword">if</span> (DW == C_AXI_DATA_WIDTH)</span><br><span class="line"><span class="keyword">begin</span> : NO_WSTRB_ADJUSTMENT</span><br><span class="line">    <span class="comment">// 在时钟上升沿，如果AXI写有效信号为假或者AXI写就绪信号为真</span></span><br><span class="line">    <span class="comment">// 则将m_sel赋值给AXI写字节使能信号</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">    <span class="keyword">if</span> (!o_axi_wvalid || i_axi_wready)</span><br><span class="line">        o_axi_wstrb   &lt;= m_sel;</span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure>

<ul>
<li><em>Situation-2</em>:<code>(OPT_LITTLE_ENDIAN)</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">低地址 ----------------&gt; 高地址</span><br><span class="line">0x78 | 0x56 | 0x34 | 0x12</span><br></pre></td></tr></table></figure>

<p>信号 <code>m_addr[SUBW-1:0]</code> 对应了<em>wb_data</em>对应在 <em>axi_data</em> 的对应的哪一个位置。使用小端的方式，左边是高地址位置，所以应该向左移动 <code>m_addr[SUBW-1:0]</code>个<em>wb bus</em>位宽<code>(DW/8)</code>的长度。<font color="red">高位左移去高地址</font></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果设置为小端模式</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (OPT_LITTLE_ENDIAN)</span><br><span class="line"><span class="keyword">begin</span> : LITTLE_ENDIAN_WSTRB</span><br><span class="line">    <span class="comment">// 在时钟上升沿，如果AXI写有效信号为假或者AXI写就绪信号为真</span></span><br><span class="line">    <span class="comment">// 则将m_sel左移（数据宽度/8）* m_addr[SUBW-1:0]位后赋值给AXI写字节使能信号</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">    <span class="keyword">if</span> (!o_axi_wvalid || i_axi_wready)</span><br><span class="line">        o_axi_wstrb   &lt;= m_sel &lt;&lt; ((DW/<span class="number">8</span>) * m_addr[SUBW-<span class="number">1</span>:<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure>

<ul>
<li><em>Situation-3</em>:  <code>BIG_ENDIAN_WSTRB</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">低地址 ----------------&gt; 高地址</span><br><span class="line">0x12 | 0x34 | 0x56 | 0x78</span><br></pre></td></tr></table></figure>

<p>和 <code>little endian</code>一样左移， 只不过移动的 <em>byte</em> 数量需要取反。<font color="red">高位右移去高地址</font></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果设置为大端模式</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">begin</span> : BIG_ENDIAN_WSTRB</span><br><span class="line">    <span class="comment">// 定义一个寄存器neg_addr，宽度为SUBW</span></span><br><span class="line">    <span class="keyword">reg</span>	[SUBW-<span class="number">1</span>:<span class="number">0</span>]	neg_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// neg_addr的值为m_addr[SUBW-1:0]的按位取反</span></span><br><span class="line">    <span class="keyword">always</span> @(*)</span><br><span class="line">        neg_addr = ~m_addr[SUBW-<span class="number">1</span>:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在时钟上升沿，如果AXI写有效信号为假或者AXI写就绪信号为真</span></span><br><span class="line">    <span class="comment">// 则将m_sel左移（数据宽度/8）* neg_addr位后赋值给AXI写字节使能信号</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">    <span class="keyword">if</span> (!o_axi_wvalid || i_axi_wready)</span><br><span class="line">        o_axi_wstrb   &lt;= m_sel &lt;&lt; ((DW/<span class="number">8</span>)* neg_addr);</span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure>



<h2 id="4-2-read-transaction-Partial"><a href="#4-2-read-transaction-Partial" class="headerlink" title="4.2 read transaction (Partial)"></a>4.2 read transaction (Partial)</h2><p>处理 <code>read channel</code> 和 <code>write channel</code>有异曲同工之处，但也有稍许不同。</p>
<blockquote>
<ul>
<li><strong>same</strong>: Read requests are similar. On any read request, where <code>i_wb_stb &amp;&amp; !i_wb_we</code>, set <code>ARVALID</code> and <code>ARADDR</code>.</li>
<li><strong>difference</strong>: Setting <code>ARADDR</code> is identical to what we did before with <code>AWADDR</code>, but <code>ARVALID</code> is just a touch different simply because we don’t have two channels that need synchronization.</li>
</ul>
</blockquote>
<p>在 <code>AR channel</code>的实现，会讲 <code>valid</code>信号进行连续的高低起伏变化，并不能一致维持在高电平状态。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	o_axi_arvalid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (i_reset)</span><br><span class="line">	o_axi_arvalid &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m_valid &amp;&amp; !m_we &amp;&amp; m_ready)</span><br><span class="line">	o_axi_arvalid &lt;= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i_axi_arready)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	o_axi_arvalid &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><strong>上面代码的两个重要特点是：</strong></p>
<ul>
<li><code>ARVALID</code>逻辑和下面的<code>RVALID</code>逻辑是两个独立的状态机，这允许有多个事务同时进行。</li>
<li>只有当相应的地址通道没有被阻塞时，才会更新地址寄存器。这可以确保在总线忙的时候，不会有新的地址被发送出去。</li>
</ul>
<blockquote>
<p> We can also update the address registers any time the respective address channels aren’t stalled. </p>
<p> 只要没有发生 <code>valid before ready</code>就可以传入新的 <code>addr</code>地址数据.<strong>这一部分的逻辑关系在后面需要深入研究。</strong></p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该部分代码并非实现时候的代码，只是一个参考例子</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (!o_axi_awvalid || i_axi_awready)</span><br><span class="line">	o_axi_awaddr  &lt;= &#123; m_addr, axi_lsbs &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (!o_axi_arvalid || i_axi_arready)</span><br><span class="line">	o_axi_araddr  &lt;= &#123; m_addr, axi_lsbs &#125;;</span><br></pre></td></tr></table></figure>

<p>下面是对一个 <code>valid before ready</code>的说明：</p>
<blockquote>
<p>it’s worth reflecting on the fact that <code>!VALID || READY</code> is the negation of <code>VALID &amp;&amp; !READY</code>, <a target="_blank" rel="noopener" href="https://zipcpu.com/doc/axi-spec.pdf">AXI</a> stall condition. Hence, any time the respective address channels are not stalled, then we want to adjust the addresses.</p>
</blockquote>
<h2 id="4-3-awaddr-araddr"><a href="#4-3-awaddr-araddr" class="headerlink" title="4.3 awaddr &amp; araddr"></a>4.3 awaddr &amp; araddr</h2><p>根据不同的端序（大端或小端）来调整AXI的读写地址（<code>o_axi_awaddr</code>和<code>o_axi_araddr</code>），确保数据在内存中的存储顺序符合相应的端序要求。</p>
<ul>
<li>在小端模式下，或者当数据宽度等于AXI数据宽度时，<code>m_addr</code>会被左移<code>($clog2(DW)-3)</code>位后赋值给AXI的读写地址；</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">generate</span> </span><br><span class="line">    <span class="comment">// 如果设置为小端模式或者数据宽度等于AXI数据宽度</span></span><br><span class="line">    <span class="keyword">if</span> (OPT_LITTLE_ENDIAN || DW == C_AXI_DATA_WIDTH)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 在时钟上升沿，如果AXI写地址有效信号为假或者AXI写地址就绪信号为真</span></span><br><span class="line">        <span class="comment">// 则将m_addr左移($clog2(DW)-3)位后赋值给AXI写地址信号</span></span><br><span class="line">        <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">        <span class="keyword">if</span> (!o_axi_awvalid || i_axi_awready)</span><br><span class="line">            o_axi_awaddr  &lt;= &#123; m_addr, &#123;(<span class="built_in">$clog2</span>(DW)-<span class="number">3</span>)&#123;<span class="number">1&#x27;b0</span>&#125;&#125; &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在时钟上升沿，如果AXI读地址有效信号为假或者AXI读地址就绪信号为真</span></span><br><span class="line">        <span class="comment">// 则将m_addr左移($clog2(DW)-3)位后赋值给AXI读地址信号</span></span><br><span class="line">        <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">        <span class="keyword">if</span> (!o_axi_arvalid || i_axi_arready)</span><br><span class="line">            o_axi_araddr  &lt;= &#123; m_addr, &#123;(<span class="built_in">$clog2</span>(DW)-<span class="number">3</span>)&#123;<span class="number">1&#x27;b0</span>&#125;&#125; &#125;;</span><br><span class="line">    <span class="keyword">end</span> </span><br></pre></td></tr></table></figure>

<ul>
<li>而在大端模式下，<code>m_addr</code>会被左移<code>($clog2(DW)-3)</code>位后赋值给AXI的读写地址，同时，<code>m_addr</code>的低位按位取反<code>（neg_addr）</code>的结果会被赋值给AXI读写地址的<code>($clog2(DW)-3 +: SUBW)</code>位。</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果设置为大端模式</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">begin</span> : OPT_BIG_ENDIAN</span><br><span class="line">    <span class="comment">// 定义一个寄存器neg_addr，宽度为SUBW</span></span><br><span class="line">    <span class="keyword">reg</span>	[SUBW-<span class="number">1</span>:<span class="number">0</span>]	neg_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// neg_addr的值为m_addr[SUBW-1:0]的按位取反</span></span><br><span class="line">    <span class="keyword">always</span> @(*)</span><br><span class="line">        neg_addr = ~m_addr[SUBW-<span class="number">1</span>:<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>在大端模式下，<code>neg_addr = ~m_addr[SUBW-1:0];</code>这行代码的作用是将地址的低<code>SUBW</code>位按位取反。这是因为在大端模式下，我们需要将低位字节存储在高地址中。通过将地址的低<code>SUBW</code>位按位取反，我们可以得到一个新的地址<code>neg_addr</code>，这个地址的低<code>SUBW</code>位和原地址的低<code>SUBW</code>位是相反的。然后，我们可以使用这个新的地址<code>neg_addr</code>来作为数据存储的地址</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">		<span class="comment">// 在时钟上升沿，如果AXI写地址有效信号为假或者AXI写地址就绪信号为真</span></span><br><span class="line">        <span class="comment">// 则将m_addr左移($clog2(DW)-3)位后赋值给AXI写地址信号</span></span><br><span class="line">        <span class="comment">// 并将neg_addr的值赋值给AXI写地址信号的($clog2(DW)-3 +: SUBW)位</span></span><br><span class="line">        <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">        <span class="keyword">if</span> (!o_axi_awvalid || i_axi_awready)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            o_axi_awaddr &lt;= <span class="number">0</span>;</span><br><span class="line">            o_axi_awaddr &lt;= m_addr &lt;&lt; (<span class="built_in">$clog2</span>(DW)-<span class="number">3</span>);</span><br><span class="line">            o_axi_awaddr[<span class="built_in">$clog2</span>(DW)-<span class="number">3</span> +: SUBW] &lt;= neg_addr;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在时钟上升沿，如果AXI读地址有效信号为假或者AXI读地址就绪信号为真</span></span><br><span class="line">        <span class="comment">// 则将m_addr左移($clog2(DW)-3)位后赋值给AXI读地址信号</span></span><br><span class="line">        <span class="comment">// 并将neg_addr的值赋值给AXI读地址信号的($clog2(DW)-3 +: SUBW)位</span></span><br><span class="line">        <span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">        <span class="keyword">if</span> (!o_axi_arvalid || i_axi_arready)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            o_axi_araddr &lt;= <span class="number">0</span>;</span><br><span class="line">            o_axi_araddr &lt;= m_addr &lt;&lt; (<span class="built_in">$clog2</span>(DW)-<span class="number">3</span>);</span><br><span class="line">            o_axi_araddr[<span class="built_in">$clog2</span>(DW)-<span class="number">3</span> +: SUBW] &lt;= neg_addr;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">endgenerate</span></span><br></pre></td></tr></table></figure>

<p>理解上面的代码需要知道 <code>SUBW</code>的定义是什么，这个并不是 <em>wb</em> 、<em>axi</em> 的<em>address</em>位宽关系，而是<em>data_width</em> 的关系。在 <code>2.4</code>小结中明确定义了两个总线之间的<em>data_width</em> 的关系。所以 <code>m_addr[SUBW-1:0]</code>位宽，可以表示一个完整的 <code>axi_data_size</code>。</p>
<p>解释代码： <code>o_axi_awaddr &lt;= m_addr &lt;&lt; ($clog2(DW)-3);</code></p>
<p>将 <em>wb</em> 的 <em>word based addr</em> 转化为 <em>byte based addr</em>。</p>
<p>解释代码： <code>o_axi_awaddr[$clog2(DW)-3 +: SUBW] &lt;= neg_addr;</code></p>
<p><font color="red">需要仿真理解，待</font></p>
<h2 id="4-4-ack-err（相对较难）"><a href="#4-4-ack-err（相对较难）" class="headerlink" title="4.4 ack &amp; err（相对较难）"></a>4.4 ack &amp; err（相对较难）</h2><h3 id="1-same-width"><a href="#1-same-width" class="headerlink" title="1. same width"></a>1. same width</h3><p>如果没有位宽的变化，那么 setting <code>o_wb_ack</code>, <code>o_wb_err</code>, and <code>o_wb_data</code> were fairly straightforward.这里使用组合逻辑。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">generate</span> <span class="keyword">if</span> (DW == C_AXI_DATA_WIDTH)</span><br><span class="line">	<span class="keyword">begin</span> : NO_READ_DATA_SELECT_NECESSARY</span><br><span class="line"></span><br><span class="line">		<span class="keyword">always</span> @(*)</span><br><span class="line">			o_wb_data = i_axi_rdata;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">always</span> @(*)</span><br><span class="line">			o_wb_ack = !flushing&amp;&amp;((i_axi_rvalid &amp;&amp; !i_axi_rresp[<span class="number">1</span>])</span><br><span class="line">				||(i_axi_bvalid &amp;&amp; !i_axi_bresp[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">always</span> @(*)</span><br><span class="line">			o_wb_err = !flushing&amp;&amp;((i_axi_rvalid &amp;&amp; i_axi_rresp[<span class="number">1</span>])</span><br><span class="line">				||(i_axi_bvalid &amp;&amp; i_axi_bresp[<span class="number">1</span>]));</span><br></pre></td></tr></table></figure>

<h3 id="2-different-width"><a href="#2-different-width" class="headerlink" title="2.different width"></a>2.different width</h3><p>当发生位宽变化的时候，在写通道中发送正确的数据不算困难，但是读通道的处理会变的比较困难。</p>
<blockquote>
<p>Sending the right data down the write channel wasn’t that hard, but the read channel is a touch harder. （think why）</p>
<p>In particular, we’ll need a small <strong>FIFO</strong> to <strong>keep track of the low order bits of the address</strong>–at least enough of a FIFO to select the right subword from the returned <code>RDATA</code> value later.</p>
<p>在这个过程中，我们需要一个小的FIFO（First In First Out，先进先出）来跟踪地址的低位，至少需要足够的FIFO来从返回的RDATA值中选择正确的数据</p>
</blockquote>
<p>首先举例说明，为什么要跟踪地位数据：</p>
<p>假设我们有一个32位的总线，但我们的处理器只能处理8位的数据。在写入数据时，我们可以简单地将8位数据写入到32位总线的适当位置（由地址的低2位决定）。但是，在读取数据时，我们需要从32位总线中选择正确的8位数据，这就需要我们跟踪地址的低2位。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] addr_fifo;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] data_fifo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">if</span> (i_reset)</span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    addr_fifo &lt;= <span class="number">2&#x27;b00</span>;</span><br><span class="line">    data_fifo &lt;= <span class="number">32&#x27;b0</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (i_wb_stb &amp;&amp; i_wb_cyc)</span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    addr_fifo &lt;= i_wb_addr[<span class="number">1</span>:<span class="number">0</span>];</span><br><span class="line">    data_fifo &lt;= i_wb_data;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 体现了低两位数据的作用</span></span><br><span class="line"><span class="keyword">assign</span> o_wb_data = (addr_fifo == <span class="number">2&#x27;b00</span>) ? data_fifo[<span class="number">7</span>:<span class="number">0</span>] :</span><br><span class="line">                   (addr_fifo == <span class="number">2&#x27;b01</span>) ? data_fifo[<span class="number">15</span>:<span class="number">8</span>] :</span><br><span class="line">                   (addr_fifo == <span class="number">2&#x27;b10</span>) ? data_fifo[<span class="number">23</span>:<span class="number">16</span>] : 												data_fifo[<span class="number">31</span>:<span class="number">24</span>];</span><br></pre></td></tr></table></figure>

<p>具体的代码会在下面的小结中介绍，该小结只是介绍这个想法和思路。</p>
<h3 id="3-using-fifo-logic"><a href="#3-using-fifo-logic" class="headerlink" title="3.using fifo logic"></a>3.using fifo logic</h3><p>The good part of this is that our <code>npending</code>, <code>empty</code>, and <code>full</code> signals above properly mirror the number of elements in this FIFO. That will at least clear up some of the challenge of getting the control signals right.</p>
<p>声明和初始化相关的信号：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个寄存器数组addr_fifo，用于存储地址信息</span></span><br><span class="line"><span class="keyword">reg</span>	[SUBW-<span class="number">1</span>:<span class="number">0</span>]	addr_fifo	[<span class="number">0</span>:(<span class="number">1</span>&lt;&lt;LGFIFO)-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个寄存器fifo_value，用于存储FIFO中的值</span></span><br><span class="line"><span class="keyword">reg</span>	[SUBW-<span class="number">1</span>:<span class="number">0</span>]	fifo_value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义两个寄存器wr_addr和rd_addr，分别用于存储写地址和读地址</span></span><br><span class="line"><span class="keyword">reg</span>	[LGFIFO:<span class="number">0</span>]	wr_addr, rd_addr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个线return_data，用于存储返回的数据</span></span><br><span class="line"><span class="keyword">wire</span>	[C_AXI_DATA_WIDTH-<span class="number">1</span>:<span class="number">0</span>]	return_data;</span><br></pre></td></tr></table></figure>

<p>处理 <em>wb_bus_ack</em> 信号：</p>
<ul>
<li>在时钟上升沿，如果复位信号为真，或者总线周期信号为假，或者正在进行刷新操作，则将o_wb_ack设置为0</li>
<li>否则，如果AXI读有效信号为真并且AXI读响应信号的第1位为假；或者AXI写回有效信号为真并且AXI写回响应信号的第1位为假，则将o_wb_ack设置为1</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (i_reset || !i_wb_cyc || flushing)</span><br><span class="line">	o_wb_ack &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	o_wb_ack &lt;= ((i_axi_rvalid &amp;&amp; !i_axi_rresp[<span class="number">1</span>])||</span><br><span class="line">                 (i_axi_bvalid &amp;&amp; !i_axi_bresp[<span class="number">1</span>]));</span><br></pre></td></tr></table></figure>

<p>处理 <em>wb_bus_err</em> 信号：</p>
<ul>
<li>在时钟上升沿，如果复位信号为真，或者总线周期信号为假，或者正在进行刷新操作，则将o_wb_err设置为0</li>
<li>否则，如果AXI读有效信号为真并且AXI读响应信号的第1位为真，或者AXI写回有效信号为真并且AXI写回响应信号的第1位为真，则将o_wb_err设置为1</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化o_wb_err为0</span></span><br><span class="line"><span class="keyword">initial</span>	o_wb_err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (i_reset || !i_wb_cyc || flushing)</span><br><span class="line">	o_wb_err &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	o_wb_err &lt;= ((i_axi_rvalid &amp;&amp; i_axi_rresp[<span class="number">1</span>])||</span><br><span class="line">                 (i_axi_bvalid &amp;&amp; i_axi_bresp[<span class="number">1</span>]));</span><br></pre></td></tr></table></figure>





<blockquote>
<p>need to adjust the address of the FIFO on any write.</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	wr_addr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (i_reset)</span><br><span class="line">	wr_addr &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m_valid &amp;&amp; m_ready)</span><br><span class="line">	wr_addr &lt;= wr_addr + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>get the low order bits of wb bus address.These are the bits which we’ll need later to select which subword of the return data word is the one we need.</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">		<span class="keyword">if</span> (m_valid &amp;&amp; m_ready)</span><br><span class="line">            addr_fifo[wr_addr] &lt;= m_addr[SUBW-<span class="number">1</span>:<span class="number">0</span>];</span><br><span class="line">			<span class="comment">//addr_fifo[wr_addr[LGFIFO-1:0]] &lt;= m_addr[SUBW-1:0];</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>on a read we’ll adjust the read address.</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	rd_addr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (i_reset)</span><br><span class="line">	rd_addr &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i_axi_bvalid || i_axi_rvalid)</span><br><span class="line">	rd_addr &lt;= rd_addr + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>如果使用 <code>distributed RAM</code>则可以在一个时钟周期内读出read data。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line">			fifo_value = addr_fifo[rd_addr[LGFIFO-<span class="number">1</span>:<span class="number">0</span>]];</span><br></pre></td></tr></table></figure>



<h3 id="shift-return-data"><a href="#shift-return-data" class="headerlink" title="shift return data"></a>shift return data</h3><p>最后使用 <code>shift</code>将需要的数据移动到 <code>wb bus</code>的最低位。</p>
<ul>
<li><p><code>assign return_data = i_axi_rdata &gt;&gt; (fifo_value * DW);</code> </p>
<p>这行代码是在做一个右移操作，将<code>i_axi_rdata</code>（从AXI总线上读取的数据）向右移动<code>fifo_value * DW</code>位。这里的<code>fifo_value</code>是我们之前存储的地址的低位，<code>DW</code>是数据宽度（以位为单位）。</p>
<p>这个操作的目的是将我们感兴趣的数据字移动到<code>return_data</code>的最低有效位。</p>
</li>
<li><p><code>always @(posedge i_clk) o_wb_data &lt;= return_data[DW-1:0];</code> </p>
<p>这行代码是在每个时钟上升沿将<code>return_data</code>的低<code>DW</code>位赋值给<code>o_wb_data</code>。</p>
<p>这样，我们就可以在下一个时钟周期中使用这个数据字。</p>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span>	return_data = i_axi_rdata &gt;&gt; (fifo_value * DW);</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">	o_wb_data &lt;= return_data[DW-<span class="number">1</span>:<span class="number">0</span>];</span><br></pre></td></tr></table></figure>



<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul>
<li>关于DAM的文章（好吧，这是一个项目）：<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ZipCPU/axidmacheck">ZipCPU&#x2F;axidmacheck: AXI DMA Check: A utility to measure DMA speeds in simulation (github.com)</a></li>
</ul>
</li>
<li><strong>AXI reset</strong> :<ul>
<li><a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2020/03/14/axi-reset.html">https://zipcpu.com/blog/2020/03/14/axi-reset.html</a></li>
</ul>
</li>
<li>避免：面向eda工具的编程：<ul>
<li><a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2018/08/04/sim-mismatch.html">Reasons why Synthesis might not match Simulation (zipcpu.com)</a></li>
</ul>
</li>
<li>clock 设计的重要性：<ul>
<li><a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2017/09/18/clocks-for-sw-engineers.html">Clocks for Software Engineers (zipcpu.com)</a></li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://more_study@163.com">冰蒂斯</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://more_study@163.com/2023/11/15/5-1-1-basic-master/">http://more_study@163.com/2023/11/15/5-1-1-basic-master/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://more_study@163.com" target="_blank">冰蒂斯のformula</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/AXI/">AXI</a><a class="post-meta__tags" href="/tags/master/">master</a><a class="post-meta__tags" href="/tags/wishbone/">wishbone</a></div><div class="post_share"><div class="social-share" data-image="/img/chainsaw_makima04.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/18/Property-master/" title="Property_axil-master"><img class="cover" src="/img/chainsaw_makima04.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Property_axil-master</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/13/5-1-basic-master/" title="5-1 basic_master(上)"><img class="cover" src="/img/chainsaw_makima04.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">5-1 basic_master(上)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/11/13/5-1-basic-master/" title="5-1 basic_master(上)"><img class="cover" src="/img/chainsaw_makima04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-13</div><div class="title">5-1 basic_master(上)</div></div></a></div><div><a href="/2023/11/23/5-1-2-basic-master/" title="5-1 basic_master(下)"><img class="cover" src="/img/chainsaw_makima04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-23</div><div class="title">5-1 basic_master(下)</div></div></a></div><div><a href="/2023/12/06/MM2S/" title="MM2S"><img class="cover" src="/img/chainsaw_red.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-06</div><div class="title">MM2S</div></div></a></div><div><a href="/2023/11/18/Property-master/" title="Property_axil-master"><img class="cover" src="/img/chainsaw_makima04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-18</div><div class="title">Property_axil-master</div></div></a></div><div><a href="/2023/12/27/S2MM/" title="S2MM"><img class="cover" src="/img/chainsaw_red.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-27</div><div class="title">S2MM</div></div></a></div><div><a href="/2023/11/25/axi-master-full/" title="axi(full)master(上)"><img class="cover" src="/img/chainsaw_makima04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-25</div><div class="title">axi(full)master(上)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">冰蒂斯</div><div class="author-info__description">螺旋上升的人生,也是多线程的人生</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/more_study@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-AXI-Master-Logic"><span class="toc-number">1.</span> <span class="toc-text">1. AXI Master Logic</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-param-signals-wire"><span class="toc-number">2.</span> <span class="toc-text">2. param &amp; signals &amp;wire</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-parameters"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 parameters</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-AXI-signals"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 AXI signals</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-WB-signals"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 WB signals</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-address-data-width-conversion"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 address &amp; data width conversion</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-fixed-value"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 fixed value</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-register-declarations"><span class="toc-number">2.6.</span> <span class="toc-text">2.6 register declarations</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Overarching-command-logic"><span class="toc-number">3.</span> <span class="toc-text">3. Overarching command logic</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-change-direction"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 change direction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-flushing-logic"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 flushing logic</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-old-friend-skidbuffer"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 old friend: skidbuffer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-AXI-Signaling"><span class="toc-number">4.</span> <span class="toc-text">4. AXI Signaling</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Write-transactions-Partial"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 Write transactions (Partial)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-awvalid-wvalid"><span class="toc-number">4.1.1.</span> <span class="toc-text">1. awvalid &amp; wvalid</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-wdata"><span class="toc-number">4.1.2.</span> <span class="toc-text">2. wdata</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-wstrb"><span class="toc-number">4.1.3.</span> <span class="toc-text">3. wstrb</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-read-transaction-Partial"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 read transaction (Partial)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-awaddr-araddr"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 awaddr &amp; araddr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-ack-err%EF%BC%88%E7%9B%B8%E5%AF%B9%E8%BE%83%E9%9A%BE%EF%BC%89"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 ack &amp; err（相对较难）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-same-width"><span class="toc-number">4.4.1.</span> <span class="toc-text">1. same width</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-different-width"><span class="toc-number">4.4.2.</span> <span class="toc-text">2.different width</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-using-fifo-logic"><span class="toc-number">4.4.3.</span> <span class="toc-text">3.using fifo logic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shift-return-data"><span class="toc-number">4.4.4.</span> <span class="toc-text">shift return data</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">5.</span> <span class="toc-text">其他</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/01/11/AXI-Master-bursting/" title="difficult of AXI Master Bursting"><img src="/img/chainsaw_makima04.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="difficult of AXI Master Bursting"/></a><div class="content"><a class="title" href="/2024/01/11/AXI-Master-bursting/" title="difficult of AXI Master Bursting">difficult of AXI Master Bursting</a><time datetime="2024-01-11T08:52:33.000Z" title="发表于 2024-01-11 16:52:33">2024-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/10/Plan-XJY/" title="Plan_XJY"><img src="/img/chainsaw_power01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Plan_XJY"/></a><div class="content"><a class="title" href="/2024/01/10/Plan-XJY/" title="Plan_XJY">Plan_XJY</a><time datetime="2024-01-10T07:46:33.000Z" title="发表于 2024-01-10 15:46:33">2024-01-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/07/skid-buffer/" title="skid_buffer"><img src="/img/chainsaw_power01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="skid_buffer"/></a><div class="content"><a class="title" href="/2024/01/07/skid-buffer/" title="skid_buffer">skid_buffer</a><time datetime="2024-01-07T12:48:03.000Z" title="发表于 2024-01-07 20:48:03">2024-01-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/06/how2blog/" title="how2blog"><img src="/img/reze.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="how2blog"/></a><div class="content"><a class="title" href="/2024/01/06/how2blog/" title="how2blog">how2blog</a><time datetime="2024-01-06T14:34:23.000Z" title="发表于 2024-01-06 22:34:23">2024-01-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/27/S2MM/" title="S2MM"><img src="/img/chainsaw_red.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="S2MM"/></a><div class="content"><a class="title" href="/2023/12/27/S2MM/" title="S2MM">S2MM</a><time datetime="2023-12-27T05:57:36.000Z" title="发表于 2023-12-27 13:57:36">2023-12-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 冰蒂斯</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>