<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>axi(full)master(上) | 冰蒂斯のformula</title><meta name="author" content="冰蒂斯"><meta name="copyright" content="冰蒂斯"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 前言学习AXI protocol 还是需要系统的了解协议的内容，相关的时序逻辑约束。  Purpose: This file contains a set of formal properties which can be used to formally verify that a core truly follows the full AXI4 specification.  本章分为下">
<meta property="og:type" content="article">
<meta property="og:title" content="axi(full)master(上)">
<meta property="og:url" content="http://example.com/2023/11/25/axi-master-full/index.html">
<meta property="og:site_name" content="冰蒂斯のformula">
<meta property="og:description" content="1. 前言学习AXI protocol 还是需要系统的了解协议的内容，相关的时序逻辑约束。  Purpose: This file contains a set of formal properties which can be used to formally verify that a core truly follows the full AXI4 specification.  本章分为下">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/chainsaw_makima04.jpg">
<meta property="article:published_time" content="2023-11-25T03:09:42.000Z">
<meta property="article:modified_time" content="2023-11-30T09:35:37.451Z">
<meta property="article:author" content="冰蒂斯">
<meta property="article:tag" content="AXI">
<meta property="article:tag" content="master">
<meta property="article:tag" content="formalproperty">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/chainsaw_makima04.jpg"><link rel="shortcut icon" href="/img/bloodborn_lib.png"><link rel="canonical" href="http://example.com/2023/11/25/axi-master-full/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'axi(full)master(上)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-30 17:35:37'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/reze.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="冰蒂斯のformula"><span class="site-name">冰蒂斯のformula</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">axi(full)master(上)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-25T03:09:42.000Z" title="发表于 2023-11-25 11:09:42">2023-11-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-30T09:35:37.451Z" title="更新于 2023-11-30 17:35:37">2023-11-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/AXI/">AXI</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/AXI/master/">master</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="axi(full)master(上)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>学习AXI protocol 还是需要系统的了解协议的内容，相关的时序逻辑约束。</p>
<blockquote>
<p>Purpose: This file contains a set of formal properties which can be used to formally verify that a core truly follows the full AXI4 specification.</p>
</blockquote>
<p>本章分为下面的几个部分</p>
<h1 id="2-param-signals"><a href="#2-param-signals" class="headerlink" title="2. param &amp; signals"></a>2. param &amp; signals</h1><h2 id="2-1-parameter"><a href="#2-1-parameter" class="headerlink" title="2.1 parameter"></a>2.1 parameter</h2><ul>
<li><code>signal width</code></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">parameter</span> C_AXI_ID_WIDTH	= <span class="number">3</span>, <span class="comment">// The AXI id width used for R&amp;W</span></span><br><span class="line">                                <span class="comment">// This is an int between 1-16</span></span><br><span class="line"><span class="keyword">parameter</span> C_AXI_DATA_WIDTH	= <span class="number">128</span>,<span class="comment">// Width of the AXI R&amp;W data</span></span><br><span class="line"><span class="keyword">parameter</span> C_AXI_ADDR_WIDTH	= <span class="number">28</span>,	<span class="comment">// AXI Address width (log wordsize)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>burst setting</code>：Maximum burst length, minus 1</li>
<li><code>exclusive</code>：如果设置为1，则允许独占访问。目前并不知道这个信号的作用是什么</li>
<li><code>OPT_NARROW_BURST == 1</code>：<strong>Narrow bursts</strong> allowed by default</li>
<li><code>OPT_ASYNC_RESET</code> ：异步复位，暂时不考虑</li>
<li><code>F_OPT_ASSUME_RESET &amp;&amp; F_OPT_NO_RESET</code>：</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// F_OPT_ASSUME_RESET, if set, will cause the design to *assume* the</span></span><br><span class="line"><span class="comment">// existence of a correct reset, rather than asserting it.  It is</span></span><br><span class="line"><span class="comment">// appropriate anytime the reset logic is outside of the circuit being</span></span><br><span class="line"><span class="comment">// examined</span></span><br><span class="line"><span class="keyword">parameter</span> [<span class="number">0</span>:<span class="number">0</span>]			F_OPT_ASSUME_RESET = <span class="number">1&#x27;b1</span>,</span><br><span class="line"><span class="keyword">parameter</span> [<span class="number">0</span>:<span class="number">0</span>]			F_OPT_NO_RESET = <span class="number">1&#x27;b1</span>,</span><br></pre></td></tr></table></figure>

<ul>
<li>parameter about ： <code>stall &amp;&amp; wait &amp;&amp; delay</code></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// F_LGDEPTH is the number of bits necessary to count the maximum</span></span><br><span class="line"><span class="comment">// number of items in flight.</span></span><br><span class="line"><span class="keyword">parameter</span>				F_LGDEPTH      = <span class="number">10</span>,</span><br><span class="line"><span class="keyword">parameter</span>	[(F_LGDEPTH-<span class="number">1</span>):<span class="number">0</span>]	F_AXI_MAXSTALL = <span class="number">3</span>,</span><br><span class="line"><span class="keyword">parameter</span>	[(F_LGDEPTH-<span class="number">1</span>):<span class="number">0</span>]	F_AXI_MAXRSTALL= <span class="number">3</span>,</span><br><span class="line"><span class="keyword">parameter</span>	[(F_LGDEPTH-<span class="number">1</span>):<span class="number">0</span>]	F_AXI_MAXDELAY = <span class="number">3</span>,</span><br></pre></td></tr></table></figure>

<ul>
<li><code>F_OPT_READCHECK == 1</code>: if set to one, will generate and check a particular read burst, to make certain that it gets the appropriate response, ID, and LAST value.</li>
<li><code>F_OPT_INITIAL = 1</code> : if set, will insist on correct values on the intial timestep–the same timestep that should also have a reset</li>
<li><code>some localparam</code> :除了这部分开头的 <em>localparam</em>，其余相关参数需要使用再做说明。</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 maxburst 数量不是0, 那么就有 burst会发生，activate 相关的选项。</span></span><br><span class="line"><span class="keyword">localparam</span>			F_OPT_BURSTS    = (OPT_MAXBURST != <span class="number">0</span>),</span><br><span class="line"><span class="keyword">localparam</span> IW			= C_AXI_ID_WIDTH,</span><br><span class="line"><span class="keyword">localparam</span> DW			= C_AXI_DATA_WIDTH,</span><br><span class="line"><span class="keyword">localparam</span> AW			= C_AXI_ADDR_WIDTH</span><br></pre></td></tr></table></figure>

<h2 id="2-2-signals"><a href="#2-2-signals" class="headerlink" title="2.2 signals"></a>2.2 signals</h2><blockquote>
<p>system clock</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>			i_clk,	<span class="comment">// System clock</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>			i_axi_reset_n,</span><br></pre></td></tr></table></figure>

<blockquote>
<p>AW* : AXI write address channel signals</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>					i_axi_awvalid,	<span class="comment">// Write address valid</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>					i_axi_awready,<span class="comment">//Slave is ready to accept</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[IW-<span class="number">1</span>:<span class="number">0</span>]	i_axi_awid,	<span class="comment">// Write ID</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[AW-<span class="number">1</span>:<span class="number">0</span>]	i_axi_awaddr,	<span class="comment">// Write address</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[<span class="number">7</span>:<span class="number">0</span>]		i_axi_awlen,	<span class="comment">// Write Burst Length</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[<span class="number">2</span>:<span class="number">0</span>]		i_axi_awsize,	<span class="comment">// Write Burst size</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[<span class="number">1</span>:<span class="number">0</span>]		i_axi_awburst,	<span class="comment">// Write Burst type</span></span><br><span class="line"><span class="comment">// the signals I do not understand</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[<span class="number">0</span>:<span class="number">0</span>]		i_axi_awlock,	<span class="comment">// Write lock type</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[<span class="number">3</span>:<span class="number">0</span>]		i_axi_awcache,	<span class="comment">// Write Cache type</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[<span class="number">2</span>:<span class="number">0</span>]		i_axi_awprot,	<span class="comment">// Write Protection type</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[<span class="number">3</span>:<span class="number">0</span>]		i_axi_awqos,	<span class="comment">// Write Quality of Svc</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>W* : AXI write data channel signals</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>							i_axi_wvalid,	<span class="comment">// Write valid</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>							i_axi_wready,	<span class="comment">// Write data ready</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[DW-<span class="number">1</span>:<span class="number">0</span>]		i_axi_wdata,	<span class="comment">// Write data</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[DW/<span class="number">8</span>-<span class="number">1</span>:<span class="number">0</span>]	i_axi_wstrb,	<span class="comment">// Write strobes</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>							i_axi_wlast,	<span class="comment">// Last write transaction</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>B* : AXI write response channel signals</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>						i_axi_bvalid,  <span class="comment">// Write reponse valid</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>						i_axi_bready,  <span class="comment">// Response ready</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[IW-<span class="number">1</span>:<span class="number">0</span>]	i_axi_bid,		<span class="comment">// Response ID</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[<span class="number">1</span>:<span class="number">0</span>]			i_axi_bresp,	<span class="comment">// Write response</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>AR* : AXI read address channel signals</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>			i_axi_arvalid,	<span class="comment">// Read address valid</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>			i_axi_arready,	<span class="comment">// Read address ready</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[IW-<span class="number">1</span>:<span class="number">0</span>]	i_axi_arid,	<span class="comment">// Read ID</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[AW-<span class="number">1</span>:<span class="number">0</span>]	i_axi_araddr,	<span class="comment">// Read address</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[<span class="number">7</span>:<span class="number">0</span>]		i_axi_arlen,	<span class="comment">// Read Burst Length</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[<span class="number">2</span>:<span class="number">0</span>]		i_axi_arsize,	<span class="comment">// Read Burst size</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[<span class="number">1</span>:<span class="number">0</span>]		i_axi_arburst,	<span class="comment">// Read Burst type</span></span><br><span class="line"><span class="comment">// the signals I do not understand</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[<span class="number">0</span>:<span class="number">0</span>]		i_axi_arlock,	<span class="comment">// Read lock type</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[<span class="number">3</span>:<span class="number">0</span>]		i_axi_arcache,	<span class="comment">// Read Cache type</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[<span class="number">2</span>:<span class="number">0</span>]		i_axi_arprot,	<span class="comment">// Read Protection type</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[<span class="number">3</span>:<span class="number">0</span>]		i_axi_arqos,	<span class="comment">// Read Protection type</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>R* : AXI read data channel signals</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>						i_axi_rvalid,  <span class="comment">// Read reponse valid</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>						i_axi_rready,  <span class="comment">// Read Response ready</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[IW-<span class="number">1</span>:<span class="number">0</span>]	i_axi_rid,     <span class="comment">// Response ID</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[DW-<span class="number">1</span>:<span class="number">0</span>]	i_axi_rdata,    <span class="comment">// Read data</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[<span class="number">1</span>:<span class="number">0</span>]			i_axi_rresp,   <span class="comment">// Read response</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>						i_axi_rlast,    <span class="comment">// Read last</span></span><br></pre></td></tr></table></figure>

<p>其余的信号是关于数学归纳的<code>Induction information</code>， <code>AW W AR</code>三个通道的 <code>counter</code>。需要使用的时候再做深入了解。因为在外部的设置中，将单独访问的参数设置为0,所以暂时不考虑相关的设计。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#125;&#125;&#125;</span></span><br><span class="line"><span class="comment">// Induction information</span></span><br><span class="line"><span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">reg</span>	[F_LGDEPTH-<span class="number">1</span>:<span class="number">0</span>]		f_axi_awr_nbursts,</span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">reg</span>	[<span class="number">9</span>-<span class="number">1</span>:<span class="number">0</span>]			f_axi_wr_pending,</span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">reg</span>	[F_LGDEPTH-<span class="number">1</span>:<span class="number">0</span>]		f_axi_rd_nbursts,</span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">reg</span>	[F_LGDEPTH-<span class="number">1</span>:<span class="number">0</span>]		f_axi_rd_outstanding,</span><br><span class="line">	<span class="comment">// Address writes without write valids</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// WR_COUNT:</span></span><br><span class="line"><span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">reg</span>	[IW-<span class="number">1</span>:<span class="number">0</span>]					f_axi_wr_checkid,</span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">reg</span>										f_axi_wr_ckvalid,</span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">reg</span>	[F_LGDEPTH-<span class="number">1</span>:<span class="number">0</span>]		f_axi_wrid_nbursts,</span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">reg</span>	[AW-<span class="number">1</span>:<span class="number">0</span>]					f_axi_wr_addr,	<span class="comment">// Write address</span></span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">wire</span>	[<span class="number">7</span>:<span class="number">0</span>]						f_axi_wr_incr,</span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">reg</span>	[<span class="number">1</span>:<span class="number">0</span>]							f_axi_wr_burst,</span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">reg</span>	[<span class="number">2</span>:<span class="number">0</span>]							f_axi_wr_size,</span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">reg</span>	[<span class="number">7</span>:<span class="number">0</span>]							f_axi_wr_len,</span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">reg</span>										f_axi_wr_lockd,</span><br><span class="line"><span class="comment">// &#125;&#125;&#125;</span></span><br><span class="line"><span class="comment">// RD_COUNT: increment on read w/o last, cleared on read w/ last</span></span><br><span class="line"><span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span>	[IW-<span class="number">1</span>:<span class="number">0</span>]		f_axi_rd_checkid,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span>			    		f_axi_rd_ckvalid,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span>	[<span class="number">9</span>-<span class="number">1</span>:<span class="number">0</span>]			f_axi_rd_cklen,</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">reg</span>	[AW-<span class="number">1</span>:<span class="number">0</span>]		f_axi_rd_ckaddr,<span class="comment">// Read address</span></span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">wire</span>	[<span class="number">7</span>:<span class="number">0</span>]			f_axi_rd_ckincr,</span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">reg</span>	[<span class="number">1</span>:<span class="number">0</span>]				f_axi_rd_ckburst,</span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">reg</span>	[<span class="number">2</span>:<span class="number">0</span>]				f_axi_rd_cksize,</span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">reg</span>	[<span class="number">7</span>:<span class="number">0</span>]				f_axi_rd_ckarlen,</span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">reg</span>							f_axi_rd_cklockd,</span><br><span class="line"></span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">reg</span>	[F_LGDEPTH-<span class="number">1</span>:<span class="number">0</span>]		f_axi_rdid_nbursts,</span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">reg</span>	[F_LGDEPTH-<span class="number">1</span>:<span class="number">0</span>]		f_axi_rdid_outstanding,</span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">reg</span>	[F_LGDEPTH-<span class="number">1</span>:<span class="number">0</span>]		f_axi_rdid_ckign_nbursts,</span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">reg</span>	[F_LGDEPTH-<span class="number">1</span>:<span class="number">0</span>]		f_axi_rdid_ckign_outstanding,</span><br></pre></td></tr></table></figure>

<h2 id="2-3-something-first"><a href="#2-3-something-first" class="headerlink" title="2.3 something first"></a>2.3 something first</h2><blockquote>
<p>Parameter declarations</p>
</blockquote>
<p>对于 <em>axi</em> 协议的 <em>[1:0] resp</em>信号来说,如果最高位是<code>1</code>那么就意味着发生了 <em>abort</em> 或者<em>err</em>。如果正确相应，最高位一定是 <code>0</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">localparam</span> [<span class="number">1</span>:<span class="number">0</span>]	OKAY = <span class="number">2&#x27;b00</span>;</span><br><span class="line"><span class="keyword">localparam</span> [<span class="number">1</span>:<span class="number">0</span>]	EXOKAY = <span class="number">2&#x27;b01</span>;</span><br><span class="line"><span class="keyword">localparam</span>		F_AXI_MAXWAIT = F_AXI_MAXSTALL;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Because of the nature and size of bursts, which can be up to <strong>256 in length (AxLEN)</strong>, the <strong>F_LGDEPTH</strong> parameter necessary to capture this <em>must</em> be at <strong>least 8 bits wide</strong></p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">assert</span>(F_LGDEPTH &gt; <span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>同时对 data size 作出了限制：Only power of two data sizes are supported from 8-bits on up to 1024</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">assert</span>((DW == <span class="number">8</span>)</span><br><span class="line">		||(DW ==  <span class="number">16</span>)</span><br><span class="line">		||(DW ==  <span class="number">32</span>)</span><br><span class="line">		||(DW ==  <span class="number">64</span>)</span><br><span class="line">		||(DW == <span class="number">128</span>)</span><br><span class="line">		||(DW == <span class="number">256</span>)</span><br><span class="line">		||(DW == <span class="number">512</span>)</span><br><span class="line">		||(DW == <span class="number">1024</span>));</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>一些可能用到的信号，这里只是对他们进行列举，后面具体使用的时候在进一步补全。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Internal register and wire declarations</span></span><br><span class="line"><span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">wire</span>	axi_rd_ack, axi_wr_ack, axi_ard_req, axi_awr_req, axi_wr_req;</span><br><span class="line">	<span class="comment">// axi_rd_err, axi_wr_err;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">assign</span>	axi_ard_req = (i_axi_arvalid)&amp;&amp;(i_axi_arready);</span><br><span class="line"><span class="keyword">assign</span>	axi_awr_req = (i_axi_awvalid)&amp;&amp;(i_axi_awready);</span><br><span class="line"><span class="keyword">assign</span>	axi_wr_req  = (i_axi_wvalid )&amp;&amp;(i_axi_wready);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">assign</span>	axi_rd_ack = (i_axi_rvalid)&amp;&amp;(i_axi_rready);</span><br><span class="line"><span class="keyword">assign</span>	axi_wr_ack = (i_axi_bvalid)&amp;&amp;(i_axi_bready);</span><br><span class="line"><span class="comment">// assign axi_rd_err = (axi_rd_ack)&amp;&amp;(i_axi_rresp[1]);</span></span><br><span class="line"><span class="comment">// assign axi_wr_err = (axi_wr_ack)&amp;&amp;(i_axi_bresp[1]);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>								f_past_valid;</span><br><span class="line"><span class="keyword">reg</span>		[<span class="number">3</span>:<span class="number">0</span>]				f_reset_length;</span><br><span class="line"><span class="keyword">reg</span>		[AW-<span class="number">1</span>:<span class="number">0</span>]		r_axi_wr_addr;</span><br><span class="line"><span class="keyword">wire</span>	[AW-<span class="number">1</span>:<span class="number">0</span>]		next_wr_addr;</span><br><span class="line"><span class="comment">// wire	[7:0]		this_wr_incr;</span></span><br><span class="line"><span class="keyword">reg</span>	[<span class="number">2</span>:<span class="number">0</span>]				this_awsize;</span><br><span class="line"><span class="keyword">reg</span>							wr_aligned, awr_aligned,</span><br><span class="line">								rd_aligned, ard_aligned;</span><br><span class="line"><span class="keyword">reg</span>							rd_pending;</span><br><span class="line"><span class="keyword">wire</span>	[AW-<span class="number">1</span>:<span class="number">0</span>]	next_rd_addr;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-Assert-Assume"><a href="#2-4-Assert-Assume" class="headerlink" title="2.4 Assert &amp; Assume"></a>2.4 Assert &amp; Assume</h2><blockquote>
<p>Within the <strong>slave core,</strong> we will <strong>*assume</strong>* properties from the <strong>master</strong>,and <strong>*assert</strong>* properties of <strong>signals coming from the slave and returning to the master</strong>.</p>
<p>This <strong>order will be reversed</strong> within the master, and the following two definitions help us do that. Similarly, we will always <strong>*assert</strong>* local values of our own necessary for checks below. Those will use the assert() keyword, rather than either of these two macros</p>
<p>salve与master中的信号 assume 和 assert 需要区分开。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">define</span>	SLAVE_ASSUME	assert</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span>	SLAVE_ASSERT	assume</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="2-5-set-up"><a href="#2-5-set-up" class="headerlink" title="2.5 set up"></a>2.5 set up</h2><p>一个经典的使用方式，来进行信号的初始化。还是强调，波形图中的第一个周期实际上是 <code>initial cycle</code>实际上属于第 <code>0</code>个周期；</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Setup   integer	k;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span>	f_past_valid = <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">	f_past_valid &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line"><span class="keyword">if</span> (!f_past_valid)</span><br><span class="line">	<span class="keyword">assert</span>(!i_axi_reset_n);</span><br></pre></td></tr></table></figure>



<h1 id="3-reset-property"><a href="#3-reset-property" class="headerlink" title="3. reset property"></a>3. reset property</h1><h2 id="3-1-reset-remain-16-clocks"><a href="#3-1-reset-remain-16-clocks" class="headerlink" title="3.1 reset remain 16 clocks"></a>3.1 reset remain 16 clocks</h2><blockquote>
<p>Insist that the reset signal start out asserted (negative), and remain so for 16 clocks.</p>
</blockquote>
<p>如果这里设置了参数 <code>    F_OPT_ASSUME_RESET</code>，表示无外界的<em>reset</em> 信号，需要<em>assume</em> 。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">generate</span> <span class="keyword">if</span> (F_OPT_ASSUME_RESET)</span><br><span class="line">   <span class="comment">// assume the initial reset</span></span><br><span class="line"><span class="keyword">begin</span> : ASSUME_INITIAL_RESET</span><br><span class="line">	<span class="keyword">always</span> @(*)</span><br><span class="line">	<span class="keyword">if</span> (!f_past_valid)</span><br><span class="line">		<span class="keyword">assume</span>(!i_axi_reset_n);</span><br><span class="line">   <span class="comment">//assert the initial reset</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span> : ASSERT_INITIAL_RESET</span><br><span class="line">	<span class="keyword">always</span> @(*)</span><br><span class="line">	<span class="keyword">if</span> (!f_past_valid)</span><br><span class="line">		<span class="keyword">assert</span>(!i_axi_reset_n);</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">endgenerate</span></span><br></pre></td></tr></table></figure>

<h3 id="1-reset-within-core"><a href="#1-reset-within-core" class="headerlink" title="1. reset within core"></a>1. reset within core</h3><blockquote>
<p>If asserted, the reset must be asserted for a minimum of 16 clocks</p>
</blockquote>
<p>这里的<em>16</em> 个时钟周期的复位需要一个计数器 <code>[3:0] f_reset_length</code>.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	f_reset_length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (F_OPT_NO_RESET || i_axi_reset_n)</span><br><span class="line">	f_reset_length &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!(&amp;f_reset_length))</span><br><span class="line">	f_reset_length &lt;= f_reset_length + <span class="number">1&#x27;b1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">     <span class="keyword">if</span> ((f_past_valid)			&amp;&amp;   <span class="comment">// no initial clock cycle</span></span><br><span class="line">         !F_OPT_NO_RESET 			&amp;&amp; 	 <span class="comment">// has outside reset signal , do not assume</span></span><br><span class="line">         (!<span class="built_in">$past</span>(i_axi_reset_n))	&amp;&amp;</span><br><span class="line">         (!<span class="built_in">$past</span>(&amp;f_reset_length)))</span><br><span class="line">       </span><br><span class="line">       `SLAVE_ASSUME(!i_axi_reset_n);   <span class="comment">// define `SLAVE_ASSUME  assert</span></span><br></pre></td></tr></table></figure>

<p>上面的代码是针对 <code>F_OPT_NO_RESET == 1</code>的设计， 这里最重要的一点是  <code>!$past(&amp;f_reset_length))== 1</code>会使得下一个 <em>clock cycle</em> 中的  <code>i_axi_reset_n</code>信号保持低电平复位状态！</p>
<h3 id="2-reset-not-within-core"><a href="#2-reset-not-within-core" class="headerlink" title="2. reset not within core"></a>2. reset not within core</h3><blockquote>
<p>If the reset is not generated within this particular core, then it can be assumed if <code>F_OPT_ASSUME_RESET</code> is set</p>
</blockquote>
<p>下面的代码不做过多的解释。不过我这里有一个疑问： <code>3.1.1 、3.1.2</code>两个小结的代码是怎么一起仿真的。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// has reset signal outside , but we still need to assume it to</span></span><br><span class="line"><span class="comment">// make sure the signal is definately right</span></span><br><span class="line"><span class="keyword">generate</span> <span class="keyword">if</span> (F_OPT_ASSUME_RESET &amp;&amp; !F_OPT_NO_RESET)</span><br><span class="line"><span class="keyword">begin</span> : ASSUME_RESET</span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">	<span class="keyword">if</span> ((f_past_valid)&amp;&amp;(!<span class="built_in">$past</span>(i_axi_reset_n))&amp;&amp;(!<span class="built_in">$past</span>(&amp;f_reset_length)))</span><br><span class="line">		<span class="keyword">assume</span>(!i_axi_reset_n);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">always</span> @(*)</span><br><span class="line">	<span class="keyword">if</span> ((f_reset_length &gt; <span class="number">0</span>)&amp;&amp;(f_reset_length &lt; <span class="number">4&#x27;hf</span>))</span><br><span class="line">		<span class="keyword">assume</span>(!i_axi_reset_n);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// just assert the outside RESET signal</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (!F_OPT_NO_RESET)</span><br><span class="line"><span class="keyword">begin</span> : ASSERT_RESET</span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">	<span class="keyword">if</span> ((f_past_valid)&amp;&amp;(!<span class="built_in">$past</span>(i_axi_reset_n))&amp;&amp;(!<span class="built_in">$past</span>(&amp;f_reset_length)))</span><br><span class="line">		<span class="keyword">assert</span>(!i_axi_reset_n);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">always</span> @(*)</span><br><span class="line">	<span class="keyword">if</span> ((f_reset_length &gt; <span class="number">0</span>)&amp;&amp;(f_reset_length &lt; <span class="number">4&#x27;hf</span>))</span><br><span class="line">		<span class="keyword">assert</span>(!i_axi_reset_n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">endgenerate</span></span><br></pre></td></tr></table></figure>



<h2 id="3-2-valid-reset"><a href="#3-2-valid-reset" class="headerlink" title="3.2  *_valid reset"></a>3.2  *_valid reset</h2><blockquote>
<p>All of the xVALID signals <em>MUST</em> be set low on the clock following a reset.  (See Fig A3-1) Not in the spec, but also checked here is that they must also be set low initially.</p>
</blockquote>
<ul>
<li><em>Situation1</em>:  in the initial clock cycle , show as <code>(!f_past_valid &amp;&amp; F_OPT_INITIAL)</code></li>
<li><em>Situation2</em>:  not in the initial cycle  but reset  , show as <code>(f_past_valid &amp;&amp; !$past(i_axi_reset_n))</code></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> ((!f_past_valid &amp;&amp; F_OPT_INITIAL)||(f_past_valid &amp;&amp; !<span class="built_in">$past</span>(i_axi_reset_n)))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">       <span class="comment">// assert the master</span></span><br><span class="line">	`SLAVE_ASSUME(!i_axi_arvalid);</span><br><span class="line">	`SLAVE_ASSUME(!i_axi_awvalid);</span><br><span class="line">	`SLAVE_ASSUME(!i_axi_wvalid);</span><br><span class="line">	<span class="comment">// assume the slave</span></span><br><span class="line">	`SLAVE_ASSERT(!i_axi_bvalid);</span><br><span class="line">	`SLAVE_ASSERT(!i_axi_rvalid);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h1 id="4-stable-property"><a href="#4-stable-property" class="headerlink" title="4. stable property"></a>4. stable property</h1><p>what happens if <code>valid and not ready</code>，经典的 <code>VBR question</code>。</p>
<blockquote>
<p><strong>To</strong> master : <em>ASSERT</em> any <em>request</em> from the bus will not change prior to that <em>request</em> being accepted</p>
<p><strong>From</strong> slave :  <em>ASSUME</em> any <em>response</em> from the bus will not change prior to that <em>response</em> being accepted</p>
</blockquote>
<h2 id="4-1-Reset-release"><a href="#4-1-Reset-release" class="headerlink" title="4.1 Reset release"></a>4.1 Reset release</h2><p>在开始的时候需要了解一个表示方法： <code>($past(i_axi_reset_n)&amp;&amp; i_axi_reset_n)</code>.</p>
<ul>
<li><em>Situation1</em>:<code>$past(i_axi_reset_n)==1</code> means that the last cycle there is no reset happended;</li>
<li><em>Situation2</em>: <code>i_axi_reset_n ==1</code>  means the cycle  there is no reset happended;</li>
</ul>
<p>上一个时钟周期发现没有复位，本周期也没有进行复位，意味着什么？ <strong>复位释放</strong>！</p>
<p>不过需要考虑复位释放的情况需要设置 <code>OPT_ASYNC_RESET ==1</code>，表示有异步复位的相关设计。如果设置为 <code>0</code>，那么情况会简单许多，只需要条件 <code>(f_past_valid)&amp;&amp; $past(i_axi_reset_n)</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> ((f_past_valid)&amp;&amp; <span class="built_in">$past</span>(i_axi_reset_n)</span><br><span class="line">	&amp;&amp; (!OPT_ASYNC_RESET || i_axi_reset_n))</span><br><span class="line"><span class="keyword">begin</span></span><br></pre></td></tr></table></figure>

<h2 id="4-2-five-channel"><a href="#4-2-five-channel" class="headerlink" title="4.2  five channel"></a>4.2  five channel</h2><blockquote>
<p>Write address channel</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((f_past_valid)&amp;&amp;(<span class="built_in">$past</span>(i_axi_awvalid &amp;&amp; !i_axi_awready)))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	`SLAVE_ASSUME(i_axi_awvalid);</span><br><span class="line">	`SLAVE_ASSUME(<span class="built_in">$stable</span>(i_axi_awaddr));</span><br><span class="line">	`SLAVE_ASSUME(<span class="built_in">$stable</span>(i_axi_awid));</span><br><span class="line">	`SLAVE_ASSUME(<span class="built_in">$stable</span>(i_axi_awlen));</span><br><span class="line">	`SLAVE_ASSUME(<span class="built_in">$stable</span>(i_axi_awsize));</span><br><span class="line">	`SLAVE_ASSUME(<span class="built_in">$stable</span>(i_axi_awburst));</span><br><span class="line">	`SLAVE_ASSUME(<span class="built_in">$stable</span>(i_axi_awlock));</span><br><span class="line">	`SLAVE_ASSUME(<span class="built_in">$stable</span>(i_axi_awcache));</span><br><span class="line">	`SLAVE_ASSUME(<span class="built_in">$stable</span>(i_axi_awprot));</span><br><span class="line">	`SLAVE_ASSUME(<span class="built_in">$stable</span>(i_axi_awqos));</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Write data channel</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((f_past_valid)&amp;&amp;(<span class="built_in">$past</span>(i_axi_wvalid &amp;&amp; !i_axi_wready)))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	`SLAVE_ASSUME(i_axi_wvalid);</span><br><span class="line">	`SLAVE_ASSUME(<span class="built_in">$stable</span>(i_axi_wstrb));</span><br><span class="line">	`SLAVE_ASSUME(<span class="built_in">$stable</span>(i_axi_wdata));</span><br><span class="line">	`SLAVE_ASSUME(<span class="built_in">$stable</span>(i_axi_wlast));</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Incoming Read address channel</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((f_past_valid)&amp;&amp;(<span class="built_in">$past</span>(i_axi_arvalid &amp;&amp; !i_axi_arready)))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	`SLAVE_ASSUME(i_axi_arvalid);</span><br><span class="line">	`SLAVE_ASSUME(<span class="built_in">$stable</span>(i_axi_arid));</span><br><span class="line">	`SLAVE_ASSUME(<span class="built_in">$stable</span>(i_axi_araddr));</span><br><span class="line">	`SLAVE_ASSUME(<span class="built_in">$stable</span>(i_axi_arlen));</span><br><span class="line">	`SLAVE_ASSUME(<span class="built_in">$stable</span>(i_axi_arsize));</span><br><span class="line">	`SLAVE_ASSUME(<span class="built_in">$stable</span>(i_axi_arburst));</span><br><span class="line">	`SLAVE_ASSUME(<span class="built_in">$stable</span>(i_axi_arlock));</span><br><span class="line">	`SLAVE_ASSUME(<span class="built_in">$stable</span>(i_axi_arcache));</span><br><span class="line">	`SLAVE_ASSUME(<span class="built_in">$stable</span>(i_axi_arprot));</span><br><span class="line">	`SLAVE_ASSUME(<span class="built_in">$stable</span>(i_axi_arqos));</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Assume any response from the bus will not change prior to that response being accepted</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((f_past_valid)&amp;&amp;(<span class="built_in">$past</span>(i_axi_rvalid &amp;&amp; !i_axi_rready)))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">        	<span class="comment">// define `SLAVE_ASSERT assume</span></span><br><span class="line">	`SLAVE_ASSERT(i_axi_rvalid);</span><br><span class="line">	`SLAVE_ASSERT(<span class="built_in">$stable</span>(i_axi_rid));</span><br><span class="line">	`SLAVE_ASSERT(<span class="built_in">$stable</span>(i_axi_rresp));</span><br><span class="line">	`SLAVE_ASSERT(<span class="built_in">$stable</span>(i_axi_rdata));</span><br><span class="line">	`SLAVE_ASSERT(<span class="built_in">$stable</span>(i_axi_rlast));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((f_past_valid)&amp;&amp;(<span class="built_in">$past</span>(i_axi_bvalid &amp;&amp; !i_axi_bready)))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">        	<span class="comment">// define `SLAVE_ASSERT assume</span></span><br><span class="line">	`SLAVE_ASSERT(i_axi_bvalid);</span><br><span class="line">	`SLAVE_ASSERT(<span class="built_in">$stable</span>(i_axi_bid));</span><br><span class="line">	`SLAVE_ASSERT(<span class="built_in">$stable</span>(i_axi_bresp));</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h1 id="5-Maximum-Wait"><a href="#5-Maximum-Wait" class="headerlink" title="5. Maximum Wait"></a>5. Maximum Wait</h1><blockquote>
<p>Insist upon a maximum delay before a request is accepted</p>
</blockquote>
<p>声明三个<em>counter</em>， <code>reg [(F_LGDEPTH-1):0]</code>   <code>f_axi_awstall</code>, <code>f_axi_wstall</code>,  <code>f_axi_arstall</code>;</p>
<h2 id="5-1-write-address-channel"><a href="#5-1-write-address-channel" class="headerlink" title="5.1 write address channel"></a>5.1 write address channel</h2><blockquote>
<p><strong>Count the number</strong> of times AWVALID is true while AWREADY is false.  <strong>These are stalls</strong>, and we want to insist on a minimum number of them.  </p>
<p>However, if <code>BVALID &amp;&amp; !BREADY</code>, then <strong>there’s a reason for not accepting anything more</strong>.</p>
<p>Similarly, many cores will only ever accept one request at a time, hence we won’t count things as stalls if <code>WR-PENDING &gt; 0</code>.</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	f_axi_awstall = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> ((!i_axi_reset_n)||</span><br><span class="line">          (!i_axi_awvalid)||</span><br><span class="line">          (i_axi_awready) ||</span><br><span class="line">          (f_axi_wr_pending &gt; <span class="number">0</span>))  </span><br><span class="line">        </span><br><span class="line">	f_axi_awstall &lt;= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((!i_axi_bvalid)||(i_axi_bready))</span><br><span class="line">	f_axi_awstall &lt;= f_axi_awstall + <span class="number">1&#x27;b1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line">        	<span class="comment">// it&#x27;s the property slave should obey, so use ASSUME</span></span><br><span class="line">	`SLAVE_ASSERT(f_axi_awstall &lt; F_AXI_MAXWAIT);</span><br></pre></td></tr></table></figure>

<p>对这里的  <code>(f_axi_wr_pending &gt; 0)</code>并不理解。我不清楚这个处理方式和下方的处理方式是否一致？</p>
<blockquote>
<p>在 <em>axi-lite</em> 协议中，<code>AW W</code>双通道的数据传递到 <code>slave</code>端需要进行 <code>synchoronize</code>同步处理。如果 <code>AW</code>的 <code>ready</code>信号已经为 <code>true</code>，但是如果 <code>W</code>通道的 <code>data</code>并不是有效信号 —<code>!valid</code>，此时不算 <code>stall</code>处理。</p>
<p>(见(<a target="_blank" rel="noopener" href="http://xlxwzybds.cn/2023/11/18/Property-master/">Property_axil-master AXI Write Address channel | 冰蒂斯の博客 (xlxwzybds.cn) </a>))</p>
</blockquote>
<h2 id="5-2-write-data-channel"><a href="#5-2-write-data-channel" class="headerlink" title="5.2 write data channel"></a>5.2 write data channel</h2><blockquote>
<p><strong>Purpose</strong>:  Count the number of clock cycles that the write data channel is stalled, that is while <code>WVALID &amp;&amp; !WREADY</code>. </p>
<p><strong>Attention</strong>: Since things can back up if <code>BVALID &amp; !BREADY</code>, we avoid counting clock cycles in that circumstance</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	f_axi_wstall = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> ((!i_axi_reset_n)||</span><br><span class="line">          (!i_axi_wvalid) ||</span><br><span class="line">          (i_axi_wready)  ||</span><br><span class="line">          (f_axi_wr_pending == <span class="number">0</span> &amp;&amp; i_axi_wvalid))</span><br><span class="line">        </span><br><span class="line">	f_axi_wstall &lt;= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((!i_axi_bvalid)||(i_axi_bready))</span><br><span class="line">	f_axi_wstall &lt;= f_axi_wstall + <span class="number">1&#x27;b1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line">	`SLAVE_ASSERT(f_axi_wstall &lt; F_AXI_MAXWAIT);</span><br></pre></td></tr></table></figure>

<p>在这段代码中唯一一个难以理解的段落是 <code>(f_axi_wr_pending == 0 &amp;&amp; i_axi_wvalid)</code>。需要结合<em>axi-lite</em>的信息来理解，先回顾一下<em>axi-lite</em>相关代码：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f_axi_wr_outstanding &gt;= f_axi_awr_outstanding)</span><br><span class="line">	&amp;&amp;(!i_axi_awvalid &amp;&amp; i_axi_wvalid))</span><br><span class="line">	<span class="comment">// If we are waiting for the write address channel</span></span><br><span class="line">	<span class="comment">// to be valid, then don&#x27;t count stalls</span></span><br></pre></td></tr></table></figure>

<p>综合来看，该段代码表示：当没有写请求正在等待（<code>f_axi_wr_pending == 0</code>）并且有一个有效的写请求（<code>i_axi_wvalid</code>）时的情况，不会计算位 <em>stall</em></p>
<h2 id="5-3-read-address-channel"><a href="#5-3-read-address-channel" class="headerlink" title="5.3 read address channel"></a>5.3 read address channel</h2><blockquote>
<p><strong>Purpose</strong>: Similar to the first two above, once the master raises <code>ARVALID</code>, insist that the slave respond within a minimum number of clock cycles. </p>
<p><strong>Attention</strong>: </p>
<ul>
<li>Exceptions include any time <code>RVALID</code> is true, since that can back up the whole system;</li>
<li>and any time the <strong>number of bursts is greater than zero</strong>, since many slaves can only accept one request at a time.</li>
</ul>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	f_axi_arstall = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> ((!i_axi_reset_n)||</span><br><span class="line">          (!i_axi_arvalid)||</span><br><span class="line">          (i_axi_arready) ||</span><br><span class="line">          (i_axi_rvalid)||(f_axi_rd_nbursts &gt; <span class="number">0</span>))</span><br><span class="line">	f_axi_arstall &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	f_axi_arstall &lt;= f_axi_arstall + <span class="number">1&#x27;b1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line">	`SLAVE_ASSERT(f_axi_arstall &lt; F_AXI_MAXWAIT);</span><br></pre></td></tr></table></figure>

<p><font color="red">问题是怎么理解f_axi_rd_nbursts &gt; 0</font></p>
<h1 id="6-Maximum-stall"><a href="#6-Maximum-stall" class="headerlink" title="6. Maximum stall"></a>6. Maximum stall</h1><blockquote>
<p>Description：Insist upon a maximum delay before any response is accepted</p>
<p>Behavior： These are separate from the earlier ones, in case you wish to control them separately.  </p>
<p>Example：For example, an interconnect might be forced to let a channel wait indefinitely for access, but it might not be appropriate to require the response to be able to wait indefinitely as well</p>
</blockquote>
<p>怎么理解在总线互联中，可以强制master wait 一段时间，但是不适合强制master stall the resp from slave ？</p>
<h2 id="6-1-W-valid"><a href="#6-1-W-valid" class="headerlink" title="6.1 W valid"></a>6.1 W valid</h2><h2 id="6-2-B-channel"><a href="#6-2-B-channel" class="headerlink" title="6.2 B channel"></a>6.2 B channel</h2><h2 id="6-3-R-channel"><a href="#6-3-R-channel" class="headerlink" title="6.3 R channel"></a>6.3 R channel</h2><h1 id="7-count-outstanding-transaction"><a href="#7-count-outstanding-transaction" class="headerlink" title="7. count outstanding transaction"></a>7. count outstanding transaction</h1><h2 id="7-1-aw-pending"><a href="#7-1-aw-pending" class="headerlink" title="7.1 aw_pending"></a>7.1 aw_pending</h2><blockquote>
<p> With these measures, we count once per any burst. 每次 write burst operation 都是对于一个 ID_slave。所以在<em>formal propertry</em> 中应该随时对<em>id</em> 的数值进行切换。</p>
<p> 下面的代码的作用可能和 <code>f_past_valid</code>信号的作用差不多。</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line">	f_axi_wr_checkid = r_axi_wr_checkid;</span><br></pre></td></tr></table></figure>

<p>主要注意两个<em>counter</em> 的使用：（更新1；该部分 <em>pending</em> 寄存器的使用方法我是在 <em>7.3</em> 小结中才弄清楚了）</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	f_axi_wr_pending = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">initial</span>	f_axi_wr_ckvalid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (!i_axi_reset_n)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	f_axi_wr_pending &lt;= <span class="number">0</span>;</span><br><span class="line">	f_axi_wr_ckvalid &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">case</span>(&#123; axi_awr_req, axi_wr_req &#125;)</span><br><span class="line">   <span class="comment">//assign	axi_awr_req = (i_axi_awvalid)&amp;&amp;(i_axi_awready);</span></span><br><span class="line"><span class="comment">//assign	axi_wr_req  = (i_axi_wvalid )&amp;&amp;(i_axi_wready);</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>f_axi_wr_pending</code> 是一个计数器，用于跟踪待处理的写操作的数量。<ul>
<li>当有一个新的写请求（<em>axi_awr_req</em>）时，它会置位 <code>i_axi_awlen+1</code>，表示有 <code>i_axi_awlen+1</code> 个写操作待处理。</li>
<li>当一个写操作完成（<em>axi_wr_req</em>）时，它会减少1。</li>
<li>如果所有的写操作都已完成（<em>i_axi_wlast</em>），那么它会被重置为<code>0</code>。</li>
</ul>
</li>
<li><code>f_axi_wr_ckvalid</code> 是一个标志，用于检查当前的写操作是否有效。<ul>
<li>当有一个新的写请求（<em>axi_awr_req</em>）或者两个请求同时发生（<em>axi_awr_req</em> 和 <em>axi_wr_req</em>）时，它会检查 <code>i_axi_awid</code> 是否等于 <code>f_axi_wr_checkid</code> 来确定写操作是否有效。</li>
<li>如果所有的写操作都已完成（<em>i_axi_wlast</em>），那么它会被重置为<code>0</code>。</li>
</ul>
</li>
</ul>
<blockquote>
<p>下面进行详细的分析</p>
</blockquote>
<p>当有一个新的写请求（<em>axi_awr_req</em>）时，它会置位 <code>i_axi_awlen+1</code>，表示有 <code>i_axi_awlen+1</code> 个写操作待处理。当有一个新的写请求（<em>axi_awr_req</em>）发生时，它会检查 <code>i_axi_awid</code> 是否等于 <code>f_axi_wr_checkid</code> 来确定写操作是否有效。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2&#x27;b10</span>: <span class="keyword">begin</span></span><br><span class="line">	<span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line">	f_axi_wr_pending &lt;= i_axi_awlen+<span class="number">1</span>;</span><br><span class="line">	f_axi_wr_ckvalid &lt;= (i_axi_awid == f_axi_wr_checkid);</span><br><span class="line">	<span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>必须要求有 <code>f_axi_wr_pending &gt; 0</code>。<em>axi</em> 协议中<em>AW</em> 和 <em>W</em> 双通道分离，没有时序约束。但是在具体的实现中一般要求<em>AW</em>在<em>W</em>之前或同时传输。所以在进行<em>w_data</em> 传输时，此时<em>master</em>或者<em>slave</em>已经知道了本次传输数据的长度 <code>awlen</code>，因此出现本次的<em>assert</em>检测项。</p>
<p>如果是最后一个需要传输的信号 <code>wlast==1</code>，此时需要传输的数据恰好 <code>(f_axi_wr_pending == 1)</code>；</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2&#x27;b01</span>: <span class="keyword">begin</span></span><br><span class="line">	<span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line">	`SLAVE_ASSUME(f_axi_wr_pending &gt; <span class="number">0</span>);</span><br><span class="line">       <span class="comment">// the datas that need to be transfered minus one !</span></span><br><span class="line">	f_axi_wr_pending &lt;= f_axi_wr_pending - <span class="number">1&#x27;b1</span>;</span><br><span class="line">	`SLAVE_ASSUME(!i_axi_wlast || (f_axi_wr_pending == <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">if</span> (i_axi_wlast)</span><br><span class="line">         	<span class="comment">// once the last data of one burst transaction has been transfered ,</span></span><br><span class="line">         	<span class="comment">// the id_formal which need to be checked should be set zero</span></span><br><span class="line">		f_axi_wr_ckvalid &lt;= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p> Q: 同时<em>AW</em>和<em>W</em>双通道握手应该怎么处理？</p>
<p> 我直接一手岁月史书，引用 7.3 小结的内容：The first case is that the <code>WVALID</code> applies to the last item of the previous burst.  Otherwise, it could be the data associated with this new burst described by AW*</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2&#x27;b11</span>: <span class="keyword">begin</span></span><br><span class="line">	f_axi_wr_ckvalid &lt;= (i_axi_awid == f_axi_wr_checkid);</span><br><span class="line">     	</span><br><span class="line">	<span class="keyword">if</span> (f_axi_wr_pending &gt; <span class="number">0</span>)</span><br><span class="line">		f_axi_wr_pending &lt;= i_axi_awlen+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">		f_axi_wr_pending &lt;= &#123; <span class="number">1&#x27;b0</span>, i_axi_awlen &#125;;</span><br><span class="line">		<span class="keyword">if</span> (i_axi_awlen == <span class="number">0</span>)</span><br><span class="line">			f_axi_wr_ckvalid &lt;= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="ID-7-2-useful-wr-ckvalid"><a href="#ID-7-2-useful-wr-ckvalid" class="headerlink" title="ID- 7.2  useful  *_wr_ckvalid"></a>ID- 7.2  useful  *_wr_ckvalid</h2><p>在前面的 <code>7.1</code>小结中主角是信号<em>pending</em>，但是在每次的逻辑处理中频繁的出现一个验证信号<em>f_axi_wr_ckvalid</em>信号。本小结谈论这个信号的作用。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line"><span class="keyword">if</span> (f_axi_wr_ckvalid)</span><br><span class="line">	<span class="keyword">assert</span>((f_axi_wrid_nbursts &gt; <span class="number">0</span>)&amp;&amp;(f_axi_wr_pending &gt; <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>目前不清楚，先跳过</p>
<h2 id="7-3-Assert-on-pending-wlast"><a href="#7-3-Assert-on-pending-wlast" class="headerlink" title="7.3 Assert on pending &amp; wlast"></a>7.3 Assert on pending &amp; wlast</h2><p>本小结主题是： <em>assertions on f_axi_wr_pending, wlast</em></p>
<h3 id="1-sth-you-should-know-first"><a href="#1-sth-you-should-know-first" class="headerlink" title="1. sth you should know first"></a>1. sth you should know first</h3><p>再次强调<em>axi protocol</em> 中出现的问题：<em>protocol</em> 中并没有要求 <em>aw</em> 和 <em>w</em> 通道的先后顺序，只是说两个通道之间没有时序约束，都是自由的。实际真的如此吗？真是的设计中必然会有其他的情况会对此进行约束。</p>
<blockquote>
<p>Insist that no <code>WVALID</code> value show up prior to a <code>AWVALID</code> value.  The address <em><code>MUST</code></em> come first. 【看吧，在zipcpu的设计中，<em>address</em> 先行于 <em>data</em>。】</p>
<p> Further, while <strong>waiting</strong> for the write data, <strong>NO OTHER WRITE ADDRESS may be permitted</strong>.  This is not strictly required by the specification, but it is required in order to make these properties work (currently–I might revisit this later) 【在一个burst中的时候，不能加发起另一个write address，这是对于一个从设备的限制吗？还是具体硬件实现的限制？】</p>
</blockquote>
<h3 id="2-The-property"><a href="#2-The-property" class="headerlink" title="2. The  property"></a>2. The  property</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line"><span class="keyword">if</span> (F_OPT_INITIAL || f_past_valid)</span><br><span class="line"><span class="keyword">case</span>(&#123;i_axi_awvalid, i_axi_wvalid&#125;)</span><br><span class="line">	<span class="comment">// If AWVALID is true but not WVALID, then no other write</span></span><br><span class="line">	<span class="comment">// requests shall be pending.  This makes certain that the</span></span><br><span class="line">	<span class="comment">// new address doesn&#x27;t get mixed up with any prior responses</span></span><br><span class="line">	<span class="comment">// from the slave</span></span><br><span class="line"><span class="number">2&#x27;b10</span>: `SLAVE_ASSUME(f_axi_wr_pending == <span class="number">0</span>);</span><br><span class="line"><span class="number">2&#x27;b01</span>: <span class="keyword">begin</span></span><br><span class="line">	<span class="comment">// On the other hand, if WVALID is true but not AWVALID,</span></span><br><span class="line">	<span class="comment">// then we only need to double check that there&#x27;s at least</span></span><br><span class="line">	<span class="comment">// one pending value to be returned.  If this is the last value,</span></span><br><span class="line">	<span class="comment">// make certain that it is so marked.</span></span><br><span class="line">	`SLAVE_ASSUME(f_axi_wr_pending &gt; <span class="number">0</span>);</span><br><span class="line">	`SLAVE_ASSUME(i_axi_wlast == (f_axi_wr_pending == <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li><em>situation1</em>:  <code>2&#39;b10</code>，确保在新写入 <em>aw_address</em> 的时候，上一次 <em>burst</em> 已经没有等待传输数据。</li>
<li><em>situation2</em>:  <code>2&#39;b01</code>，确保 <em>wlast</em>信号和 <em>pending</em> 之间的关系。</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2&#x27;b11</span>: <span class="keyword">begin</span></span><br><span class="line">	<span class="comment">// If both AWVALID and WVALID, then we have two cases to</span></span><br><span class="line">	<span class="comment">// consider.  The first case is that the WVALID applies to the</span></span><br><span class="line">	<span class="comment">// last item of the previous burst.  Otherwise, it could be</span></span><br><span class="line">	<span class="comment">// the data associated with this new burst described by AW*</span></span><br><span class="line">	<span class="keyword">if</span> (f_axi_wr_pending &gt; <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">begin</span> <span class="comment">// Write word applies to the last burst</span></span><br><span class="line">		`SLAVE_ASSUME(f_axi_wr_pending == <span class="number">1</span>);</span><br><span class="line">		`SLAVE_ASSUME(i_axi_wlast);</span><br><span class="line">		`SLAVE_ASSERT(!i_axi_awready || i_axi_wready);</span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">		<span class="comment">// Must be associated with the new burst</span></span><br><span class="line">		<span class="comment">// In this case, check WLAST against the *incoming*</span></span><br><span class="line">		<span class="comment">// address request</span></span><br><span class="line">		`SLAVE_ASSUME(i_axi_wlast == (i_axi_awlen == <span class="number">0</span>));</span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">default</span>: <span class="keyword">begin</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>

<p>这个解释一下就让我 <code>7.1</code>小结的疑惑解开。在 <code>7。3.1</code>中明确说了在此设计中，一次只能有一个 <em>burst</em> 在发生，不能对<em>aw address</em> 进行<em>outstanding</em> 操作。那么这个时候就有两种情况了：</p>
<ul>
<li><p><em>first situation</em> ： <em>the WVALID applies to the  last item of the previous burst</em></p>
<p>在<em>first situation</em>中，同时发起 <em>i_axi_awvalid</em> &amp; <em>i_axi_wvalid</em>，如果要接受新的 <em>address</em> ，必须 <code>assume</code>  <em>slave</em>端的 <em>wready</em> 信号保持接受。</p>
</li>
<li><p><em>second situation</em> ：<em>the data associated with this new burst described by AW</em></p>
<p>在<em>second situation</em>中，如果发起的 <em>aw_len</em> 是一个 <code>signle beat burst</code>，需要确保同时 <code>assert</code> 信号 <code>wlast</code>。</p>
</li>
</ul>
<h2 id="7-4-Awr-num-bursts"><a href="#7-4-Awr-num-bursts" class="headerlink" title="7.4 Awr_num_bursts"></a>7.4 Awr_num_bursts</h2><p><em>first things you should know</em> :</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span>	axi_ard_req = (i_axi_arvalid)&amp;&amp;(i_axi_arready);</span><br><span class="line"><span class="keyword">assign</span>	axi_awr_req = (i_axi_awvalid)&amp;&amp;(i_axi_awready);</span><br><span class="line"><span class="keyword">assign</span>	axi_wr_req  = (i_axi_wvalid )&amp;&amp;(i_axi_wready);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">assign</span>	axi_rd_ack = (i_axi_rvalid)&amp;&amp;(i_axi_rready);</span><br><span class="line"><span class="keyword">assign</span>	axi_wr_ack = (i_axi_bvalid)&amp;&amp;(i_axi_bready);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Purpose</strong>: Count the number of <strong>outstanding</strong> <code>BVALID&#39;s</code> to expect</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	f_axi_awr_nbursts = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (!i_axi_reset_n)</span><br><span class="line">	f_axi_awr_nbursts &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">case</span>(&#123; (axi_awr_req), (axi_wr_ack) &#125;</span><br><span class="line"><span class="number">2&#x27;b10</span>: f_axi_awr_nbursts &lt;= f_axi_awr_nbursts + <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="number">2&#x27;b01</span>: f_axi_awr_nbursts &lt;= f_axi_awr_nbursts - <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">default</span>: <span class="keyword">begin</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>

<p><strong>Q</strong>: 	在这里我突然有一个疑问。在 7.3 小结中不是说 ——while <strong>waiting</strong> for the write data, <strong>NO OTHER WRITE ADDRESS may be permitted</strong>.  为什么这里还需要使用 outstanding ，这不是摆明了 outstanding只能是1吗。</p>
<p><strong>A</strong>：	 理解错误。上面的意思是，当我们在处理一个固定 <em>aw_addrss</em> 加 <em>aw_len</em>的 <em>burst</em>传输时，该传输没有结束之前不接受其他的<em>burst</em> 发生。但是可以使用<em>fifo</em>等模块暂时存储这些请求，等待上一次<em>burst</em> 结束后把<em>fifo</em> 中的<em>new address</em> 读出。</p>
<p><strong>A</strong>：	即使在等待写入数据时不允许有其他写入地址，也并不意味着不能有多个未完成的写请求。例如，主设备可以向不同的从设备发起写请求，或者在等待一个长突发写请求的数据阶段完成时发起另一个写请求，<strong>该请求不需要立刻被响应</strong>。在这些情况下，<code>f_axi_awr_nbursts</code>计数器仍然是必要的，以确保所有的写请求都得到了响应。 </p>
<h2 id="ID-7-5-wrID-num-bursts"><a href="#ID-7-5-wrID-num-bursts" class="headerlink" title="ID- 7.5 wrID_num_bursts"></a>ID- 7.5 wrID_num_bursts</h2><p>这段代码与 7.4 章节的处理方式形式上很相近。在目的上 7.4 是为了让<em>num_ req</em> 和 <em>num_ack</em> 保持相等。而在本小结，是为了让对相应 <em>id</em> 发起 <em>num_req</em> 都能收回相应数量的 <em>num_ack</em>。  </p>
<blockquote>
<p>Count the number of outstanding BVALID’s to expect associated with our choice of check ID.  That is, we check one channel alone for proper ordering, and this is the count of the channel we have chosen</p>
</blockquote>
<p>这里的处理设计到了 <code>id</code>，我还是一知半解，所以暂时跳过。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	f_axi_wrid_nbursts = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (!i_axi_reset_n)</span><br><span class="line">	f_axi_wrid_nbursts &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">case</span>(&#123; (axi_awr_req)&amp;&amp;(i_axi_awid==f_axi_wr_checkid),</span><br><span class="line">		(axi_wr_ack)&amp;&amp;(i_axi_bid == f_axi_wr_checkid) &#125;)</span><br><span class="line"><span class="number">2&#x27;b10</span>: f_axi_wrid_nbursts &lt;= f_axi_wrid_nbursts + <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="number">2&#x27;b01</span>: f_axi_wrid_nbursts &lt;= f_axi_wrid_nbursts - <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">default</span>: <span class="keyword">begin</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>



<h2 id="7-6-rd-num-bursts"><a href="#7-6-rd-num-bursts" class="headerlink" title="7.6 rd_num_bursts"></a>7.6 rd_num_bursts</h2><blockquote>
<p>Purpose:  Count the number of reads bursts <strong>outstanding</strong>.  This defines the  <strong>number</strong> of <code>RDVALID &amp;&amp; RLAST</code>‘s we expect to see before becoming idle.</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	f_axi_rd_nbursts = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (!i_axi_reset_n)</span><br><span class="line">	f_axi_rd_nbursts &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">case</span>(&#123; (axi_ard_req), (axi_rd_ack)&amp;&amp;(i_axi_rlast) &#125;)</span><br><span class="line">   <span class="comment">// only rd_req , the burst should add one</span></span><br><span class="line"><span class="number">2&#x27;b01</span>: f_axi_rd_nbursts &lt;= f_axi_rd_nbursts - <span class="number">1&#x27;b1</span>;</span><br><span class="line">   <span class="comment">// once read the LAST data from slave , the num_burst minus one</span></span><br><span class="line"><span class="number">2&#x27;b10</span>: f_axi_rd_nbursts &lt;= f_axi_rd_nbursts + <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">default</span>: <span class="keyword">begin</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>



<h2 id="ID-7-7-rd-outstanding"><a href="#ID-7-7-rd-outstanding" class="headerlink" title="ID-7.7 rd_outstanding"></a>ID-7.7 rd_outstanding</h2><blockquote>
<p>Description:	</p>
<p>​	f_axi_rd_outstanding counts the number of <code>RDVALID&#39;s</code> we expect to see before becoming idle.  This must always be <strong>greater than or  equal to</strong> the number of <code>RVALID &amp; RLAST</code>‘s counted above</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	f_axi_rd_outstanding = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (!i_axi_reset_n)</span><br><span class="line">	f_axi_rd_outstanding &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">case</span>(&#123; (axi_ard_req), (axi_rd_ack) &#125;)</span><br><span class="line"><span class="comment">// Verilator lint_off WIDTH</span></span><br><span class="line"><span class="number">2&#x27;b01</span>: f_axi_rd_outstanding &lt;= f_axi_rd_outstanding - <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="number">2&#x27;b10</span>: f_axi_rd_outstanding &lt;= f_axi_rd_outstanding + i_axi_arlen+<span class="number">1</span>;</span><br><span class="line"><span class="number">2&#x27;b11</span>: f_axi_rd_outstanding &lt;= f_axi_rd_outstanding + i_axi_arlen;</span><br><span class="line"><span class="comment">// Verilator lint_on  WIDTH</span></span><br><span class="line"><span class="keyword">default</span>: <span class="keyword">begin</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>

<p>相比于 <em>write</em> 的 <code>2’b11</code>情况，少了两种情景的讨论。我本来想说【原因很简单：<em>W Operation</em> 可以在送入<em>address</em> 的同时将<em>w_data</em>传入。<em>R Operation</em>不能瞬间读出相应的数据】，不过在浏览了一遍代码之后我发现这的实现方式为什么不一样。<em>wr</em> 的处理方式是直接更新，而这里是在原来基础上的<em>outstanding</em> 数量上进行增加。</p>
<h2 id="7-8-overflow-checking"><a href="#7-8-overflow-checking" class="headerlink" title="7.8 overflow checking"></a>7.8 overflow checking</h2><p>为什么这部分代码，有的是 burst ，有的是 pending ，有的是 outstanding ？？？&#x2F;</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Do not let the number of outstanding requests overflow.  This is</span></span><br><span class="line"><span class="comment">// a responsibility of the master to never allow 2^F_LGDEPTH-1</span></span><br><span class="line"><span class="comment">// requests to be outstanding.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line">	`SLAVE_ASSERT(f_axi_rd_outstanding  &lt; &#123;(F_LGDEPTH)&#123;<span class="number">1&#x27;b1</span>&#125;&#125;);</span><br><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line">	`SLAVE_ASSERT(f_axi_awr_nbursts &lt; &#123;(F_LGDEPTH)&#123;<span class="number">1&#x27;b1</span>&#125;&#125;);</span><br><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line">	`SLAVE_ASSERT(f_axi_wr_pending &lt;= <span class="number">256</span>);</span><br><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line">	`SLAVE_ASSERT(f_axi_rd_nbursts  &lt; &#123;(F_LGDEPTH)&#123;<span class="number">1&#x27;b1</span>&#125;&#125;);</span><br></pre></td></tr></table></figure>



<h1 id="8-Maximum-delay"><a href="#8-Maximum-delay" class="headerlink" title="8. Maximum delay"></a>8. Maximum delay</h1><p>在 <em>slave</em> 与 <em>master</em> 完成 <em>req</em> 握手后，<em>salve</em> 必须在固定的时钟周期内给出相应的<em>resp</em> 信号。</p>
<blockquote>
<p> Insist that all responses are returned in less than a maximum delay. In this case, we count responses within a burst, rather than entire bursts. 对于一个burst来说，握手完成后，<em>slave</em> 需要在一定的周期内将<em>resp</em> 信号发回<em>master</em>。</p>
</blockquote>
<p>在里会使用两个寄存器 <code>f_axi_awr_ack_delay</code>、 <code>f_axi_rd_ack_delay</code>，分别记录读写两个操作的<em>delay</em> 周期。</p>
<ul>
<li>首先对 <em>awr_ack_delay</em> 解释：</li>
</ul>
<blockquote>
<p> A unique feature to the <strong>backpressure mechanism</strong> within AXI is that we <strong>have to reset</strong> our delay counters in the case of <strong>any push back</strong>, since the response can’t move forward if the master isn’t (yet)  ready for it.</p>
</blockquote>
<p>在<em>master</em> 对 <em>salve</em>的</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	f_axi_awr_ack_delay = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> ((!i_axi_reset_n)||</span><br><span class="line">          (i_axi_bvalid)	||</span><br><span class="line">          (i_axi_wvalid)	||</span><br><span class="line">          ((f_axi_awr_nbursts == <span class="number">1</span>) &amp;&amp;(f_axi_wr_pending&gt;<span class="number">0</span>))||</span><br><span class="line">          (f_axi_awr_nbursts == <span class="number">0</span>))</span><br><span class="line">        </span><br><span class="line">	f_axi_awr_ack_delay &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	f_axi_awr_ack_delay &lt;= f_axi_awr_ack_delay + <span class="number">1&#x27;b1</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>然后是对 <em>rd_ack_delay</em> 解释：</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	f_axi_rd_ack_delay = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> ((!i_axi_reset_n)||</span><br><span class="line">          (i_axi_rvalid)  ||</span><br><span class="line">          (f_axi_rd_outstanding==<span class="number">0</span>))</span><br><span class="line">        </span><br><span class="line">	f_axi_rd_ack_delay &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	f_axi_rd_ack_delay &lt;= f_axi_rd_ack_delay + <span class="number">1&#x27;b1</span>;</span><br></pre></td></tr></table></figure>

<p>最后需要对计数器进行<em>assume</em> ，因为这些信号都是由<em>slave</em> 进行返回的。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line">	`SLAVE_ASSERT(f_axi_awr_ack_delay &lt; F_AXI_MAXDELAY);</span><br><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line">	`SLAVE_ASSERT(f_axi_rd_ack_delay &lt; F_AXI_MAXDELAY);</span><br></pre></td></tr></table></figure>



</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">冰蒂斯</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/11/25/axi-master-full/">http://example.com/2023/11/25/axi-master-full/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">冰蒂斯のformula</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/AXI/">AXI</a><a class="post-meta__tags" href="/tags/master/">master</a><a class="post-meta__tags" href="/tags/formalproperty/">formalproperty</a></div><div class="post_share"><div class="social-share" data-image="/img/chainsaw_makima04.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/26/formal-addr/" title="formal_addr"><img class="cover" src="/img/chainsaw_red.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">formal_addr</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/23/5-1-2-basic-master/" title="5-1 basic_master(下)"><img class="cover" src="/img/chainsaw_makima04.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">5-1 basic_master(下)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/11/23/5-1-2-basic-master/" title="5-1 basic_master(下)"><img class="cover" src="/img/chainsaw_makima04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-23</div><div class="title">5-1 basic_master(下)</div></div></a></div><div><a href="/2023/11/13/5-1-basic-master/" title="5-1 basic_master(上)"><img class="cover" src="/img/chainsaw_makima04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-13</div><div class="title">5-1 basic_master(上)</div></div></a></div><div><a href="/2023/12/06/MM2S/" title="MM2S"><img class="cover" src="/img/chainsaw_red.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-06</div><div class="title">MM2S</div></div></a></div><div><a href="/2023/11/18/Property-master/" title="Property_axil-master"><img class="cover" src="/img/chainsaw_makima04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-18</div><div class="title">Property_axil-master</div></div></a></div><div><a href="/2023/12/03/axi-master-fulllast/" title="axi_(full)master(下)"><img class="cover" src="/img/chainsaw_makima04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-03</div><div class="title">axi_(full)master(下)</div></div></a></div><div><a href="/2023/11/15/5-1-1-basic-master/" title="5-1 basic_master(中)"><img class="cover" src="/img/chainsaw_makima04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-15</div><div class="title">5-1 basic_master(中)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">冰蒂斯</div><div class="author-info__description">螺旋上升的人生,也是多线程的人生</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">1. 前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-param-signals"><span class="toc-number">2.</span> <span class="toc-text">2. param &amp; signals</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-parameter"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 parameter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-signals"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 signals</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-something-first"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 something first</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-Assert-Assume"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 Assert &amp; Assume</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-set-up"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 set up</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-reset-property"><span class="toc-number">3.</span> <span class="toc-text">3. reset property</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-reset-remain-16-clocks"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 reset remain 16 clocks</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-reset-within-core"><span class="toc-number">3.1.1.</span> <span class="toc-text">1. reset within core</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-reset-not-within-core"><span class="toc-number">3.1.2.</span> <span class="toc-text">2. reset not within core</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-valid-reset"><span class="toc-number">3.2.</span> <span class="toc-text">3.2  *_valid reset</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-stable-property"><span class="toc-number">4.</span> <span class="toc-text">4. stable property</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Reset-release"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 Reset release</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-five-channel"><span class="toc-number">4.2.</span> <span class="toc-text">4.2  five channel</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Maximum-Wait"><span class="toc-number">5.</span> <span class="toc-text">5. Maximum Wait</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-write-address-channel"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 write address channel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-write-data-channel"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 write data channel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-read-address-channel"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 read address channel</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-Maximum-stall"><span class="toc-number">6.</span> <span class="toc-text">6. Maximum stall</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-W-valid"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 W valid</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-B-channel"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 B channel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-R-channel"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 R channel</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-count-outstanding-transaction"><span class="toc-number">7.</span> <span class="toc-text">7. count outstanding transaction</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-aw-pending"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 aw_pending</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ID-7-2-useful-wr-ckvalid"><span class="toc-number">7.2.</span> <span class="toc-text">ID- 7.2  useful  *_wr_ckvalid</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-Assert-on-pending-wlast"><span class="toc-number">7.3.</span> <span class="toc-text">7.3 Assert on pending &amp; wlast</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-sth-you-should-know-first"><span class="toc-number">7.3.1.</span> <span class="toc-text">1. sth you should know first</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-The-property"><span class="toc-number">7.3.2.</span> <span class="toc-text">2. The  property</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-Awr-num-bursts"><span class="toc-number">7.4.</span> <span class="toc-text">7.4 Awr_num_bursts</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ID-7-5-wrID-num-bursts"><span class="toc-number">7.5.</span> <span class="toc-text">ID- 7.5 wrID_num_bursts</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-rd-num-bursts"><span class="toc-number">7.6.</span> <span class="toc-text">7.6 rd_num_bursts</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ID-7-7-rd-outstanding"><span class="toc-number">7.7.</span> <span class="toc-text">ID-7.7 rd_outstanding</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-8-overflow-checking"><span class="toc-number">7.8.</span> <span class="toc-text">7.8 overflow checking</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-Maximum-delay"><span class="toc-number">8.</span> <span class="toc-text">8. Maximum delay</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/01/07/skid-buffer/" title="skid_buffer"><img src="/img/chainsaw_power01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="skid_buffer"/></a><div class="content"><a class="title" href="/2024/01/07/skid-buffer/" title="skid_buffer">skid_buffer</a><time datetime="2024-01-07T12:48:03.000Z" title="发表于 2024-01-07 20:48:03">2024-01-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/06/how2blog/" title="how2blog"><img src="/img/reze.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="how2blog"/></a><div class="content"><a class="title" href="/2024/01/06/how2blog/" title="how2blog">how2blog</a><time datetime="2024-01-06T14:34:23.000Z" title="发表于 2024-01-06 22:34:23">2024-01-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/27/S2MM/" title="S2MM"><img src="/img/chainsaw_red.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="S2MM"/></a><div class="content"><a class="title" href="/2023/12/27/S2MM/" title="S2MM">S2MM</a><time datetime="2023-12-27T05:57:36.000Z" title="发表于 2023-12-27 13:57:36">2023-12-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/24/auto2-using/" title="auto2-using"><img src="/img/chainsaw_makima04.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="auto2-using"/></a><div class="content"><a class="title" href="/2023/12/24/auto2-using/" title="auto2-using">auto2-using</a><time datetime="2023-12-24T14:17:24.000Z" title="发表于 2023-12-24 22:17:24">2023-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/12/auto1-introduction/" title="auto1_introduction"><img src="/img/flower.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="auto1_introduction"/></a><div class="content"><a class="title" href="/2023/12/12/auto1-introduction/" title="auto1_introduction">auto1_introduction</a><time datetime="2023-12-12T06:18:40.000Z" title="发表于 2023-12-12 14:18:40">2023-12-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 冰蒂斯</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>