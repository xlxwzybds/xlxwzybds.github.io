<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Property_axil-master | 冰蒂斯のformula</title><meta name="author" content="冰蒂斯"><meta name="copyright" content="冰蒂斯"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. introduction前言： ​	本文档的内容来源于 zipcpu的博客代码进行解读和注解，代码的链接是https:&#x2F;&#x2F;github.com&#x2F;ZipCPU&#x2F;wb2axip&#x2F;blob&#x2F;master&#x2F;bench&#x2F;formal&#x2F;faxil_master.v。本笔记是仅仅对该篇博客的解读和学习总结，所有的权益归原作者所有。 ​	该篇文章是为更好的解读 axi master相关模块。如果阅读了 sp">
<meta property="og:type" content="article">
<meta property="og:title" content="Property_axil-master">
<meta property="og:url" content="http://more_study@163.com/2023/11/18/Property-master/index.html">
<meta property="og:site_name" content="冰蒂斯のformula">
<meta property="og:description" content="1. introduction前言： ​	本文档的内容来源于 zipcpu的博客代码进行解读和注解，代码的链接是https:&#x2F;&#x2F;github.com&#x2F;ZipCPU&#x2F;wb2axip&#x2F;blob&#x2F;master&#x2F;bench&#x2F;formal&#x2F;faxil_master.v。本笔记是仅仅对该篇博客的解读和学习总结，所有的权益归原作者所有。 ​	该篇文章是为更好的解读 axi master相关模块。如果阅读了 sp">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://more_study@163.com/img/chainsaw_makima04.jpg">
<meta property="article:published_time" content="2023-11-18T14:44:21.000Z">
<meta property="article:modified_time" content="2023-11-28T09:09:38.128Z">
<meta property="article:author" content="冰蒂斯">
<meta property="article:tag" content="AXI">
<meta property="article:tag" content="master">
<meta property="article:tag" content="formal">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://more_study@163.com/img/chainsaw_makima04.jpg"><link rel="shortcut icon" href="/img/bloodborn_lib.png"><link rel="canonical" href="http://more_study@163.com/2023/11/18/Property-master/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Property_axil-master',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-28 17:09:38'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/reze.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="冰蒂斯のformula"><span class="site-name">冰蒂斯のformula</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Property_axil-master</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-18T14:44:21.000Z" title="发表于 2023-11-18 22:44:21">2023-11-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-28T09:09:38.128Z" title="更新于 2023-11-28 17:09:38">2023-11-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/AXI/">AXI</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/AXI/formal/">formal</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Property_axil-master"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-introduction"><a href="#1-introduction" class="headerlink" title="1. introduction"></a>1. introduction</h1><p>前言：</p>
<p>​	本文档的内容来源于 <code>zipcpu</code>的博客代码进行解读和注解，代码的链接是<a target="_blank" rel="noopener" href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_master.v%E3%80%82%E6%9C%AC%E7%AC%94%E8%AE%B0%E6%98%AF%E4%BB%85%E4%BB%85%E5%AF%B9%E8%AF%A5%E7%AF%87%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%A7%A3%E8%AF%BB%E5%92%8C%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%8C%E6%89%80%E6%9C%89%E7%9A%84%E6%9D%83%E7%9B%8A%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82">https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_master.v。本笔记是仅仅对该篇博客的解读和学习总结，所有的权益归原作者所有。</a></p>
<p>​	该篇文章是为更好的解读 <code>axi master</code>相关模块。如果阅读了 <code>spec.pdf</code>文档，但是依然对于信号之间的依赖问题还是比较模糊，那么请阅读这篇博客。该博客将会对 <code>axil master</code>的信号以来进行比较详细的阐述。</p>
<p>​	本片博文我打算分为如下三个部分进行解读：</p>
<ul>
<li><code>declarations</code>： <code>axi-lite master</code>信号的声明和使用方法；</li>
<li><code>property</code>：各个信号之间的依赖关系，该部分也可能是本文最长、最复杂的部分；</li>
<li><code>cover &amp; wave</code>：cover的波形图仿真与解释；</li>
</ul>
<h1 id="2-Declarations"><a href="#2-Declarations" class="headerlink" title="2. Declarations"></a>2. Declarations</h1><p>该部分将会分为三个小结：</p>
<ul>
<li><p><strong>parameter declarations</strong>：</p>
<p>对模块的参数进行说明。有部分参数目前我并不希望使用，比如异步复位的参数 <code>F_OPT_ASYNC_RESET</code>等。在解读的过程中我将自动跳过这部分的参数，如有需要请自行了解。这部分参数的解读或者使用也许会在后面的博文中进行。</p>
<p>除开 <code>parameter</code>，外有部分的 <code>localparam</code>的声明。一定要认识要这些本地参数的使用方法和原因。</p>
</li>
<li><p><strong>signals declarations</strong></p>
<p>这部分是对 <code>axi-lite master</code>的信号进行回顾。比较重要的是三个 <code>*_outstanding</code>相关的信号。</p>
</li>
<li><p><strong>register and wire declaration</strong></p>
<p>该部分主要是对 <code>ack</code>、 <code>req</code>相关信号的逻辑表示。</p>
</li>
</ul>
<h2 id="2-1-parameter"><a href="#2-1-parameter" class="headerlink" title="2.1  parameter"></a>2.1  parameter</h2><ul>
<li><code>axi lite</code> 数据位宽和地址位宽</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">parameter</span>  C_AXI_DATA_WIDTH     = <span class="number">32</span>,<span class="comment">// Fixed, width of the AXI R&amp;W data</span></span><br><span class="line"><span class="keyword">parameter</span>  C_AXI_ADDR_WIDTH     = <span class="number">28</span>,<span class="comment">// AXI Address width (log wordsize)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Xilinx</code> 在自身的设计中对 <code>aw</code> 、<code>w</code> <code>channel</code>的数据互相间隔的时间有约束</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// F_OPT_XILINX, Certain Xilinx cores impose additional rules upon AXI</span></span><br><span class="line"><span class="comment">// write transactions, limiting how far the write and write address</span></span><br><span class="line"><span class="comment">// can be apart.  If F_OPT_XILINX is set, these rules will be applied</span></span><br><span class="line"><span class="comment">// here as well.  See in-line for more details.</span></span><br><span class="line"><span class="keyword">parameter</span> [<span class="number">0</span>:<span class="number">0</span>]	F_OPT_XILINX = <span class="number">1&#x27;b0</span>,</span><br></pre></td></tr></table></figure>

<ul>
<li><code>only write</code> 和 <code>only read</code> 的相关限制，设置为 <code>1‘b1</code>的时候表示 <code>only one channel</code></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// F_OPT_WRITE_ONLY, if set, will assume the master is always idle on</span></span><br><span class="line"><span class="comment">// te read channel, allowing you to test/focus on the write interface</span></span><br><span class="line"><span class="keyword">parameter</span> [<span class="number">0</span>:<span class="number">0</span>]	F_OPT_WRITE_ONLY  = <span class="number">1&#x27;b0</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// F_OPT_READ_ONLY, if set, will assume the master is always idle on</span></span><br><span class="line"><span class="comment">// the write channel, while asserting that all of the associated returns</span></span><br><span class="line"><span class="comment">// and counters are zero</span></span><br><span class="line"><span class="keyword">parameter</span> [<span class="number">0</span>:<span class="number">0</span>]	F_OPT_READ_ONLY = <span class="number">1&#x27;b0</span>,</span><br></pre></td></tr></table></figure>

<ul>
<li>有的设计可能没有 <code>B response</code> 以及 <code>ERR response</code>。设置为 <code>1‘b0</code>的时候 <code>disallow the response</code></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// F_OPT_BRESP: Allow any type of write response.  If set clear, then</span></span><br><span class="line"><span class="comment">// error responses are disallowed.</span></span><br><span class="line"><span class="keyword">parameter</span> [<span class="number">0</span>:<span class="number">0</span>]	F_OPT_BRESP = <span class="number">1&#x27;b1</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// F_OPT_RRESP, if cleared, will disallow error responses</span></span><br><span class="line"><span class="keyword">parameter</span> [<span class="number">0</span>:<span class="number">0</span>]	F_OPT_RRESP = <span class="number">1&#x27;b1</span>,</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>下面这个信号比较重要</strong>。在验证中，使用 <code>ASSUME</code>强制是的外部的信号和自己设计的标准保持一致， <code>ASSERT</code>则是用来检测外部输入的信号是否保持正确。前者用来可以用来模拟正确的标准信号，后者用来检验信号的正确性。</p>
<p>该信号可以在 <code>sby</code>文件中对其设置为1，强制外部的信号保持正确。为什么需要<code>assume</code>呢？因为单独仿真 <code>axil_master</code>的逻辑时候，并没有外部输入信号。如果该参数设置为 <code>1‘b1</code>表示强制 <code>assume</code>模块的 <code>reset signal</code>，并且没有外部输入的 <code>reset signal</code>。</p>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// F_OPT_ASSUME_RESET, if set, will cause the design to *assume* the</span></span><br><span class="line"><span class="comment">// existence of a correct reset, rather than asserting it.  It is</span></span><br><span class="line"><span class="comment">// appropriate anytime the reset logic is outside of the circuit being</span></span><br><span class="line"><span class="comment">// examined</span></span><br><span class="line"><span class="keyword">parameter</span> [<span class="number">0</span>:<span class="number">0</span>]			F_OPT_ASSUME_RESET = <span class="number">1&#x27;b0</span>,</span><br><span class="line"><span class="keyword">parameter</span> [<span class="number">0</span>:<span class="number">0</span>]			F_OPT_NO_RESET = F_OPT_ASSUME_RESET,</span><br></pre></td></tr></table></figure>

<ul>
<li>剩下的参数和 <code>xilinx rules</code>有关，如果在之前设置了参数 <code>F_OPT_XILINX = 1&#39;b1</code>，那么这些参数将会发生作用。</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// F_LGDEPTH is the number of bits necessary to count the maximum</span></span><br><span class="line"><span class="comment">// number of items in flight.</span></span><br><span class="line"><span class="keyword">parameter</span>			F_LGDEPTH	= <span class="number">4</span>,</span><br><span class="line"><span class="comment">// F_AXI_MAXWAIT is the maximum number of clock cycles the</span></span><br><span class="line"><span class="comment">// master should have to wait for a slave to raise its ready flag to</span></span><br><span class="line"><span class="comment">// accept a request.  Set to zero for no limit.</span></span><br><span class="line"><span class="keyword">parameter</span>			F_AXI_MAXWAIT  = <span class="number">12</span>,</span><br><span class="line"><span class="comment">// F_AXI_MAXRSTALL is the maximum number of clock cycles the</span></span><br><span class="line"><span class="comment">// slave should have to wait with a return valid signal high, but</span></span><br><span class="line"><span class="comment">// while the master&#x27;s return ready signal is low.  Set to zero for no</span></span><br><span class="line"><span class="comment">// limit.</span></span><br><span class="line"><span class="keyword">parameter</span>			F_AXI_MAXRSTALL= <span class="number">12</span>,</span><br><span class="line"><span class="comment">// F_AXI_MAXDELAY is the maximum number of clock cycles between request</span></span><br><span class="line"><span class="comment">// and response within the slave.  Set this to zero for no limit.</span></span><br><span class="line"><span class="keyword">parameter</span>			F_AXI_MAXDELAY = <span class="number">12</span>,</span><br></pre></td></tr></table></figure>

<ul>
<li><p>最后一个参数是 <code>F_OPT_INITIAL = 1&#39;b1</code>。这个和时候设置初始数值有关，后面会接和实际的代码。</p>
</li>
<li><p>其他：异步复位的信号暂时对于我来说过于复杂，暂时不做研究和讨论。</p>
</li>
</ul>
<h2 id="2-2-signals"><a href="#2-2-signals" class="headerlink" title="2.2 signals"></a>2.2 signals</h2><p>相关的信号无疑就是 <code>axil</code>： <code>AW W B AR R</code>五个通道的信号。</p>
<p>这里使用了两个 <code>localparam</code>对信号的 <code>width</code>进行表示。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">localparam</span> DW			= C_AXI_DATA_WIDTH,</span><br><span class="line"><span class="keyword">localparam</span> AW			= C_AXI_ADDR_WIDTH</span><br></pre></td></tr></table></figure>

<ul>
<li>总时钟信号和复位信号</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>			i_clk,	<span class="comment">// System clock</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>			i_axi_reset_n,</span><br></pre></td></tr></table></figure>

<ul>
<li><code>AXI write address channel signals</code></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AXI write address channel signals</span></span><br><span class="line"><span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>				i_axi_awvalid,</span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>				i_axi_awready,</span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[AW-<span class="number">1</span>:<span class="number">0</span>]	i_axi_awaddr,	<span class="comment">// Write address</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[<span class="number">2</span>:<span class="number">0</span>]		i_axi_awprot,	<span class="comment">// Protection</span></span><br><span class="line"><span class="comment">// &#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>AXI write data channel signals</code></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AXI write data channel signals</span></span><br><span class="line"><span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>				i_axi_wvalid,</span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>				i_axi_wready,</span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[DW-<span class="number">1</span>:<span class="number">0</span>]	i_axi_wdata,	<span class="comment">// Write data</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[DW/<span class="number">8</span>-<span class="number">1</span>:<span class="number">0</span>]	i_axi_wstrb,	<span class="comment">// Write strobes</span></span><br><span class="line"><span class="comment">// &#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>AXI write response channel signals</code></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AXI write response channel signals</span></span><br><span class="line"><span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>				i_axi_bvalid,</span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>				i_axi_bready,</span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[<span class="number">1</span>:<span class="number">0</span>]		i_axi_bresp,	<span class="comment">// Wr response</span></span><br><span class="line"><span class="comment">// &#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>AXI read address channel signals</code></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AXI read address channel signals </span></span><br><span class="line"><span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>				i_axi_arvalid,</span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>				i_axi_arready,</span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[AW-<span class="number">1</span>:<span class="number">0</span>]	i_axi_araddr,	<span class="comment">// Read address</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[<span class="number">2</span>:<span class="number">0</span>]		i_axi_arprot,	<span class="comment">// Protection</span></span><br><span class="line"><span class="comment">// &#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>AXI read data channel signals</code></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AXI read data channel signals</span></span><br><span class="line"><span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>				i_axi_rvalid,</span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>				i_axi_rready,</span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[DW-<span class="number">1</span>:<span class="number">0</span>]	i_axi_rdata,	<span class="comment">// Read data</span></span><br><span class="line"><span class="keyword">input</span>	<span class="keyword">wire</span>	[<span class="number">1</span>:<span class="number">0</span>]		i_axi_rresp,	<span class="comment">// Read response</span></span><br><span class="line"><span class="comment">// &#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure>



<p>还有一些额外的 <code>outstanding</code>信号用于硬件设计中的超时控制或延迟控制。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">localparam</span>	MAX_SLAVE_TIMEOUT = (F_AXI_MAXWAIT &gt; F_AXI_MAXDELAY)</span><br><span class="line">			? (F_AXI_MAXWAIT) : F_AXI_MAXDELAY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">localparam</span>	MAX_TIMEOUT = (F_AXI_MAXRSTALL&gt;MAX_SLAVE_TIMEOUT)</span><br><span class="line">			? (F_AXI_MAXRSTALL) : MAX_SLAVE_TIMEOUT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">localparam</span>	LGTIMEOUT = <span class="built_in">$clog2</span>(MAX_TIMEOUT+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>表示的含义是：</p>
<ul>
<li><code>max_slave_timeout</code>：<ul>
<li>用于确定 <code>f_axi_maxwait</code> 和 <code>f_axi_maxdelay</code> 之间的最大值。</li>
<li>如果 <code>f_axi_maxwait</code> 大于 <code>f_axi_maxdelay</code>，则 <code>max_slave_timeout</code> 的值为 <code>f_axi_maxwait</code>，否则为 <code>f_axi_maxdelay</code>。</li>
</ul>
</li>
<li><code>max_timeout</code>：<ul>
<li>用于确定 <code>f_axi_maxrstall</code> 和 <code>max_slave_timeout</code> 之间的最大值。</li>
<li>如果 <code>f_axi_maxrstall</code> 大于 <code>max_slave_timeout</code>，则 <code>max_timeout</code> 的值为 <code>f_axi_maxrstall</code>，否则为 <code>max_slave_timeout</code>。</li>
</ul>
</li>
<li><code>lgtimeout</code>：<ul>
<li>它的值为 <code>max_timeout+1</code> 的以2为底的对数。</li>
<li><code>$clog2</code> 是一个系统函数，用于计算以2为底的对数。</li>
</ul>
</li>
</ul>
<p>具体的表示会在后面更新。</p>
<h2 id="2-3-registr-wire"><a href="#2-3-registr-wire" class="headerlink" title="2.3 registr &amp;  wire"></a>2.3 registr &amp;  wire</h2><p>五个通道的<code>requitment</code> 信号，和 <code>acknowledgement</code> 信号。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span>	axi_rd_ack, axi_wr_ack, axi_ard_req, axi_awr_req, axi_wr_req;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>f_past_valid</code>：强制初始复位的信号；</li>
<li><code>f_reset_length</code>：低复位保持时钟周期的长度；</li>
</ul>
<p>非复位状态下， <code>valid</code>信号和 <code>ready</code>信号的握手表示握手信号的完成， <code>data</code>的成功传递。不过在不同通道表达的信息不相同。在 <code>AW W AR</code>三个通道中， <code>master</code>发起 <code>valid</code>信号，所以当握手完成时候，表示<strong>请求的发起成功</strong>。 <code>B R</code>两个通道的 <code>valid</code>信号由 <code>slave</code>发起， <code>ready </code>信号由<code>master</code>发起，所以握手完成的时候，表示<strong>任务完成的确认</strong>。</p>
<h1 id="3-Property"><a href="#3-Property" class="headerlink" title="3. Property"></a>3. Property</h1><h2 id="3-1-assume-assert"><a href="#3-1-assume-assert" class="headerlink" title="3.1 assume &amp; assert"></a>3.1 assume &amp; assert</h2><p>博文的参考代码中，将 <code>ASSUME</code>和 <code>ASSERT</code>的 <code>definition</code>弄反了，我目前并不清楚这么做的原因。</p>
<p><strong>十分需要注意的一点</strong>：如果不将该 <code>formal property</code>代码加入到其他 <code>design</code>中，在直接使用的时候，需要对部分<code>input signal</code>做 <code>ASSUME</code>处理，而不是 <code>ASSERT</code>检验。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">define</span>	SLAVE_ASSUME	assert</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span>	SLAVE_ASSERT	assume</span></span><br></pre></td></tr></table></figure>

<p>插入 <code>set up</code>部分， <code>f_past_valid</code>信号会在初始0周期中（<strong>记住：第一个周期是 initial 的 0 周期</strong> ）保持位低电平，此外的所有时间都保持高电平。该信号的作用是为后面的 <code>reset</code>信号服务，使用 <code>assume</code>确保 <code>initial</code>阶段必有 <code>reset==1&#39;b0</code>的低电位复位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">initial	f_past_valid = <span class="number">1&#x27;b</span>0;</span><br><span class="line">always @(posedge i_clk)</span><br><span class="line">	f_past_valid &lt;= <span class="number">1&#x27;b</span>1;</span><br></pre></td></tr></table></figure>



<h2 id="3-2-reset-property"><a href="#3-2-reset-property" class="headerlink" title="3.2 reset property"></a>3.2 reset property</h2><h3 id="1-set-up"><a href="#1-set-up" class="headerlink" title="1. set up"></a>1. set up</h3><p>这部分的 <code>purpose</code>是：强制初始时候开始低电平复位16个时钟周期。</p>
<blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Insist that the reset signal start out asserted (negative), and</span></span><br><span class="line"><span class="comment">// remain so for 16 clocks.</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>如果设置了 <code>F_OPT_ASSUME_RESET == 1 </code>，会使得 <code>i_axi_reset_n</code> 信号在初始阶段一定低电平复位。</li>
<li>否则查看外部是否在 <code>initial step</code>传入低电平 <code>reset signal</code>进行复位。</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">generate</span> <span class="keyword">if</span> (F_OPT_ASSUME_RESET)</span><br><span class="line"><span class="keyword">begin</span> : ASSUME_INITIAL_RESET</span><br><span class="line">	<span class="keyword">always</span> @(*)</span><br><span class="line">	<span class="keyword">if</span> (!f_past_valid)</span><br><span class="line">		<span class="keyword">assume</span>(!i_axi_reset_n);</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span> : ASSERT_INITIAL_RESET</span><br><span class="line">	<span class="keyword">always</span> @(*)</span><br><span class="line">	<span class="keyword">if</span> (!f_past_valid)</span><br><span class="line">		<span class="keyword">assert</span>(!i_axi_reset_n);</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">endgenerate</span></span><br></pre></td></tr></table></figure>



<h3 id="2-reset-16-clocks"><a href="#2-reset-16-clocks" class="headerlink" title="2. reset 16 clocks"></a>2. reset 16 clocks</h3><p>一旦出现初始的低复位信号，那么将会持续16个时钟周期的复位。</p>
<blockquote>
<p>If asserted, the reset must be asserted for a minimum of 16 clocks</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	f_reset_length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (F_OPT_NO_RESET || i_axi_reset_n)</span><br><span class="line">	f_reset_length &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!(&amp;f_reset_length))</span><br><span class="line">	f_reset_length &lt;= f_reset_length + <span class="number">1&#x27;b1</span>;</span><br></pre></td></tr></table></figure>

<p><code>f_reset_length</code>信号的长度是<code>4bit</code>带宽，所以当 <code>f_reset_length == 4‘b1111</code>的时候， <code>!(&amp;f_reset_length)</code>的逻辑才能等于0.</p>
<ul>
<li>当 <code>F_OPT_ASSUME_RESET == F_OPT_NO_RESET ==0</code>的时候。会出现16周期的强制复位；</li>
<li>当 <code>F_OPT_ASSUME_RESET == F_OPT_NO_RESET ==1</code>的时候。 <code>f_reset_length</code>保持为0；</li>
</ul>
<h3 id="3-The-flaw-I-guess"><a href="#3-The-flaw-I-guess" class="headerlink" title="3. The flaw I guess"></a>3. The flaw I guess</h3><p>我推测在这里的  <code>F_OPT_ASSUME_RESET</code>以及 <code>F_OPT_NO_RESET</code>两个参数在最开始的时候，设置为<strong>相等</strong>。其实在下面的代码可能出现问题。所以我还是认为这两个参数应该分开设置。</p>
<p>现在分为两个支线进行：</p>
<ul>
<li>有 <code>ASSUME_RESET</code>的假设强制复位： <code>F_OPT_ASSUME_RESET == 1&#39;b1</code>；</li>
<li>关于外部的输入复位信号：<ul>
<li>没有外部的复位信号： <code>F_OPT_NO_RESET == 1&#39;b1 </code>。当设置为<strong>高电平</strong>的时候，没有外部信号；</li>
<li>有外部的复位信号：<code>F_OPT_NO_RESET == 1&#39;b0 </code>。则  <code>!F_OPT_NO_RESET</code>为高电平，有外部输入；</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the reset is not generated within this particular core, then it</span></span><br><span class="line"><span class="comment">// can be assumed if F_OPT_ASSUME_RESET is set</span></span><br><span class="line"><span class="keyword">generate</span> <span class="keyword">if</span> (F_OPT_ASSUME_RESET &amp;&amp; !F_OPT_NO_RESET)</span><br><span class="line"><span class="keyword">begin</span> : ASSUME_RESET</span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">	<span class="comment">// the situations below will RESET design</span></span><br><span class="line">	<span class="comment">// f_past_valid == 1, means the clock cycle is not the initial cycle</span></span><br><span class="line">	<span class="comment">// !$past(i_axi_reset_n) ==1 , means the last cycle is in LOW RESET</span></span><br><span class="line">	<span class="comment">// !$past(&amp;f_reset_length))==1, means the last cycle is in 16 cycle RESET</span></span><br><span class="line">	<span class="keyword">if</span> ((f_past_valid)&amp;&amp;(!<span class="built_in">$past</span>(i_axi_reset_n))&amp;&amp;(!<span class="built_in">$past</span>(&amp;f_reset_length)))</span><br><span class="line">		<span class="comment">// impose the RESET signal keep LOW</span></span><br><span class="line">		<span class="keyword">assume</span>(!i_axi_reset_n);</span><br><span class="line"></span><br><span class="line">     	<span class="comment">// the combinatorical logic</span></span><br><span class="line">	<span class="keyword">always</span> @(*)</span><br><span class="line">	<span class="comment">// make sure the RESET signal will keep LOW in 16 clock cycle</span></span><br><span class="line">	<span class="keyword">if</span> ((f_reset_length &gt; <span class="number">0</span>)&amp;&amp;(f_reset_length &lt; <span class="number">4&#x27;hf</span>))</span><br><span class="line">		<span class="keyword">assume</span>(!i_axi_reset_n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (!F_OPT_NO_RESET)</span><br><span class="line"><span class="comment">// if there is reset singal from the upper module, </span></span><br><span class="line"><span class="comment">// we should ASSERT it instead of using ASSUME</span></span><br><span class="line"><span class="keyword">begin</span> : ASSERT_RESET</span><br><span class="line">	<span class="comment">// the operation is the same as that above</span></span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">	<span class="keyword">if</span> ((f_past_valid)&amp;&amp;(!<span class="built_in">$past</span>(i_axi_reset_n))&amp;&amp;(!<span class="built_in">$past</span>(&amp;f_reset_length)))</span><br><span class="line">		<span class="keyword">assert</span>(!i_axi_reset_n);</span><br><span class="line"></span><br><span class="line">     	<span class="comment">// the combinatorical logic</span></span><br><span class="line">	<span class="keyword">always</span> @(*)</span><br><span class="line">	<span class="keyword">if</span> ((f_reset_length &gt; <span class="number">0</span>)&amp;&amp;(f_reset_length &lt; <span class="number">4&#x27;hf</span>))</span><br><span class="line">		<span class="keyword">assert</span>(!i_axi_reset_n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">endgenerate</span></span><br></pre></td></tr></table></figure>



<h3 id="4-xVALID-initial-low"><a href="#4-xVALID-initial-low" class="headerlink" title="4. xVALID initial low"></a>4. xVALID initial low</h3><p>所有的 <code>xxxvalid</code>信号在初始化或者复位的时候，都需要保持低电平。</p>
<p>十分需要注意的一点是：<strong>这个设计是 faxil_master，所以在理论上检测master功能是否正确的时候，会使用一个perfect axil slave。因此设计中由slave端发起的 bvalid和 rvalid 都是使用的assert，没有使用assume。如果需要单独使用这个 faxil_master 设计，那么需要更改 assert 的复位相关语句。</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// All of the xVALID signals *MUST* be set low on the clock following</span></span><br><span class="line"><span class="comment">// a reset.  Not in the spec, but also checked here is that they must</span></span><br><span class="line"><span class="comment">// also be set low initially.</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> ((!f_past_valid &amp;&amp; F_OPT_INITIAL)</span><br><span class="line">                        ||(f_past_valid &amp;&amp; !<span class="built_in">$past</span>(i_axi_reset_n)))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">        `SLAVE_ASSUME(!i_axi_arvalid);</span><br><span class="line">        `SLAVE_ASSUME(!i_axi_awvalid);</span><br><span class="line">        `SLAVE_ASSUME(!i_axi_wvalid);</span><br><span class="line">        </span><br><span class="line">  		<span class="comment">// if you want to use the formal property faxil_master.v alone,</span></span><br><span class="line">  		<span class="comment">// make sure you have change the `SLAVE_ASSERT to `SLAVE_ASSUME</span></span><br><span class="line">  		<span class="comment">// because you do not have a perfect axi-slave-demo</span></span><br><span class="line">        `SLAVE_ASSERT(!i_axi_bvalid);</span><br><span class="line">        `SLAVE_ASSERT(!i_axi_rvalid);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h3 id="5-xRESP-checking"><a href="#5-xRESP-checking" class="headerlink" title="5.  xRESP checking"></a>5.  xRESP checking</h3><p>首先回顾一下前面的参数作用声明。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// F_OPT_BRESP: Allow any type of write response.  If set clear, then</span></span><br><span class="line"><span class="comment">// error responses are disallowed.</span></span><br><span class="line"><span class="keyword">parameter</span> [<span class="number">0</span>:<span class="number">0</span>]	F_OPT_BRESP = <span class="number">1&#x27;b1</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// F_OPT_RRESP, if cleared, will disallow error responses</span></span><br><span class="line"><span class="keyword">parameter</span> [<span class="number">0</span>:<span class="number">0</span>]	F_OPT_RRESP = <span class="number">1&#x27;b1</span>,</span><br></pre></td></tr></table></figure>

<ul>
<li>如果这个参数被设置为<code>1</code>，可以<strong>允许返回任意类型</strong>的返回信号。</li>
<li>如果参数设置为<code>0</code>，不允许返回<strong>错误类型 response</strong> 。</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// F_OPT_INITIAL == 1 ,means that there is initial operation should be done </span></span><br><span class="line"><span class="comment">// F_OPT_BRESP == 1, means that Allow any type of write response.</span></span><br><span class="line"><span class="comment">// F_OPT_RRESP == 1 , means that allow any type of read responese. </span></span><br><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line"><span class="keyword">if</span> ((i_axi_bvalid)&amp;&amp;(!F_OPT_BRESP)&amp;&amp;(F_OPT_INITIAL || i_axi_reset_n))</span><br><span class="line">        `SLAVE_ASSERT(i_axi_bresp == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line"><span class="keyword">if</span> ((i_axi_rvalid)&amp;&amp;(!F_OPT_RRESP)&amp;&amp;(F_OPT_INITIAL || i_axi_reset_n))</span><br><span class="line">        `SLAVE_ASSERT(i_axi_rresp == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line"><span class="keyword">if</span> (i_axi_bvalid&amp;&amp;(F_OPT_INITIAL || i_axi_reset_n))</span><br><span class="line">        `SLAVE_ASSERT(i_axi_bresp != <span class="number">2&#x27;b01</span>); <span class="comment">// Exclusive access not allowed</span></span><br><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line"><span class="keyword">if</span> (i_axi_rvalid&amp;&amp;(F_OPT_INITIAL || i_axi_reset_n))</span><br><span class="line">        `SLAVE_ASSERT(i_axi_rresp != <span class="number">2&#x27;b01</span>); <span class="comment">// Exclusive access not allowed</span></span><br></pre></td></tr></table></figure>

<p>这里的  &#96;&#96;SLAVE_ASSERT<code>在单独使用时候，使用 </code>assume<code>。如果嵌套在其他的 </code>moudle<code>中，那么需要使用 </code>assert&#96;。</p>
<h2 id="3-3-stablity-property"><a href="#3-3-stablity-property" class="headerlink" title="3.3 stablity property"></a>3.3 stablity property</h2><p>这个 <code>property</code>是为了检测 <code> valid before ready</code>的情况，这也是需要重点验证的情况。</p>
<p>什么时候使用 <code>ASSUME</code>，什么时候使用 <code>ASSERT</code>呢？</p>
<ul>
<li><code>master</code>的 <code>valid</code>信号由 <code>AW W AR</code>三个 <code>channel</code>发起，所以需要对这三个通道进行 <code>ASSERT check</code>；</li>
<li>在 <code>B R</code>两个通道中， <code>valid</code>信号由 <code>slave</code>发起，既然两个信号来源于外界，假设是一个 <code>perfect slave demo</code> ，那么由其发起的信号一定要正确。因为我们现在的任务是检测  <code>master</code>的正确性，如果<code>slave</code>信号发生了错误，不能判断是不是  <code>master</code>  的设计出错。 <code>master</code>方在这两个通道中只负责 <code>ready</code>信号。</li>
<li>还是要强调：代码中的定义是交叉的 <code>ASSUME</code>对应 <code>assert</code>， <code>ASSERT</code>对 <code>assume</code>。</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assume any response from the bus will not change prior to that</span></span><br><span class="line"><span class="comment">// response being accepted</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> ((f_past_valid)&amp;&amp;(<span class="built_in">$past</span>(i_axi_reset_n))</span><br><span class="line">		&amp;&amp;(!F_OPT_ASYNC_RESET || i_axi_reset_n))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="comment">// Write address channel</span></span><br><span class="line">	<span class="keyword">if</span> ((f_past_valid)&amp;&amp;(<span class="built_in">$past</span>(i_axi_awvalid &amp;&amp; !i_axi_awready)))</span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		`SLAVE_ASSUME(i_axi_awvalid);</span><br><span class="line">		`SLAVE_ASSUME(<span class="built_in">$stable</span>(i_axi_awaddr));</span><br><span class="line">		`SLAVE_ASSUME(<span class="built_in">$stable</span>(i_axi_awprot));</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Write data channel</span></span><br><span class="line">	<span class="keyword">if</span> ((f_past_valid &amp;&amp; (!F_OPT_ASYNC_RESET || i_axi_reset_n))</span><br><span class="line">			&amp;&amp;(<span class="built_in">$past</span>(i_axi_wvalid &amp;&amp; !i_axi_wready)))</span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		`SLAVE_ASSUME(i_axi_wvalid);</span><br><span class="line">		`SLAVE_ASSUME(<span class="built_in">$stable</span>(i_axi_wstrb));</span><br><span class="line">		`SLAVE_ASSUME(<span class="built_in">$stable</span>(i_axi_wdata));</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Incoming Read address channel</span></span><br><span class="line">	<span class="keyword">if</span> ((f_past_valid &amp;&amp; (!F_OPT_ASYNC_RESET || i_axi_reset_n))</span><br><span class="line">		&amp;&amp;(<span class="built_in">$past</span>(i_axi_arvalid &amp;&amp; !i_axi_arready)))</span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		`SLAVE_ASSUME(i_axi_arvalid);</span><br><span class="line">		`SLAVE_ASSUME(<span class="built_in">$stable</span>(i_axi_araddr));</span><br><span class="line">		`SLAVE_ASSUME(<span class="built_in">$stable</span>(i_axi_arprot));</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">     	<span class="comment">// write response channel</span></span><br><span class="line">	<span class="keyword">if</span> ((f_past_valid &amp;&amp; (!F_OPT_ASYNC_RESET || i_axi_reset_n))</span><br><span class="line">		&amp;&amp;(<span class="built_in">$past</span>(i_axi_rvalid &amp;&amp; !i_axi_rready)))</span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		`SLAVE_ASSERT(i_axi_rvalid);</span><br><span class="line">		`SLAVE_ASSERT(<span class="built_in">$stable</span>(i_axi_rresp));</span><br><span class="line">		`SLAVE_ASSERT(<span class="built_in">$stable</span>(i_axi_rdata));</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">     	<span class="comment">// read date response channel</span></span><br><span class="line">	<span class="keyword">if</span> ((f_past_valid &amp;&amp; (!F_OPT_ASYNC_RESET || i_axi_reset_n))</span><br><span class="line">		&amp;&amp;(<span class="built_in">$past</span>(i_axi_bvalid &amp;&amp; !i_axi_bready)))</span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		`SLAVE_ASSERT(i_axi_bvalid);</span><br><span class="line">		`SLAVE_ASSERT(<span class="built_in">$stable</span>(i_axi_bresp));</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中 <code>if</code>语句使用了 <code>((f_past_valid)&amp;&amp;($past(i_axi_reset_n)) &amp;&amp;( i_axi_reset_n))</code></p>
<ul>
<li><code>f_past_valid== 1</code> ：采集到这个信号状态，表示非 <code>initial</code>状态；</li>
<li><code>$past(i_axi_reset_n) == 1</code>：上一次 <code>cycle</code>没有进行复位；</li>
<li><code>( i_axi_reset_n)== 1</code>：本次 <code>cycle</code>没有进行复位；</li>
</ul>
<blockquote>
<p> 为什么要使用判断语句：<code>($past(i_axi_reset_n)) &amp;&amp;( i_axi_reset_n)</code></p>
</blockquote>
<p>这个判断语句通常用于检测复位信号是否已经被释放。如果在上一个时钟周期和当前时钟周期中，<code>i_axi_reset_n</code>都为真，那么说明复位信号已经被释放，可以进行正常的操作。否则，如果<code>i_axi_reset_n</code>在任何一个时钟周期中为假，那么说明系统正在复位，不能进行正常的操作。</p>
<p><code>initial</code>的通道信号，还是上面的道理区分 <code>ASSUME</code>和 <code>ASSERT</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Nothing should be returned or requested on the first clock</span></span><br><span class="line"><span class="keyword">generate</span> <span class="keyword">if</span> (F_OPT_INITIAL)</span><br><span class="line"><span class="keyword">begin</span> : INITIAL_VALUE_CHECKS</span><br><span class="line">	<span class="keyword">initial</span>	`SLAVE_ASSUME(!i_axi_arvalid);</span><br><span class="line">	<span class="keyword">initial</span>	`SLAVE_ASSUME(!i_axi_awvalid);</span><br><span class="line">	<span class="keyword">initial</span>	`SLAVE_ASSUME(!i_axi_wvalid);</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="keyword">initial</span>	`SLAVE_ASSERT(!i_axi_bvalid);</span><br><span class="line">	<span class="keyword">initial</span>	`SLAVE_ASSERT(!i_axi_rvalid);</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">endgenerate</span></span><br></pre></td></tr></table></figure>



<h1 id="4-MAX-limitation"><a href="#4-MAX-limitation" class="headerlink" title="4. MAX limitation"></a>4. MAX limitation</h1><p>这部分主要对于：<code>max wait</code>、<code>max stall</code>、<code>max delay</code>、<code>outstanding</code> 四个部分进行主要解读。分别了解他们的概念定义，以及相关的逻辑设计与约束。</p>
<h2 id="4-1-MAX-WAIT"><a href="#4-1-MAX-WAIT" class="headerlink" title="4.1 MAX  WAIT"></a>4.1 MAX  WAIT</h2><blockquote>
<p>Insist upon a maximum delay before a request is accepted</p>
</blockquote>
<p>再次回顾相关的定义：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// F_AXI_MAXWAIT is the maximum number of clock cycles the</span></span><br><span class="line"><span class="comment">// master should have to wait for a slave to raise its ready flag to</span></span><br><span class="line"><span class="comment">// accept a request.  Set to zero for no limit.</span></span><br><span class="line"><span class="keyword">parameter</span>			F_AXI_MAXWAIT  = <span class="number">12</span>,</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该段<code>formal property</code> 确保在接收到请求之前，有一个最大的延迟限制。这是通过计算AXI总线上的读&#x2F;写通道的停滞次数来实现的。这里的停滞是指有效信号（valid signal）为真，而就绪信号（ready signal）为假的情况。</p>
</blockquote>
<p>首先是声明了相关的寄存器用来计数延迟周期。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">generate</span> <span class="keyword">if</span> (F_AXI_MAXWAIT &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">begin</span> : CHECK_STALL_COUNT</span><br><span class="line">        <span class="keyword">reg</span>     [LGTIMEOUT-<span class="number">1</span>:<span class="number">0</span>]         f_axi_awstall,</span><br><span class="line">                                        f_axi_wstall,</span><br><span class="line">                                        f_axi_arstall;</span><br></pre></td></tr></table></figure>



<h3 id="1-AXI-Write-Address-channel"><a href="#1-AXI-Write-Address-channel" class="headerlink" title="1. AXI Write Address channel"></a>1. AXI Write Address channel</h3><blockquote>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// AXI write address channel</span><br><span class="line">//</span><br><span class="line">// Count the number of times AWVALID is true while AWREADY</span><br><span class="line">// is false.  These are stalls, and we want to insist on a</span><br><span class="line">// minimum number of them.  However, if BVALID &amp;&amp; !BREADY,</span><br><span class="line">// then there&#x27;s a reason for not accepting anything more.</span><br><span class="line"></span><br><span class="line">// Similarly, many cores will only ever accept one request</span><br><span class="line">// at a time, hence we won&#x27;t count things as stalls if</span><br><span class="line">// WR-PENDING &gt; 0.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>首先是定义了一个寄存器<code>f_axi_awstall</code>来记录停滞的次数，并在初始时将其设置为0。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	f_axi_awstall = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<p>如果<code>i_axi_reset_n</code>为假（表示在复位状态），或者<code>i_axi_awvalid</code>为假（表示没有有效的写地址请求），或者<code>i_axi_awready</code>为真（表示已经准备好接收写地址请求），或者<code>i_axi_bvalid</code>为真（表示有有效的写回应），那么就将<code>f_axi_awstall</code>清零。这些情况下，都不会发生停滞。</p>
<ul>
<li>如果<code>i_axi_reset_n</code>为假，表示系统正在复位，此时所有的操作都应该停止，包括停滞的计数，所以将<code>f_axi_awstall</code>清零。</li>
<li>如果<code>i_axi_awvalid</code>为假，表示没有有效的写地址请求，那么就没有必要计算停滞，因为没有请求需要被处理，所以将<code>f_axi_awstall</code>清零。</li>
<li>如果<code>i_axi_awready</code>为真，表示已经准备好接收写地址请求，那么就不存在停滞的情况，因为请求可以被立即处理，所以将<code>f_axi_awstall</code>清零。</li>
<li>如果<code>i_axi_bvalid</code>为真，表示有有效的写回应，那么写地址通道就不应该被认为是停滞的，因为它可能正在等待写回应被接收，所以将<code>f_axi_awstall</code>清零。</li>
</ul>
<p><code>axi-lite </code>这边的协议， <code>AW W</code>通道的有效数据，需要上一阶段发送的数据被 <code>master ack</code>才能继续接受。不然会出现 <code>backpressure</code>的情况。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">	<span class="keyword">if</span> ((!i_axi_reset_n)||</span><br><span class="line">           (!i_axi_awvalid)||</span><br><span class="line">           (i_axi_awready) ||</span><br><span class="line">           (i_axi_bvalid))</span><br><span class="line">         </span><br><span class="line">		f_axi_awstall &lt;= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>在 <code>axi-lite</code>中， <code>AW W</code>双通道的数据传递到 <code>slave</code>端需要进行 <code>synchoronize</code>同步处理。如果 <code>AW</code>的 <code>ready</code>信号已经为 <code>true</code>，但是如果 <code>W</code>通道的 <code>data</code>并不是有效信号 —<code>!valid</code>，此时不算 <code>stall</code>处理。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f_axi_awr_outstanding &gt;= f_axi_wr_outstanding)</span><br><span class="line">	&amp;&amp;(i_axi_awvalid &amp;&amp; !i_axi_wvalid))</span><br><span class="line">	<span class="comment">// If we are waiting for the write channel to be valid</span></span><br><span class="line">	<span class="comment">// then don&#x27;t count stalls</span></span><br><span class="line">	f_axi_awstall &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	f_axi_awstall &lt;= f_axi_awstall + <span class="number">1&#x27;b1</span>;</span><br></pre></td></tr></table></figure>



<p>最后在 <code>formal verification</code>中，需要保证 <code>AW channel</code>的 <code>stall cycle</code>不会超过最大限制周期。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line">	`SLAVE_ASSERT(f_axi_awstall &lt; F_AXI_MAXWAIT);</span><br></pre></td></tr></table></figure>



<h3 id="2-AXI-Write-Data-channel"><a href="#2-AXI-Write-Data-channel" class="headerlink" title="2. AXI Write Data channel"></a>2. AXI Write Data channel</h3><blockquote>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// AXI write data channel</span><br><span class="line">//</span><br><span class="line">// Count the number of clock cycles that the write data</span><br><span class="line">// channel is stalled, that is while WVALID &amp;&amp; !WREADY.</span><br><span class="line"></span><br><span class="line">// Since things can back up if BVALID &amp; !BREADY, we avoid</span><br><span class="line">// counting clock cycles in that circumstance</span><br></pre></td></tr></table></figure>
</blockquote>
<p>对于 <code>stall register clear</code>有一样的逻辑。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	f_axi_wstall = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> ((!i_axi_reset_n)||</span><br><span class="line">          (!i_axi_wvalid) ||</span><br><span class="line">          (i_axi_wready)  ||</span><br><span class="line">          (i_axi_bvalid))</span><br><span class="line">        </span><br><span class="line">	f_axi_wstall &lt;= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f_axi_wr_outstanding &gt;= f_axi_awr_outstanding)</span><br><span class="line">	&amp;&amp;(!i_axi_awvalid &amp;&amp; i_axi_wvalid))</span><br><span class="line">	<span class="comment">// If we are waiting for the write address channel</span></span><br><span class="line">	<span class="comment">// to be valid, then don&#x27;t count stalls</span></span><br><span class="line">	f_axi_wstall &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	f_axi_wstall &lt;= f_axi_wstall + <span class="number">1&#x27;b1</span>;</span><br></pre></td></tr></table></figure>

<p>保证 <code>W channel</code>的 <code>stall cycle</code>不会超过最大限制周期。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line">	`SLAVE_ASSERT(f_axi_wstall &lt; F_AXI_MAXWAIT);</span><br></pre></td></tr></table></figure>



<h3 id="3-AXI-Read-Address-channel"><a href="#3-AXI-Read-Address-channel" class="headerlink" title="3. AXI Read Address channel"></a>3. AXI Read Address channel</h3><blockquote>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// AXI read address channel</span><br><span class="line">//</span><br><span class="line">// Similar to the first two above, once the master raises</span><br><span class="line">// ARVALID, insist that the slave respond within a minimum</span><br><span class="line">// number of clock cycles.  Exceptions include any time</span><br><span class="line">// RVALID is true, since that can back up the whole system,</span><br><span class="line">// and any time the number of bursts is greater than zero,</span><br><span class="line">// since many slaves can only accept one request at a time.</span><br><span class="line">initial	f_axi_arstall = 0;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>相关代码的实现如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">initial</span>	f_axi_arstall = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">	<span class="keyword">if</span> ((!i_axi_reset_n)||(!i_axi_arvalid)||(i_axi_arready)</span><br><span class="line">			||(i_axi_rvalid))</span><br><span class="line">		f_axi_arstall &lt;= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		f_axi_arstall &lt;= f_axi_arstall + <span class="number">1&#x27;b1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">always</span> @(*)</span><br><span class="line">		`SLAVE_ASSERT(f_axi_arstall &lt; F_AXI_MAXWAIT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">endgenerate</span></span><br></pre></td></tr></table></figure>





<h2 id="4-2-MAX-STALL"><a href="#4-2-MAX-STALL" class="headerlink" title="4.2 MAX STALL"></a>4.2 MAX STALL</h2><blockquote>
<p>Insist upon a maximum delay before any response is accepted</p>
</blockquote>
<p>再次回顾相关的定义。该部分主要用于限制 <code>master</code> 对 <code>slave valid</code>做出 <code>ack</code>行为的时钟周期延迟。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// F_AXI_MAXRSTALL is the maximum number of clock cycles the</span></span><br><span class="line"><span class="comment">// slave should have to wait with a return valid signal high, but</span></span><br><span class="line"><span class="comment">// while the master&#x27;s return ready signal is low.  Set to zero for no</span></span><br><span class="line"><span class="comment">// limit.</span></span><br><span class="line"><span class="keyword">parameter</span>			F_AXI_MAXRSTALL= <span class="number">12</span>,</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个互联网可能被迫让一个通道无限期地等待访问，但是可能不适合要求响应也能无限期地等待。换句话说，虽然你可能允许请求在被处理之前有一段较长的等待时间，但是你可能不希望响应也有同样长的等待时间。因此，你可以通过调整这两个延迟限制来分别控制请求和响应的等待时间。</p>
</blockquote>
<p>首先进行相关的寄存器声明：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">// if I set the limitation on the parameter-- maxstall</span></span><br><span class="line"><span class="keyword">generate</span> <span class="keyword">if</span> (F_AXI_MAXRSTALL &gt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">begin</span> : CHECK_RESPONSE_STALLS</span><br><span class="line">              <span class="keyword">reg</span>     [LGTIMEOUT-<span class="number">1</span>:<span class="number">0</span>]         f_axi_bstall,</span><br><span class="line">                                              f_axi_rstall;</span><br></pre></td></tr></table></figure>

<p>主代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// AXI write response channel</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Insist on a maximum number of clocks that BVALID can be</span></span><br><span class="line">	<span class="comment">// high while BREADY is low</span></span><br><span class="line">	<span class="keyword">initial</span>	f_axi_bstall = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">	<span class="keyword">if</span> ((!i_axi_reset_n)||</span><br><span class="line">           (!i_axi_bvalid) ||</span><br><span class="line">           (i_axi_bready))</span><br><span class="line">         </span><br><span class="line">		f_axi_bstall &lt;= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		f_axi_bstall &lt;= f_axi_bstall + <span class="number">1&#x27;b1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">always</span> @(*)</span><br><span class="line">		`SLAVE_ASSUME(f_axi_bstall &lt; F_AXI_MAXRSTALL);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// AXI read response channel</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Insist on a maximum number of clocks that RVALID can be</span></span><br><span class="line">	<span class="comment">// high while RREADY is low</span></span><br><span class="line">	<span class="keyword">initial</span>	f_axi_rstall = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">	<span class="keyword">if</span> ((!i_axi_reset_n)||</span><br><span class="line">           (!i_axi_rvalid) ||</span><br><span class="line">           (i_axi_rready))</span><br><span class="line">         </span><br><span class="line">		f_axi_rstall &lt;= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		f_axi_rstall &lt;= f_axi_rstall + <span class="number">1&#x27;b1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">always</span> @(*)</span><br><span class="line">		`SLAVE_ASSUME(f_axi_rstall &lt; F_AXI_MAXRSTALL);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">endgenerate</span></span><br></pre></td></tr></table></figure>



<h2 id="4-3-xilinx-guarantees"><a href="#4-3-xilinx-guarantees" class="headerlink" title="4.3 xilinx guarantees"></a>4.3 xilinx guarantees</h2><p>  <code>xilinx</code>在自己的设计中，加入了通道信号之间的依赖。同样见于 <code>xilinx slave formal verification</code>中。</p>
<blockquote>
<p>Xilinx extensions&#x2F;guarantees to the AXI protocol</p>
<ul>
<li>The address line will never be more than two clocks ahead of the write data channel;</li>
<li>The write data channel will never be more than one clock ahead of the address channel;</li>
</ul>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">generate</span> <span class="keyword">if</span> (F_OPT_XILINX)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="comment">// Rule number one:</span></span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">         	<span class="comment">// double reset means the state reset signal has been released</span></span><br><span class="line">	<span class="keyword">if</span> ((i_axi_reset_n)&amp;&amp;(<span class="built_in">$past</span>(i_axi_reset_n))</span><br><span class="line">           <span class="comment">// two clock ago, no aw stall happended</span></span><br><span class="line">		&amp;&amp;(<span class="built_in">$past</span>(i_axi_awvalid &amp;&amp; !i_axi_wvalid,<span class="number">2</span>))</span><br><span class="line">		&amp;&amp;(<span class="built_in">$past</span>(f_axi_awr_outstanding&gt;=f_axi_wr_outstanding,<span class="number">2</span>))</span><br><span class="line">           <span class="comment">// last cycle ,w channel is still not valid</span></span><br><span class="line">		&amp;&amp;(!<span class="built_in">$past</span>(i_axi_wvalid)))</span><br><span class="line">         </span><br><span class="line">         	<span class="comment">// this cycle , w channel must be valid</span></span><br><span class="line">		`SLAVE_ASSUME(i_axi_wvalid);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">	<span class="keyword">if</span> ((i_axi_reset_n)</span><br><span class="line">		&amp;&amp;(f_axi_awr_outstanding &gt; <span class="number">1</span>)</span><br><span class="line">		&amp;&amp;(f_axi_awr_outstanding-<span class="number">1</span> &gt; f_axi_wr_outstanding))</span><br><span class="line">         </span><br><span class="line">		`SLAVE_ASSUME(i_axi_wvalid);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">	<span class="keyword">if</span> ((i_axi_reset_n)</span><br><span class="line">		&amp;&amp;(<span class="built_in">$past</span>(f_axi_awr_outstanding &gt; f_axi_wr_outstanding))</span><br><span class="line">		&amp;&amp;(!<span class="built_in">$past</span>(axi_wr_req)))</span><br><span class="line">         </span><br><span class="line">		`SLAVE_ASSUME(i_axi_wvalid);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Rule number two:</span></span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">	<span class="keyword">if</span> ((i_axi_reset_n)&amp;&amp;(f_axi_awr_outstanding &lt; f_axi_wr_outstanding))</span><br><span class="line">		`SLAVE_ASSUME(i_axi_awvalid);</span><br><span class="line">     </span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">endgenerate</span></span><br></pre></td></tr></table></figure>



<p>上面代码中 <code>($past(f_axi_awr_outstanding&gt;=f_axi_wr_outstanding,2))</code>所代表的具体含义需要进一步研究。如果对 <code>outstanding</code>部分有很多的疑问，建议先跳过对这部分的代码理解。不要被一个部分限制很长的时间，也许该部分花时间是没用的，反而后面更多的阅读会帮助加深理解。</p>
<h2 id="4-4-Count-outstanding-transactions"><a href="#4-4-Count-outstanding-transactions" class="headerlink" title="4.4 Count outstanding transactions"></a>4.4 Count outstanding transactions</h2><p>这里首先需要对 <code>outstanding</code>的 <code>conception</code>进行一定的理解。</p>
<p>从字面理解，outstanding<strong>表示正在进行中的，未完成的意思，形象地说就是“在路上”。</strong>如果没有<code>outstanding</code>，或者说<code>outstanding</code>能力为<code>1</code>，则总线<code>Master</code>的行为如下(AHB总线就没有outstanding能力）：</p>
<ul>
<li>1）读操作：读地址命令 -&gt; 等待读数据返回 -&gt; 读地址命令 -&gt; 等待读数据返回 -&gt; </li>
<li>2）写操作：写地址命令-&gt;写数据-&gt;等待写响应返回-&gt;写地址命令-&gt;写数据-&gt;等待写响应返回</li>
</ul>
<p>然而，如果 <code>outstanding</code> 能力大于 <code>1</code>，那么：</p>
<ul>
<li>1）读操作：可以连续发出多个读地址命令，这期间如果读数据没有返回，则需要等待读数据返回，如果有读数据返回，则返回了几个，那么仍然可以接着发几个</li>
<li>2）写操作：可以连续发出多组写地址（写数据）命令，这期间如果写响应没有返回，则必须等待写响应返回才能接着发写地址（写数据）命令，如果有写响应返回，则返回了几个，那么仍然可以接着发几组</li>
</ul>
<h3 id="1-look-up-code"><a href="#1-look-up-code" class="headerlink" title="1. look up code"></a>1. look up code</h3><p>先直接看代码内容:</p>
<blockquote>
<p>Count outstanding write address channel requests</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	f_axi_awr_outstanding = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (!i_axi_reset_n)</span><br><span class="line">	f_axi_awr_outstanding &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">case</span>(&#123; (axi_awr_req), (axi_wr_ack) &#125;)</span><br><span class="line">	<span class="number">2&#x27;b10</span>: f_axi_awr_outstanding &lt;= f_axi_awr_outstanding + <span class="number">1&#x27;b1</span>;</span><br><span class="line">	<span class="number">2&#x27;b01</span>: f_axi_awr_outstanding &lt;= f_axi_awr_outstanding - <span class="number">1&#x27;b1</span>;</span><br><span class="line">	<span class="keyword">default</span>: <span class="keyword">begin</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Count outstanding write data channel requests</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	f_axi_wr_outstanding = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (!i_axi_reset_n)</span><br><span class="line">	f_axi_wr_outstanding &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">case</span>(&#123; (axi_wr_req), (axi_wr_ack) &#125;)</span><br><span class="line"><span class="number">2&#x27;b01</span>: f_axi_wr_outstanding &lt;= f_axi_wr_outstanding - <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="number">2&#x27;b10</span>: f_axi_wr_outstanding &lt;= f_axi_wr_outstanding + <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">default</span>: <span class="keyword">begin</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Count outstanding read requests</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	f_axi_rd_outstanding = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (!i_axi_reset_n)</span><br><span class="line">	f_axi_rd_outstanding &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">case</span>(&#123; (axi_ard_req), (axi_rd_ack) &#125;)</span><br><span class="line"><span class="number">2&#x27;b01</span>: f_axi_rd_outstanding &lt;= f_axi_rd_outstanding - <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="number">2&#x27;b10</span>: f_axi_rd_outstanding &lt;= f_axi_rd_outstanding + <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">default</span>: <span class="keyword">begin</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中出现了十分重要的两个信号分别是 <code>xx_req</code>和 <code>xx_ack</code>信号。该文章讲述的是 <code>master</code>相关的问题， <code>req</code>是指由 <code>AW W AR</code>三个通道发起的 <code>valid</code>信号的确认。 <code>ack</code>是对 <code>B、R</code>两个通道进行 <code>acknowledge</code>确认。对于 <code>master</code>来讲，会分别确认三个通道的 <code>req 、 ack</code>信号来判断 <code>outstanding</code>。</p>
<h3 id="2-constraint"><a href="#2-constraint" class="headerlink" title="2. constraint"></a>2. constraint</h3><p>在使用逻辑记录下每次 <code>outstanding</code>变化后，需要 <code>make sure</code>设计的 <code>outstanding power</code>不要超过一定的阈值。体现在两个方面：</p>
<ul>
<li><em>Do not let the number of outstanding requests overflow</em></li>
<li><em>requests need to stop when we’re almost full</em></li>
</ul>
<blockquote>
<p>First, we want to make certain our counters never overflow.</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Do not let the number of outstanding requests overflow</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">	`SLAVE_ASSERT(f_axi_wr_outstanding  &lt; &#123;(F_LGDEPTH)&#123;<span class="number">1&#x27;b1</span>&#125;&#125;);</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">	`SLAVE_ASSERT(f_axi_awr_outstanding &lt; &#123;(F_LGDEPTH)&#123;<span class="number">1&#x27;b1</span>&#125;&#125;);</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">	`SLAVE_ASSERT(f_axi_rd_outstanding  &lt; &#123;(F_LGDEPTH)&#123;<span class="number">1&#x27;b1</span>&#125;&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Second, in order to guarantee that the counters never overflow, we’ll need to insist that the channel stops making a request one clock earlier.</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> ((F_OPT_INITIAL || i_axi_reset_n) &amp;&amp; f_axi_awr_outstanding == &#123; &#123;(F_LGDEPTH-<span class="number">1</span>)&#123;<span class="number">1&#x27;b1</span>&#125;&#125;, <span class="number">1&#x27;b0</span>&#125; )</span><br><span class="line">	<span class="keyword">assert</span>(!i_axi_awvalid);</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> ((F_OPT_INITIAL || i_axi_reset_n) &amp;&amp; f_axi_wr_outstanding == &#123; &#123;(F_LGDEPTH-<span class="number">1</span>)&#123;<span class="number">1&#x27;b1</span>&#125;&#125;, <span class="number">1&#x27;b0</span>&#125; )</span><br><span class="line">	<span class="keyword">assert</span>(!i_axi_wvalid);</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> ((F_OPT_INITIAL || i_axi_reset_n) &amp;&amp; f_axi_rd_outstanding == &#123; &#123;(F_LGDEPTH-<span class="number">1</span>)&#123;<span class="number">1&#x27;b1</span>&#125;&#125;, <span class="number">1&#x27;b0</span>&#125; )</span><br><span class="line">	<span class="keyword">assert</span>(!i_axi_arvalid);</span><br></pre></td></tr></table></figure>

<p>当我初次看到这个代码时候，对 <code>(F_OPT_INITIAL || i_axi_reset_n)</code>感到困惑。我去查找了关于 <code>salve</code>的相关 <code>formal property</code>代码后，观察到其并没有出现 <code>master</code>的这个需求，具体代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (f_axi_rd_outstanding == &#123; &#123;(F_LGDEPTH-<span class="number">1</span>)&#123;<span class="number">1&#x27;b1</span>&#125;&#125;, <span class="number">1&#x27;b0</span>&#125; )</span><br><span class="line">	<span class="keyword">assert</span>(!i_axi_arvalid);</span><br></pre></td></tr></table></figure>



<h3 id="3-conclusion"><a href="#3-conclusion" class="headerlink" title="3. conclusion"></a>3. conclusion</h3><p>还是要注意关于 <code>master</code>和 <code>slave</code>在不同情况下如何使用 <code>assert</code>和 <code>assume</code>。哪些是 <code>assert check</code>，哪些是假设的 <code>assume</code>需要去分开。在代码中也能看出两者的区别。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// slave defination</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span>	SLAVE_ASSUME	assume</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span>	SLAVE_ASSERT	assert</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//master defination</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span>	SLAVE_ASSUME	assert</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span>	SLAVE_ASSERT	assume</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结就是：对本地 local implement 进行 assert ，对外部输入信号进行 assumption</p>
<p>来源于slave property ：You might notice that these are all a series of assertions–for both <a target="_blank" rel="noopener" href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_master.v">master</a> and <a target="_blank" rel="noopener" href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">slave</a>. They are not <code>SLAVE_ASSERT()</code>ions, but rather regular assertions. This somewhat violates our rule, that we only make assertions of local state and outputs. However, if an assumption is required to keep this number lower, that assumption should really exist within the implementation defined code. Hence we’ll just use regular assertions here.</p>
</blockquote>
<h2 id="4-5-MAX-DELAY"><a href="#4-5-MAX-DELAY" class="headerlink" title="4.5 MAX DELAY"></a>4.5 MAX DELAY</h2><p>在之前的内容中提到了两个类似的概念，分别是： <code>max wait</code>、 <code>max stall </code>.</p>
<ul>
<li><em>max wait</em> ：<em>a maximum delay before <strong>a request of master</strong> is accepted</em></li>
<li><em>max stall</em>：a maximum delay before any response is accepted by <strong>the master</strong></li>
</ul>
<p>这里的 <code>delay</code>表示新的概念： <code>req</code>由 <code>master</code>方发起后， <code>slave </code>进行处理并返回相应的 <code>response</code>信号，中间所需要花费的时钟周期。</p>
<blockquote>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Insist that all responses are returned in less than a maximum delay</span><br><span class="line">In this case, we count responses within a burst, rather than entire</span><br><span class="line">bursts.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A unique feature to the backpressure mechanism within AXI is that</span><br><span class="line">we have to reset our delay counters in the case of any push back,</span><br><span class="line">since the response can&#x27;t move forward if the master isn&#x27;t (yet)</span><br><span class="line">ready for it.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>首先还是寄存器的声明：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">generate</span> <span class="keyword">if</span> (F_AXI_MAXDELAY &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">begin</span> : CHECK_MAX_DELAY</span><br><span class="line"></span><br><span class="line">	<span class="keyword">reg</span>	[LGTIMEOUT-<span class="number">1</span>:<span class="number">0</span>]		f_axi_wr_ack_delay,</span><br><span class="line">					f_axi_rd_ack_delay;</span><br></pre></td></tr></table></figure>



<h3 id="1-W-response-delay"><a href="#1-W-response-delay" class="headerlink" title="1. W response delay"></a>1. W response delay</h3><blockquote>
<p>关于<strong>写 delay</strong>的相关定义如下：</p>
<p>Count the clock cycles a write request (address + data) has been outstanding and without any response</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	f_axi_wr_ack_delay = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">      <span class="comment">// i_axi_bvalid ==1 ,means that the last request had been handled</span></span><br><span class="line">      <span class="comment">// AW channel has no outstanding</span></span><br><span class="line">      <span class="comment">// W  channel has no outstanding</span></span><br><span class="line"><span class="keyword">if</span> ((!i_axi_reset_n)||(i_axi_bvalid)</span><br><span class="line">		||(f_axi_awr_outstanding==<span class="number">0</span>)</span><br><span class="line">		||(f_axi_wr_outstanding==<span class="number">0</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// if one of the situations above happended, there should be no </span></span><br><span class="line">        <span class="comment">// wr ack delay </span></span><br><span class="line">	f_axi_wr_ack_delay &lt;= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (f_axi_wr_outstanding &gt; <span class="number">0</span>)</span><br><span class="line">	f_axi_wr_ack_delay &lt;= f_axi_wr_ack_delay + <span class="number">1&#x27;b1</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Q: 为什么关于 wr delay只需要看 w channel即可.</p>
<p>A：<code>f_axi_wr_outstanding</code> 是用来记录当前未完成的写数据请求的数量。当 <code>f_axi_wr_outstanding &gt; 0</code> 时，表示有未完成的写数据请求，也就是说，有 outstanding 的写请求。这里只看 <code>f_axi_wr_outstanding &gt; 0</code> 是因为在 AXI 协议中，写请求包括写地址请求和写数据请求，它们是分离的。</p>
<p>在一次完整的写操作中，首先发送写地址请求，然后发送写数据请求。因此，即使写地址请求已经完成（也就是说，<code>f_axi_awr_outstanding == 0</code>），但只要写数据请求还没有完成（也就是说，<code>f_axi_wr_outstanding &gt; 0</code>），那么就仍然存在 outstanding 的写请求。因此，这里只看 <code>f_axi_wr_outstanding &gt; 0</code> 就足够了，因为它能准确地反映当前是否有未完成的写数据请求，从而判断是否有 outstanding 的写请求。</p>
<p>Q:为什么 <code>AW W</code>通道任意一个 <code>outstanding == 0</code>就会 <em>clear the delay</em> ？</p>
<p>A：对于 <em>axi-lite</em> 来说，需要 <code>W AW</code>两个通道 <code>synchoronize</code>同步才能进行 <em>write operation</em>。只有一个通道。<em>axil</em>进行写的时候，<em>A</em> 和 <em>W</em> 的<code>outstanding == 1</code>，此时 <code>delay</code>信号会逐渐增加。</p>
</blockquote>
<h3 id="2-R-response-delay"><a href="#2-R-response-delay" class="headerlink" title="2. R response delay"></a>2. R response delay</h3><p><strong>关于 read的相关定义如下</strong>：</p>
<blockquote>
<p>Count the clock cycles that any read request has been outstanding, but without any response.</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	f_axi_rd_ack_delay = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> ((!i_axi_reset_n)||</span><br><span class="line">          (i_axi_rvalid)  ||</span><br><span class="line">          (f_axi_rd_outstanding==<span class="number">0</span>))</span><br><span class="line">        </span><br><span class="line">	f_axi_rd_ack_delay &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	f_axi_rd_ack_delay &lt;= f_axi_rd_ack_delay + <span class="number">1&#x27;b1</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>i_axi_rvalid==1</code>：表示<em>axi-lite</em> 的上一个 <em>req</em> 已经成功被处理；</li>
<li><code>f_axi_rd_outstanding==0</code>：表示 <em>read channel</em> 上已经没了需要等待处理，或者未处理完成的 <em>req</em>；</li>
</ul>
<h3 id="3-delay-assert-limitation"><a href="#3-delay-assert-limitation" class="headerlink" title="3. delay assert limitation"></a>3. delay assert limitation</h3><p>这部分的 <code>ASSERT</code>使用的是 <code>ASSUME</code>，在定义部分需要更改回来。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// Assert that write responses will be returned in a timely</span></span><br><span class="line">	<span class="comment">// fashion</span></span><br><span class="line">	<span class="keyword">always</span> @(*)</span><br><span class="line">		`SLAVE_ASSERT(f_axi_wr_ack_delay &lt; F_AXI_MAXDELAY);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Assert that read responses will be returned in a timely</span></span><br><span class="line">	<span class="comment">// fashion</span></span><br><span class="line">	<span class="keyword">always</span> @(*)</span><br><span class="line">		`SLAVE_ASSERT(f_axi_rd_ack_delay &lt; F_AXI_MAXDELAY);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">endgenerate</span></span><br></pre></td></tr></table></figure>



<h1 id="5-acknowledgements-requests"><a href="#5-acknowledgements-requests" class="headerlink" title="5. acknowledgements &amp; requests"></a>5. acknowledgements &amp; requests</h1><blockquote>
<p>Author: </p>
<ul>
<li><strong>Assume acknowledgements must follow requests</strong></li>
<li>The <code>f_axi*outstanding counters</code> count the number of requests.  No acknowledgment should issue without a pending request burst. </li>
<li>Further, the spec is clear: <strong>you can’t acknowledge something on the same clock you get the request.  There must be at least one clock delay</strong>.</li>
</ul>
</blockquote>
<p>怎么理解上面的 constraint：</p>
<blockquote>
<p>在一次典型的写操作中，master 设备首先发送一个写地址请求，然后发送写数据请求。在接收到写地址请求和写数据请求后，slave 设备需要发送一个写响应来确认接收。</p>
<p>在这个过程中，我们需要确保两个重要的规则：</p>
<ol>
<li><p><strong>确认信号必须在请求信号之后发送</strong>。</p>
<p><strong>Assume acknowledgements must follow requests.</strong></p>
<p>也就是说，slave 设备不能在还没有接收到写地址请求和写数据请求的情况下就发送写响应。</p>
<p>为了实现这个规则，我们可以使用一个计数器 <code>f_axi_wr_outstanding</code> 来记录当前未完成的写数据请求的数量。只有当 <code>f_axi_wr_outstanding &gt; 0</code>，也就是有未完成的写数据请求时，slave 设备才能发送写响应。</p>
</li>
<li><p><strong>不能在同一时钟周期内发送请求信号和确认信号</strong>。</p>
<p>**you can’t acknowledge something on the same clock you get the request. **</p>
<p>也就是说，slave 设备不能在接收到写地址请求或写数据请求的同一时钟周期内就发送写响应。</p>
<p>为了实现这个规则，我们可以引入一个延迟计数器 <code>f_axi_wr_ack_delay</code>，用于记录写请求的延迟时间。每当时钟上升沿到来时，如果有未完成的写数据请求，那么就将 <code>f_axi_wr_ack_delay</code> 加一；如果收到了写响应，那么就将 <code>f_axi_wr_ack_delay</code> 清零。</p>
</li>
</ol>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AXI write response channel</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (i_axi_bvalid &amp;&amp; (F_OPT_INITIAL || i_axi_reset_n))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="comment">// No BVALID w/o an outstanding request</span></span><br><span class="line">	`SLAVE_ASSERT(f_axi_awr_outstanding &gt; <span class="number">0</span>);</span><br><span class="line">	`SLAVE_ASSERT(f_axi_wr_outstanding  &gt; <span class="number">0</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// AXI read data channel signals</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (i_axi_rvalid &amp;&amp; (F_OPT_INITIAL || i_axi_reset_n))</span><br><span class="line">	<span class="comment">// No RVALID w/o an outstanding request</span></span><br><span class="line">	`SLAVE_ASSERT(f_axi_rd_outstanding &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>明确这个 <code>SLAVE_ASSERET</code>是使用的 <code>assume</code>，因为这里的 <code>master</code>需要一个 <code>perfect slave demo</code>，所以使用 <code>assume</code>。如果是使用的外部设计传输的信号，需要更改为 <code>assert</code>。</p>
<h1 id="6-Only-W-or-R"><a href="#6-Only-W-or-R" class="headerlink" title="6. Only W or R"></a>6. Only W or R</h1><p>首先两个 <em>parameter</em> 不能同时设置为 <code>1</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	<span class="keyword">assert</span>((!F_OPT_WRITE_ONLY)||(!F_OPT_READ_ONLY));</span><br></pre></td></tr></table></figure>

<p>如果只有 <code>write</code> ，对本地发起的 <code>arvalid</code>信号进行 <code>assert（ arvalid == 0 ）</code>；对外界进来的 <code>rvalid</code>信号进行 <code>assume（rvalid == 0）</code>处理。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">generate</span> <span class="keyword">if</span> (F_OPT_WRITE_ONLY)</span><br><span class="line"><span class="keyword">begin</span> : NO_READS</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If there are no read requests (assumed), there should be</span></span><br><span class="line">	<span class="comment">// no read responses</span></span><br><span class="line">	<span class="keyword">always</span> @(*)</span><br><span class="line">		`SLAVE_ASSUME(i_axi_arvalid == <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">always</span> @(*)</span><br><span class="line">         <span class="comment">// there should be no outstanding</span></span><br><span class="line">		<span class="keyword">assert</span>(f_axi_rd_outstanding == <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">always</span> @(*)</span><br><span class="line">		`SLAVE_ASSERT(i_axi_rvalid == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">endgenerate</span></span><br></pre></td></tr></table></figure>

<p>如果只有 <code>read</code>，对本地的 <code>awvalid</code>信号， <code>wvalid</code>信号进行低位信号处理。相应 <code>outstanding</code>信号需要保持 <code>0</code>数量，最后强制 <code>assume</code>外界的slave返回的 <code>bvalid</code>信号为 <code>0</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">generate</span> <span class="keyword">if</span> (F_OPT_READ_ONLY)</span><br><span class="line"><span class="keyword">begin</span> : NO_WRITES</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If there are no write requests (assumed, address or data),</span></span><br><span class="line">	<span class="comment">// there should be no read responses</span></span><br><span class="line">	<span class="keyword">always</span> @(*)</span><br><span class="line">		`SLAVE_ASSUME(i_axi_awvalid == <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">always</span> @(*)</span><br><span class="line">		`SLAVE_ASSUME(i_axi_wvalid == <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">always</span> @(*)</span><br><span class="line">		<span class="keyword">assert</span>(f_axi_wr_outstanding == <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">always</span> @(*)</span><br><span class="line">		<span class="keyword">assert</span>(f_axi_awr_outstanding == <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">always</span> @(*)</span><br><span class="line">		`SLAVE_ASSERT(i_axi_bvalid == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">endgenerate</span></span><br></pre></td></tr></table></figure>



<h1 id="7-Cover-Property"><a href="#7-Cover-Property" class="headerlink" title="7. Cover Property"></a>7. Cover Property</h1><p>该小结的目的是：</p>
<blockquote>
<p>We’ll use this to prove that transactions are even possible, and hence that we haven’t so constrained the bus that nothing can take place.</p>
</blockquote>
<p><code>cover</code>在 <code>B、R</code>两个通道中都需要一个 <code>handshake</code>的发生。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AXI write response channel</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">generate</span> <span class="keyword">if</span> (!F_OPT_READ_ONLY)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">		<span class="comment">// Make sure we can get a write acknowledgment</span></span><br><span class="line">		<span class="keyword">cover</span>((i_axi_bvalid)&amp;&amp;(i_axi_bready));</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">endgenerate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// AXI read response channel</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">generate</span> <span class="keyword">if</span> (!F_OPT_WRITE_ONLY)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">		<span class="comment">// Make sure we can get a response from the read channel</span></span><br><span class="line">		<span class="keyword">cover</span>((i_axi_rvalid)&amp;&amp;(i_axi_rready));</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">endgenerate</span></span><br></pre></td></tr></table></figure>

<p>可以是否有 <code>cover burst power</code>。如果不是只有 <code>read_only</code>并且 <code>F_OPT_COVER_BURST == 1</code>会进行下面的 <code>write burst </code>能力检测。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">generate</span> <span class="keyword">if</span> (!F_OPT_READ_ONLY &amp;&amp; F_OPT_COVER_BURST &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">begin</span> : COVER_WRITE_BURSTS</span><br><span class="line"></span><br><span class="line">	<span class="keyword">reg</span>	[<span class="number">31</span>:<span class="number">0</span>]	cvr_writes;</span><br><span class="line">	<span class="keyword">initial</span>	cvr_writes = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">	<span class="keyword">if</span> (!i_axi_reset_n)</span><br><span class="line">		cvr_writes &lt;= <span class="number">0</span>;</span><br><span class="line">     			</span><br><span class="line">    		 <span class="comment">// A handshake in B channel happends</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (i_axi_bvalid &amp;&amp; i_axi_bready &amp;&amp; </span><br><span class="line">         	<span class="comment">//  return a NO err response</span></span><br><span class="line">         		i_axi_bresp == <span class="number">2&#x27;b00</span>		  &amp;&amp; </span><br><span class="line">         	<span class="comment">//  the register cvr_writes does not reach 0x_FFFF</span></span><br><span class="line">         		!(&amp;cvr_writes))</span><br><span class="line">         	<span class="comment">//  the register add one</span></span><br><span class="line">		cvr_writes &lt;= cvr_writes + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// the number of the B response should happend N times</span></span><br><span class="line">	<span class="keyword">always</span> @(*)</span><br><span class="line">		<span class="keyword">cover</span>(cvr_writes == F_OPT_COVER_BURST);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">endgenerate</span></span><br></pre></td></tr></table></figure>

<p>使用同样的方法进行 <code>R channel</code>的cover。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">generate</span> <span class="keyword">if</span> (!F_OPT_WRITE_ONLY &amp;&amp; F_OPT_COVER_BURST &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">begin</span> : COVER_READ_BURSTS</span><br><span class="line"></span><br><span class="line">	<span class="keyword">reg</span>	[<span class="number">31</span>:<span class="number">0</span>]	cvr_reads;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">initial</span>	cvr_reads = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">	<span class="keyword">if</span> (!i_axi_reset_n)</span><br><span class="line">		cvr_reads &lt;= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (i_axi_rvalid &amp;&amp; i_axi_rready &amp;&amp; i_axi_rresp == <span class="number">2&#x27;b00</span></span><br><span class="line">			&amp;&amp; !(&amp;cvr_reads))</span><br><span class="line">		cvr_reads &lt;= cvr_reads + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">always</span> @(*)</span><br><span class="line">		<span class="keyword">cover</span>(cvr_reads == F_OPT_COVER_BURST);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">endgenerate</span></span><br></pre></td></tr></table></figure>













</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://more_study@163.com">冰蒂斯</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://more_study@163.com/2023/11/18/Property-master/">http://more_study@163.com/2023/11/18/Property-master/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://more_study@163.com" target="_blank">冰蒂斯のformula</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/AXI/">AXI</a><a class="post-meta__tags" href="/tags/master/">master</a><a class="post-meta__tags" href="/tags/formal/">formal</a></div><div class="post_share"><div class="social-share" data-image="/img/chainsaw_makima04.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/18/Property-slave/" title="Property-axil-slave"><img class="cover" src="/img/chainsaw_power01.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Property-axil-slave</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/15/5-1-1-basic-master/" title="5-1 basic_master(中)"><img class="cover" src="/img/chainsaw_makima04.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">5-1 basic_master(中)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/11/23/5-1-2-basic-master/" title="5-1 basic_master(下)"><img class="cover" src="/img/chainsaw_makima04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-23</div><div class="title">5-1 basic_master(下)</div></div></a></div><div><a href="/2023/11/15/5-1-1-basic-master/" title="5-1 basic_master(中)"><img class="cover" src="/img/chainsaw_makima04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-15</div><div class="title">5-1 basic_master(中)</div></div></a></div><div><a href="/2023/11/13/5-1-basic-master/" title="5-1 basic_master(上)"><img class="cover" src="/img/chainsaw_makima04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-13</div><div class="title">5-1 basic_master(上)</div></div></a></div><div><a href="/2023/12/06/MM2S/" title="MM2S"><img class="cover" src="/img/chainsaw_red.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-06</div><div class="title">MM2S</div></div></a></div><div><a href="/2023/12/03/axi-master-fulllast/" title="axi_(full)master(下)"><img class="cover" src="/img/chainsaw_makima04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-03</div><div class="title">axi_(full)master(下)</div></div></a></div><div><a href="/2023/11/25/axi-master-full/" title="axi(full)master(上)"><img class="cover" src="/img/chainsaw_makima04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-25</div><div class="title">axi(full)master(上)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">冰蒂斯</div><div class="author-info__description">螺旋上升的人生,也是多线程的人生</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/more_study@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-introduction"><span class="toc-number">1.</span> <span class="toc-text">1. introduction</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Declarations"><span class="toc-number">2.</span> <span class="toc-text">2. Declarations</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-parameter"><span class="toc-number">2.1.</span> <span class="toc-text">2.1  parameter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-signals"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 signals</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-registr-wire"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 registr &amp;  wire</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Property"><span class="toc-number">3.</span> <span class="toc-text">3. Property</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-assume-assert"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 assume &amp; assert</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-reset-property"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 reset property</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-set-up"><span class="toc-number">3.2.1.</span> <span class="toc-text">1. set up</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-reset-16-clocks"><span class="toc-number">3.2.2.</span> <span class="toc-text">2. reset 16 clocks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-The-flaw-I-guess"><span class="toc-number">3.2.3.</span> <span class="toc-text">3. The flaw I guess</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-xVALID-initial-low"><span class="toc-number">3.2.4.</span> <span class="toc-text">4. xVALID initial low</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-xRESP-checking"><span class="toc-number">3.2.5.</span> <span class="toc-text">5.  xRESP checking</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-stablity-property"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 stablity property</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-MAX-limitation"><span class="toc-number">4.</span> <span class="toc-text">4. MAX limitation</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-MAX-WAIT"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 MAX  WAIT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-AXI-Write-Address-channel"><span class="toc-number">4.1.1.</span> <span class="toc-text">1. AXI Write Address channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-AXI-Write-Data-channel"><span class="toc-number">4.1.2.</span> <span class="toc-text">2. AXI Write Data channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-AXI-Read-Address-channel"><span class="toc-number">4.1.3.</span> <span class="toc-text">3. AXI Read Address channel</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-MAX-STALL"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 MAX STALL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-xilinx-guarantees"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 xilinx guarantees</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-Count-outstanding-transactions"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 Count outstanding transactions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-look-up-code"><span class="toc-number">4.4.1.</span> <span class="toc-text">1. look up code</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-constraint"><span class="toc-number">4.4.2.</span> <span class="toc-text">2. constraint</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-conclusion"><span class="toc-number">4.4.3.</span> <span class="toc-text">3. conclusion</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-MAX-DELAY"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 MAX DELAY</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-W-response-delay"><span class="toc-number">4.5.1.</span> <span class="toc-text">1. W response delay</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-R-response-delay"><span class="toc-number">4.5.2.</span> <span class="toc-text">2. R response delay</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-delay-assert-limitation"><span class="toc-number">4.5.3.</span> <span class="toc-text">3. delay assert limitation</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-acknowledgements-requests"><span class="toc-number">5.</span> <span class="toc-text">5. acknowledgements &amp; requests</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-Only-W-or-R"><span class="toc-number">6.</span> <span class="toc-text">6. Only W or R</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-Cover-Property"><span class="toc-number">7.</span> <span class="toc-text">7. Cover Property</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/03/09/axilite-mux/" title="axilite-mux"><img src="/img/makima.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="axilite-mux"/></a><div class="content"><a class="title" href="/2024/03/09/axilite-mux/" title="axilite-mux">axilite-mux</a><time datetime="2024-03-09T03:30:56.000Z" title="发表于 2024-03-09 11:30:56">2024-03-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/26/cocotbaxi-01-try/" title="cocotbaxi-01-try"><img src="/img/makima.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="cocotbaxi-01-try"/></a><div class="content"><a class="title" href="/2024/02/26/cocotbaxi-01-try/" title="cocotbaxi-01-try">cocotbaxi-01-try</a><time datetime="2024-02-26T13:55:25.000Z" title="发表于 2024-02-26 21:55:25">2024-02-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/11/AXI-Master-bursting/" title="difficult of AXI Master Bursting"><img src="/img/chainsaw_makima04.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="difficult of AXI Master Bursting"/></a><div class="content"><a class="title" href="/2024/01/11/AXI-Master-bursting/" title="difficult of AXI Master Bursting">difficult of AXI Master Bursting</a><time datetime="2024-01-11T08:52:33.000Z" title="发表于 2024-01-11 16:52:33">2024-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/10/Plan-XJY/" title="Plan_XJY"><img src="/img/chainsaw_power01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Plan_XJY"/></a><div class="content"><a class="title" href="/2024/01/10/Plan-XJY/" title="Plan_XJY">Plan_XJY</a><time datetime="2024-01-10T07:46:33.000Z" title="发表于 2024-01-10 15:46:33">2024-01-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/07/skid-buffer/" title="skid_buffer"><img src="/img/chainsaw_power01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="skid_buffer"/></a><div class="content"><a class="title" href="/2024/01/07/skid-buffer/" title="skid_buffer">skid_buffer</a><time datetime="2024-01-07T12:48:03.000Z" title="发表于 2024-01-07 20:48:03">2024-01-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 冰蒂斯</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>