<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>5-1 basic_master(上) | 冰蒂斯のformula</title><meta name="author" content="冰蒂斯"><meta name="copyright" content="冰蒂斯"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="5-1 AXI master前言： ​	本文档的内容来源于 zipcpu的博客：《Building a basic AXI Master》(https:&#x2F;&#x2F;zipcpu.com&#x2F;blog&#x2F;2020&#x2F;03&#x2F;23&#x2F;wbm2axisp.html)。本笔记是仅仅对该篇博客的解读和学习总结，所有的权益归原作者所有。 ​	为什么博客的第一篇文章是关于 AXI master，而不是关于 handshake 以及">
<meta property="og:type" content="article">
<meta property="og:title" content="5-1 basic_master(上)">
<meta property="og:url" content="http://example.com/2023/11/13/5-1-basic-master/index.html">
<meta property="og:site_name" content="冰蒂斯のformula">
<meta property="og:description" content="5-1 AXI master前言： ​	本文档的内容来源于 zipcpu的博客：《Building a basic AXI Master》(https:&#x2F;&#x2F;zipcpu.com&#x2F;blog&#x2F;2020&#x2F;03&#x2F;23&#x2F;wbm2axisp.html)。本笔记是仅仅对该篇博客的解读和学习总结，所有的权益归原作者所有。 ​	为什么博客的第一篇文章是关于 AXI master，而不是关于 handshake 以及">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/chainsaw_makima04.jpg">
<meta property="article:published_time" content="2023-11-13T03:43:53.000Z">
<meta property="article:modified_time" content="2023-11-28T09:03:55.296Z">
<meta property="article:author" content="冰蒂斯">
<meta property="article:tag" content="AXI">
<meta property="article:tag" content="master">
<meta property="article:tag" content="wishbone">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/chainsaw_makima04.jpg"><link rel="shortcut icon" href="/img/bloodborn_lib.png"><link rel="canonical" href="http://example.com/2023/11/13/5-1-basic-master/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '5-1 basic_master(上)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-28 17:03:55'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/reze.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="冰蒂斯のformula"><span class="site-name">冰蒂斯のformula</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">5-1 basic_master(上)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-13T03:43:53.000Z" title="发表于 2023-11-13 11:43:53">2023-11-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-28T09:03:55.296Z" title="更新于 2023-11-28 17:03:55">2023-11-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/AXI/">AXI</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/AXI/master/">master</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="5-1 basic_master(上)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="5-1-AXI-master"><a href="#5-1-AXI-master" class="headerlink" title="5-1 AXI master"></a>5-1 AXI master</h1><p>前言：</p>
<p>​	本文档的内容来源于 <code>zipcpu</code>的博客：《Building a basic AXI Master》(<a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2020/03/23/wbm2axisp.html)%E3%80%82%E6%9C%AC%E7%AC%94%E8%AE%B0%E6%98%AF%E4%BB%85%E4%BB%85%E5%AF%B9%E8%AF%A5%E7%AF%87%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%A7%A3%E8%AF%BB%E5%92%8C%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%8C%E6%89%80%E6%9C%89%E7%9A%84%E6%9D%83%E7%9B%8A%E5%BD%92%E5%8E%9F%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82">https://zipcpu.com/blog/2020/03/23/wbm2axisp.html)。本笔记是仅仅对该篇博客的解读和学习总结，所有的权益归原作者所有。</a></p>
<p>​	为什么博客的第一篇文章是关于 <code>AXI master</code>，而不是关于 <code>handshake </code>以及 <code>AXIslave</code>。因为后两者我已经较为熟练的掌握相关的信号时序约束，相关的笔记将会在后续逐步转移到该博客上。现在的目的是：进行 <code>master</code>的进一步学习。</p>
<p>​	本片博客可能会出现较多的文章嵌套。对于该问题，我将尽量在引用的文章中粗略阐述相关的信息，再给出其他文章的链接，以避免不断<strong>套娃阅读</strong>， 最后影响对主干问题的把握。</p>
<ul>
<li>文章1：<a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2021/06/28/master-examples.html">总文章集合</a></li>
<li>文章2：<a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2020/03/23/wbm2axisp.html">https://zipcpu.com/blog/2020/03/23/wbm2axisp.html</a></li>
<li>文章三：<a target="_blank" rel="noopener" href="https://zipcpu.com/zipcpu/2017/11/07/wb-formal.html">Wishbone</a></li>
</ul>
<h1 id="1-Classes-of-AXI-Masters"><a href="#1-Classes-of-AXI-Masters" class="headerlink" title="1. Classes of AXI Masters"></a>1. Classes of AXI Masters</h1><p>For the purpose of discussion, I’m going to divide AXI all master designs into one of four general categories or classes: <strong>single beat, single beat pipelined, bursting, and multichannel bursting</strong>. </p>
<img src="https://zipcpu.com/img/wbm2axisp/master-classes.svg" alt="img" style="zoom: 25%;" />



<h2 id="1-1-Single-beat"><a href="#1-1-Single-beat" class="headerlink" title="1.1 Single beat"></a>1.1 Single beat</h2><p>This mode do not need to keep track of how many transactions are outstanding at all.</p>
<p>(Fig 3. A single beat master only issues one request at a time)</p>
<img src="https://zipcpu.com/img/wbm2axisp/single-master-reads.svg" alt="img" style="zoom: 67%;" />

<p>Single beat的关键点 <code>key</code>是： that both <code>AWLEN</code> and <code>ARLEN</code> are held at zero.  这两个信号设置为0意味着，读、写通道的数据都是 1 Byte。</p>
<ul>
<li>1.<strong>无 Last信号</strong>：you can hold <code>WLAST</code> high and ignore <code>RLAST</code></li>
<li>2.<strong>无 burst，不需要考虑地址相关问题</strong>：<em>you don’t need to worry about the maximum burst length, whether or not your burst addresses are incrementing or not, or whether or not the burst will cross a 4kB boundary.</em></li>
</ul>
<p>这句话表示了<code>xLEN == 0</code>所具有的性质，目前解读还不是很全面：<em>Indeed, the <a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2018/03/10/induction-exercise.html">induction</a> property is quite simple: there’s either one burst outstanding on one of the two channels, or no bursts are outstanding at all.</em></p>
<h2 id="1-2-Single-beat-pipelined"><a href="#1-2-Single-beat-pipelined" class="headerlink" title="1.2 Single beat pipelined"></a>1.2 Single beat pipelined</h2><h3 id="1-guilty-of-xilinx"><a href="#1-guilty-of-xilinx" class="headerlink" title="1. guilty of xilinx"></a>1. guilty of xilinx</h3><p>我阅读过 AXI spec.pdf 的资料手册后，在信号时序那一部分，对 xilinx endor的建议记忆犹新： <code>keep *_ready signal high</code>。对于这个建议xilinx还给出了看起来很合理的建议说明。</p>
<p>不过这样的设计无法进行 <code>backpressure</code>的功能。xilinx demo在“骗人”。</p>
<p>设计 <em><strong>Single beat pipelined</strong></em> 的关键点在：<em>If you want performance, however, then you will need to issue multiple requests without waiting for their responses. This is the purpose of the single beat pipelined master.</em></p>
<h3 id="2-difference"><a href="#2-difference" class="headerlink" title="2. difference"></a>2. difference</h3><p>(Fig 5. Four single read beats from a pipelined master)</p>
<img src="https://zipcpu.com/img/wbm2axisp/single-pipelined-reads.svg" alt="img" style="zoom: 80%;" />



<blockquote>
<p>the difference between signle beat master and signle beat pipelind master</p>
</blockquote>
<ul>
<li><strong>the first difference</strong>: <em>you really need a state machine to handle issuing requests and a separate state machine to handle request responses.</em>   master不需要接收到 response信号才能发出下一个request，所以需要两个 state machine 。</li>
<li><strong>the second difference</strong>: <em>must maintain a counter of outstanding transactions and possibly even an internal FIFO to keep track of what needs to be done when the response returns.</em> &#x3D;&#x3D;对这句话的了解可能需要代码加深记忆&#x3D;&#x3D;</li>
</ul>
<h3 id="3-key-problem"><a href="#3-key-problem" class="headerlink" title="3. key &amp; problem"></a>3. key &amp; problem</h3><blockquote>
<p>One key</p>
<p>the <code>AWID</code> and <code>ARID</code> fields need to be held constant. This will make sure your responses get returned in order. 如果 ID 改变的话，有的数据处理速度快responese也快。可能首先给 ID—1 发送读请求，再给 ID—2发送读请求，结果可能是首先接收到 ID2的responese。</p>
</blockquote>
<blockquote>
<p>One biggest problem</p>
<p>need to look out for with any single beat pipelined master implementation is that the counter of outstanding transactions cannot be allowed to overflow. 这个问题后面&#x3D;&#x3D;结合代码在决定是否深入理解&#x3D;&#x3D;</p>
</blockquote>
<h2 id="1-3-Bursting-single-channel"><a href="#1-3-Bursting-single-channel" class="headerlink" title="1.3 Bursting, single channel"></a>1.3 Bursting, single channel</h2><p>这里又吐槽了 the fake AXI burst —— the single beat burst 。</p>
<blockquote>
<p>Single beat pipelined masters are awesome. They are the simplest masters that should be able to achieve the full speed of the bus. </p>
<p>The key word in that sentence is <strong>should</strong>.</p>
<p>Unfortunately, many AXI components are optimized around <em>burst</em> processing and perform dismally with single beat bursts.</p>
</blockquote>
<p>（Fig 6. Xilinx’s AXI Block RAM controller’s read performance）</p>
<p><img src="https://zipcpu.com/img/wbm2axisp/xilinx-bram-read-burst.png" alt="img"></p>
<p>上面的时序逻辑波形图我在 ipad goodnote进行过波形图划分，不过好像并没有分清这个逻辑。不过重点在作者下面的话：</p>
<blockquote>
<p><em>While this slave is able to handle one clock per beat of information, it can’t handle two bursts in short succession without taking some time to reset its internal logic. In this case, the core requires three clocks to reset and get ready for the next burst.</em>  虽然可以 one clock handle one beat，有个小问题，不能处理如下情况—— two burst in succession , can not handle successive burst !</p>
</blockquote>
<p>(Fig 7. Xilinx’s AXI Block RAM controller’s singleton read performance)</p>
<p><img src="https://zipcpu.com/img/wbm2axisp/xilinx-bram-read-singles.png" alt="img"></p>
<p>这个图是 master 连续向 slave 发出4个 signle request请求。但是表现却不让人满意。</p>
<blockquote>
<p>For every <code>ARVALID &amp; ARREADY</code>, the core requires three clock cycles before it will accept a new transaction. That’s then one transaction every four cycles, to yield a 25% throughput.</p>
</blockquote>
<h3 id="1-burst-ask-more"><a href="#1-burst-ask-more" class="headerlink" title="1. burst ask more"></a>1. burst ask more</h3><p>burst 发送比 single beat发送的直观吞吐量更高，但是在功能上能够容纳 burst，那么在设计上也需要更高的要求：<em>不仅需要记录有多少 burst outstanding ， 还要记录每次burst的 beats outstanding。</em></p>
<blockquote>
<p>The most obvious change is simply that you’ll now need to keep track of both the number of beats outstanding as well as the number bursts outstanding. The master will also need to carefully make certain that <code>WLAST</code> is properly set on the last beat of every write burst.</p>
</blockquote>
<h3 id="2-challenging-changes"><a href="#2-challenging-changes" class="headerlink" title="2. challenging changes"></a>2. challenging changes</h3><ul>
<li>burst length limitation：</li>
</ul>
<blockquote>
<p>Bursts to or from a fixed address can be no longer than 16 beats in length. This applies to wrapped addressing as well. If the address increments, however, bursts of 256 beats are allowed.</p>
<p>对于一个固定地址的burst，或者对于 cache的 addressing，长度不能超过16 beats。对于 address increments 不能超过 256 beats。</p>
</blockquote>
<ul>
<li>Bursts are not allowed to cross 4kB boundaries. (知道规则，但不知道具体的使用方法)</li>
</ul>
<p>文章中在这里给了较多用于仿真的代码，但是目前还为对这些代码进行深入了解和仿真。</p>
<h2 id="1-4-Bursting-multiple-channel"><a href="#1-4-Bursting-multiple-channel" class="headerlink" title="1.4 Bursting, multiple channel"></a>1.4 Bursting, multiple channel</h2><ul>
<li>第四中发送方式最大的区别：</li>
</ul>
<blockquote>
<p>They key difference between constant  AXI  ID’s and varying  AXI ID’s is that  AXI only guarantees that returned responses will be in order when those responses have the same ID. In other words, if you use multiple IDs, you’ll never know which ID of the many transactions IDs you may have outstanding will be the next one returned.</p>
</blockquote>
<ul>
<li>后面作者会展示一个他的个人设计：</li>
</ul>
<blockquote>
<p>At one time I had a nice example of a bursting, multiple channel master.</p>
<p>I’ve since torn this master apart and replaced it with an implementation of the simpler bursting master logic that we’ll discuss the implementation of below.</p>
</blockquote>
<ul>
<li>the reason why the author tear the implement up ?</li>
</ul>
<blockquote>
<ul>
<li>First, it was very difficult to verify that it worked. Yes, it worked in practice for about two years or so, but I couldn’t really <em>verify</em> that it would always work. </li>
<li>Second, the reorder buffer slowed it down by adding an additional clock or two of latency to the logic.</li>
</ul>
</blockquote>
<ul>
<li>作者展示的设计不适合作为一个 multiple channel ID 的教程</li>
</ul>
<blockquote>
<p>my <a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2019/07/17/crossbar.html">AXI crossbar core</a>. Sadly, that’s not really a very useful master to use as an example of how to build a bursting multiple channel AXI master. Worse, from an example point of view, my crossbar implementation  doesn’t exploit the ID’s to its advantage at all. </p>
</blockquote>
<ul>
<li>single master access multiple slaves</li>
</ul>
<p>虽然作者之前展示的代码无法作为一个很好的相关入门参考，但是作者关上了一扇门，又给我打开了一扇窗。</p>
<blockquote>
<p>&#x3D;&#x3D;Where multiple channel AXI masters really start to shine is if a single master needs to access multiple slaves.&#x3D;&#x3D;</p>
<p>记住这个话，单master对多slave十分有意义。多mastr对多slave会复杂！</p>
</blockquote>
<h3 id="1-one-connection-without-ID"><a href="#1-one-connection-without-ID" class="headerlink" title="1. one connection without ID"></a>1. one connection without ID</h3><p>只允许一个master与一个salve在同一时刻进行信息互通！</p>
<blockquote>
<p>In such an interconnect, a master might issue two requests: one for slave 1, and then a second one for slave 2.</p>
<p>The interconnect that doesn’t support ID’s must first route the request to slave 1 <em>and then wait for the response</em> from slave 1 before routing the second request to slave number 2;</p>
</blockquote>
<p>（Fig 9. Interconnect only allows one connection between master and slave at a time）</p>
<img src="https://zipcpu.com/img/wbm2axisp/single-intercon.svg" alt="img" style="zoom: 67%;" />



<p>&#x3D;&#x3D;该种连接方式表现如下：&#x3D;&#x3D;</p>
<blockquote>
<p>If the first slave takes a long time, the second request will be stuck behind that first one until that reply comes back. In the example shown in Fig. 9 above, the first slave takes four clocks to return. This keeps the interconnect  from routing the second packet to the second slave until this first response returns. The second packet, therefore, suffers from a delay of seven clock cycles, when a single clock cycle delay might have been possible.</p>
</blockquote>
<h3 id="2-connection-with-ID"><a href="#2-connection-with-ID" class="headerlink" title="2. connection with ID"></a>2. connection with ID</h3><p>&#x3D;&#x3D;时序表现如下：&#x3D;&#x3D;</p>
<blockquote>
<p>On the other hand, if the interconnect, were to provide full ID support, it should route the first request to slave 1, and then route the second request to slave 2 even before slave 1 responds.</p>
</blockquote>
<p>(Fig 10. Interconnect allows one connection between any given master,ID pair and slave at a time)</p>
<img src="https://zipcpu.com/img/wbm2axisp/multid-intercon.svg" alt="img" style="zoom:67%;" />

<p>&#x3D;&#x3D;会出现的问题：&#x3D;&#x3D;</p>
<blockquote>
<p>Unfortunately, while this looks faster in our figure above, the complexity of the operation coupled with the desire for high clock speeds makes it so that this form of interconnect , isn’t necessarily faster at all.</p>
</blockquote>
<p>为什么理论上更快的设计会反而会出现低效率？因为会出现以下的问题：</p>
<blockquote>
<p>For example, the interconnect, must now make certain that </p>
<ul>
<li>it keeps track of outstanding requests of every &lt;master,ID&gt; combination, rather than one counter per master.</li>
<li>It needs to know to what slave such &lt;master,ID&gt; pairs are assigned to, as well as the number of outstanding transactions assigned to that slave. </li>
<li>This counter is required to prevent a request from the same &lt;master,ID&gt; from being sent to a subsequent slave and returning before the first slave’s response returns. This means it needs <code>2^&#123;IDW&#125;*(num masters)</code> counters, which might each need to be updated on every cycle.</li>
</ul>
</blockquote>
<p>上面的话可能一时间难以理解，简单翻译：</p>
<blockquote>
<ul>
<li>首先，互连需要跟踪每个&lt;主机，ID&gt;组合的未完成请求，而不是每个主机的一个计数器。这意味着互连需要知道每个请求来自哪个主机，并且这个主机的请求还没有完成。</li>
<li>其次，互连需要知道这些&lt;主机，ID&gt;对被分配给哪个从机，以及分配给该从机的未完成事务的数量。这是因为互连需要确保同一个&lt;主机，ID&gt;的请求不会在第一个从机的响应返回之前被发送到后续的从机。</li>
<li>最后，这就意味着互连需要<code>2^&#123;IDW&#125;*(num masters)</code>个计数器，这些计数器可能需要在每个周期上都更新。这是一个相当大的开销，因为每个计数器都需要在每个周期上进行更新。</li>
</ul>
</blockquote>
<p>&#x3D;&#x3D;翻译之后呢，还是难以理解对吧。那就暂时条过他，不需要在这些地方浪费时间，只需要做3点即可&#x3D;&#x3D;：</p>
<ul>
<li>&#x3D;&#x3D;1.忘记上面所有的原文和翻译，不要尝试花费过多的时间去理解，这不是我们的主要任务(其实这一部分只是引出multiple概念并且对比)；&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;2.记住一点：这种情况的开销也很大；&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;3.记住之前的话：<em>Where multiple channel AXI masters really start to shine is if a single master needs to access multipl</em>&#x3D;&#x3D;</li>
</ul>
<h3 id="3-single-vs-multichannel-masters"><a href="#3-single-vs-multichannel-masters" class="headerlink" title="3.  single vs multichannel masters"></a>3.  single vs multichannel masters</h3><p>(Fig 11. Comparing the advantages and disadvantages of using multiple AXI IDs)</p>
<p><img src="https://zipcpu.com/img/wbm2axisp/multichannel.svg" alt="img"></p>
<ul>
<li>&#x3D;&#x3D;是不是太多了，记不住？有没有很好的例子方便记忆，或者加深理解？&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;有！&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;一句话梳理上面的区别和优势，准备好了吗？&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;有的时候 multiple cahnnels 并不比single channel有优势，对于初学者来说尤其如此！&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;结束！&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;还以为自己是高中生呢，什么东西都要弄得一清二楚？&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;你需要：<font color="red">抓住主干问题，忽略次要！因为你的时间和经历都是由局限性的，运用好你的时间！</font>&#x3D;&#x3D;</li>
</ul>
<h1 id="2-single-beat-pipelined-AXI-master"><a href="#2-single-beat-pipelined-AXI-master" class="headerlink" title="2. single beat,pipelined AXI master"></a>2. single beat,pipelined AXI master</h1><h2 id="2-1-the-situation-you-can’t-use-AXI-protocol"><a href="#2-1-the-situation-you-can’t-use-AXI-protocol" class="headerlink" title="2.1 the situation you can’t use AXI protocol"></a>2.1 the situation you can’t use AXI protocol</h2><p>前段内容都是对哪些实例不能使用 axi 协议进行阐述，作者制作的一张表格已经可以很好的表述了。</p>
<img src="https://zipcpu.com/img/wbm2axisp/no-burst-reasons.svg" alt="img" style="zoom: 33%;" />

<blockquote>
<p>作者在这里体积到一点： 对于 xilinx 的 DDR相关读写可以使用 MIG IP达到近乎 100%的吞吐量，但是对于 RAM的读写 ，xilinx的 control IP似乎不能进行100%吞吐量读写。</p>
</blockquote>
<h2 id="2-2-the-roughly-introduction"><a href="#2-2-the-roughly-introduction" class="headerlink" title="2.2  the roughly introduction"></a>2.2  the roughly introduction</h2><p>小结前言：</p>
<p>本章节对将 <code>wishbone</code>与 <code>AXI</code>通过 <code>wishbone2AXI bridge</code>进行连接。通过<em>bridge</em>构建<em>axi master</em>其中对 <code>wishbone</code>的描述相对粗略，作者给出了该 <em>bus</em> 较为详细的 <em>formal verification method</em>。暂时不建议进行 <strong>套娃阅读</strong>。</p>
<blockquote>
<p>链接是： <a target="_blank" rel="noopener" href="https://zipcpu.com/zipcpu/2017/11/07/wb-formal.html">Building Formal Assumptions to Describe Wishbone Behaviour (zipcpu.com)</a></p>
</blockquote>
<ul>
<li><em>wishbone</em>只允许单个请求，只读or只写，这一点与支持多通道独立的 <em>axi protocol</em>完全不同。所以要求：</li>
</ul>
<blockquote>
<p>In order to make certain we maintain the correct ordering between read and write responses, this core will only ever accept read requests or write requests. Further, all requests will be flushed before switching between the two.</p>
</blockquote>
<ul>
<li>Abort problem ：作者的 <em>wishbone</em> 支持总线的 abort，但是 <em>axi</em> 明显不支持，<em>axi</em> 协议要求每一个<em>request</em>都要有一个相应的<em>respoonse</em>。这会造成一个问题，作者使用 <em>axi dma</em> 描述该问题：对于 <em>axi dma</em> 看，如果相应的 <em>slave</em> 出现<em>broken</em> 的情况，无法返回得到 <em>request</em> 相应的 <em>respones</em>，这个时候 <em>dma</em> 作为master 会一直处于 <strong>hang</strong>状态。这种情况的可能性说明：设计一个功能能够似的 <em>axi‘ bus reset</em> 是十分重要的。</li>
</ul>
<blockquote>
<ul>
<li>My own Wishbone implementations allow a bus(computing)) abort. By this, I mean that if a Wishbone master wants to abort all outstanding transactions, it can do this by just dropping the cycle line for one clock cycle. After that, all pending acknowledgments need to be suppressed.</li>
<li>Unfortunately, AXI offers no similar capability. This is the reason why so many individuals have struggled to <a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2020/03/14/axi-reset.html">reset AXI DMA cores</a>: if your <a target="_blank" rel="noopener" href="https://zipcpu.com/formal/2019/05/13/axifull.html">AXI slave is broken</a>, the DMA might hang. However, <a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2020/03/14/axi-reset.html">you can’t reset the DMA while a transaction is outstanding</a>–no matter what the DMA instructions might tell you. AXI <em>requires</em> one bus(computing)) response for every bus(computing)) request.</li>
<li>This will mean that we need to <a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2020/03/14/axi-reset.html">keep track of the number of outstanding AXI responses</a>, in case the Wishbone master ever wish to abort an outstanding transaction, and so keep subsequent responses from producing Wishbone acknowledgments.</li>
</ul>
</blockquote>
<p>两个参考链接：<a target="_blank" rel="noopener" href="https://zipcpu.com/zipcpu/2017/11/07/wb-formal.html">Building Formal Assumptions to Describe Wishbone Behaviour (zipcpu.com)</a>、<a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2020/03/14/axi-reset.html">Locally resetting an AXI component (zipcpu.com)</a></p>
<ul>
<li>对于<em>cpu</em> 和 <em>dma</em> 来说，如何处理 <em>bus err situation</em>？</li>
</ul>
<blockquote>
<p>In many ways, this just makes sense. What should a CPU do on a bus error? In general, the “right” answer is to halt the program at the first bus error return. What should a DMA do on a bus error? It should halt the transfer as soon as possible on the first erroneous return.</p>
</blockquote>
<p>（Fig 13. Lesson learned: Halt on a bus error）</p>
<img src="https://zipcpu.com/img/wbm2axisp/halt-on-error.svg" alt="img" style="zoom: 33%;" />



<ul>
<li>什么？还有一个关于 <em>axi bridge</em> 的逻辑功能要求？</li>
</ul>
<blockquote>
<p>这并不是该文章的主干内容，也不是本次学习计划的主干。 please just ignore it。</p>
<p>好吧好吧，也许他很重要，我们也许过段时间需要重新回来看他。但是这不是我们当前的主要内容，我希望你在后面的阅读和学习中能不断加深这种认识。相信我，这没坏处，相反能节省你更多的时间。</p>
</blockquote>
<h2 id="2-3-implement"><a href="#2-3-implement" class="headerlink" title="2.3 implement"></a>2.3 implement</h2><p>小结前言：</p>
<p>在上面的小结中，作者提及到该 <em>bridge</em> 内容的实现需要更多额外的考虑和设计。如果不考虑上面的内容，一个 <em>wb2axi</em> 的设计会简单许多。下面将通过代码的实例展示— <em>a simple bridge</em>：</p>
<h3 id="1-wb-stall-signal"><a href="#1-wb-stall-signal" class="headerlink" title="1. wb_stall signal"></a>1. wb_stall signal</h3><p>作者使用了一个组合逻辑来实现相应的功能，相应的握手规则处理在后面的<em>slave</em> 相关章节我会比较详细的讲解。可能其他读者对此较为疑惑，建议额外花时间学习 <code>handshake</code>的握手规则。</p>
<blockquote>
<ol>
<li>Set the WB stall signal so that we’ll stall if any request is waiting to be sent forwards. This is perhaps the most complex part, since there are many reasons why we might need to stall the upstream bus. Let’s walk through each of them.</li>
</ol>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">       <span class="comment">// wb bus is one direction , sometimes we should stall the upstream</span></span><br><span class="line">	o_wb_stall = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>下面的情况都设计一种握手时许逻辑： <code>valid before ready</code>。</p>
<p>First, we might stall if ever the AW channel is stalled. </p>
<p>如果 <em>axi-lite</em> 总线中的 <em>aw channel</em>发生了 <em>valid before ready</em> 情况，需要 <em>stall</em> 上游的 <em>wb</em> 信号传输。 </p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (o_axi_awvalid &amp;&amp; !i_axi_awready)</span><br><span class="line">	o_wb_stall = <span class="number">1&#x27;b1</span>;</span><br></pre></td></tr></table></figure>

<p>We might also need to stall for essentially the same reason if the write data channel is stalled.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (o_axi_wvalid &amp;&amp; !i_axi_wready)</span><br><span class="line">	o_wb_stall = <span class="number">1&#x27;b1</span>;</span><br></pre></td></tr></table></figure>

<p>The same applies to the read address channel.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (o_axi_arvalid &amp;&amp; !i_axi_arready)</span><br><span class="line">	o_wb_stall = <span class="number">1&#x27;b1</span>;</span><br></pre></td></tr></table></figure>

<p>上面的三段代码不过是<code>AW W AR</code>三个通道的简单 <code>valid before ready</code>简单处理，下面会增添额外的功能设计。</p>
<p>在之前的章节中提及到： <code>wishbone</code>不能进行双通道的读写，每次只能 <code>read or write</code>。所以在每次改变传输方向之前，会对<em>bus</em>进行下面的操作。 </p>
<blockquote>
<p>Specifically, if we are waiting on read (or write) returns and we now want to reverse the direction of the bus, then we need to stall until the system is flushed enough that we can reverse the bus direction.</p>
</blockquote>
<p>下面 show two situations that will stall the bus:</p>
<blockquote>
<ul>
<li>Remember, we’ve chosen the approach that we’ll only ever go in one direction at a time, and we’ll flush the design before switching directions.</li>
</ul>
<p>如果现在是能的方向和 <em>bus</em>中方向不对应，总线中的数据不是 <code>empty</code>（总线传输中还有数据存在），那么拉高 <code>stall</code>信号。</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// i_wb_we != direction ， means operation direction change</span></span><br><span class="line"><span class="keyword">if</span> ((i_wb_we != direction)&amp;&amp;(!empty))</span><br><span class="line">		o_wb_stall = <span class="number">1&#x27;b1</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>if we are in the process of flushing all <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> returns following a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> abort, or if our counter is about ready to overflow, then we’ll need to stall the incoming <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> as well.</li>
</ul>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span> (flushing || nearfull)</span><br><span class="line">		o_wb_stall = <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h3 id="2-If-i-wb-stb-i-wb-we"><a href="#2-If-i-wb-stb-i-wb-we" class="headerlink" title="2. If (i_wb_stb &amp;&amp; i_wb_we)"></a>2. If <code>(i_wb_stb &amp;&amp; i_wb_we)</code></h3><p>如果在 <code>wishbone</code>中发出 <code>request</code>请求，这个时候 <code>wishbone</code>的写使能和写数据同时有效，对于 <em>axi</em> 信号应该怎么处理？</p>
<blockquote>
<p>On any Wishbone. write request, where <code>i_wb_stb &amp;&amp; i_wb_we</code>, set <code>AWVALID</code>, <code>WVALID</code> <code>AWADDR</code>, and <code>WDATA</code>.</p>
</blockquote>
<blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">	<span class="keyword">if</span> (i_reset)</span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		<span class="comment">// Always clear any handshaking signals on reset.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		o_axi_awvalid &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">		o_axi_wvalid &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (i_wb_we &amp;&amp; i_wb_stb &amp;&amp; !o_wb_stall)</span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		<span class="comment">// On any new write request, set both AWVALID and AWREADY</span></span><br><span class="line">		o_axi_awvalid &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">		o_axi_wvalid  &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br></pre></td></tr></table></figure>

<p>Once each of these gets accepted, we’ll clear it to prepare for the next transaction.</p>
<p>虽然 <code>aw_valid</code>和<code>w_valid信号</code>都是同时设置为高电平，但是两个通道可以在接受到各自的 <code>ready</code>信号后进行拉低。（不由自主的想到了xilinx demo design中的 ready信号设计，也和这个一样一高一低，总吞吐量最大只能保存在 <code>50%</code>）</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//		the combinatorical logic of when design will stall</span></span><br><span class="line"><span class="comment">//		code above :</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//		if (o_axi_awvalid &amp;&amp; !i_axi_awready)</span></span><br><span class="line"><span class="comment">//			o_wb_stall = 1&#x27;b1;</span></span><br><span class="line"><span class="comment">//		if (o_axi_wvalid &amp;&amp; !i_axi_wready)</span></span><br><span class="line"><span class="comment">//			o_wb_stall = 1&#x27;b1;</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (i_axi_awready)</span><br><span class="line">			o_axi_awvalid &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">if</span> (i_axi_wready)</span><br><span class="line">			o_axi_wvalid &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>这种结构作者称其为 <code>a cascaded if structure like this</code>。</p>
<blockquote>
<p>In this case, <code>o_wb_stall</code> will keep us from setting both <code>AWVALID</code> and <code>WVALID</code> if ever one of the two is still stalled from a prior request. Otherwise, it would preempt the clearing of one of the two, and so it allows us to send multiple requests on consecutive clock cycles.</p>
<p>在该种模式处理方法中， <code>o_wb_stall</code>信号防止：在只有一个通道被接收的时候，同时设置两个通道的<code>valid</code>信号。该种设计方法在一个通道 <code>stall</code>的时候，拉低另一个已经被接受通道的 <code>valid</code>，以免误传数据。</p>
</blockquote>
<h3 id="3-handle-“AW-W-channel”"><a href="#3-handle-“AW-W-channel”" class="headerlink" title="3.handle “AW &amp; W  channel”"></a>3.handle “AW &amp; W  channel”</h3><blockquote>
<p>While you might reset any data associated with a request as well, it’s not necessary to do so. In an effort to keep our logic low (减少需要的LUT逻辑资源), we’ll set both <code>WDATA</code> and <code>WSTRB</code> above any time the channel isn’t stalled.</p>
</blockquote>
<p>以 <code>W cahnnel</code>通道进行举例，非 <code>valid before ready</code>的情况都将 <code>strb</code>和 <code>data</code>的两个信号向 <code>axi</code>进行传输。代码表现：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (!o_axi_wvalid || i_axi_wready)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	o_axi_wdata &lt;= i_wb_data;</span><br><span class="line">	o_axi_wstrb &lt;= i_wb_sel;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>上面并不是最低功耗的方法，如果想要见小功耗，需要减少 <code>trasition</code>的数量，可以使用 <code>与逻辑</code>实现。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (i_wb_stb &amp;&amp; i_wb_we &amp;&amp; !o_wb_stall)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	o_axi_wdata &lt;= i_wb_data;</span><br><span class="line">	o_axi_wstrb &lt;= i_wb_sel;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Q: why chose to gate these values on <code>(!o_axi_wvalid || i_axi_wready)</code> instead.</p>
<p>A: in this case it just makes timing more difficult. Remember, for example, that <code>o_wb_stall</code> had a rather large computational burden on it already.</p>
<ul>
<li>当 <code>i_wb_stb</code> 和 <code>i_wb_we</code> 为真，<code>o_wb_stall</code> 为假时进行的。这意味着，只有在这些条件满足的情况下，数据才会被写入。然而，这种设计可能会增加时序压力，因为它需要在一个时钟周期内完成所有的操作。</li>
<li><code>o_wb_stall</code> 已经有相当大的计算负担了。如果我们在每个时钟周期都检查这些条件，就会增加额外的计算负担，从而使时序更加困难。</li>
<li>只有当 <code>o_axi_wvalid</code> 为假或 <code>i_axi_wready</code> 为真时，数据才会被写入，这可以减轻计算负担，提高时序性能。</li>
</ul>
</blockquote>
<p>在处理 <code>AW channel</code>上可能会有较多的困难。两个总线基于的位宽是不同的，所以需要做一定的处理。</p>
<blockquote>
<p>Setting <code>AWADDR</code> is a touch more difficult, simply because Wishbone is word addressed whereas AXI is byte addressed. Hence, we’ll need to take the Wishbone address and append some number of zeros to it.</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">localparam</span>	DW = <span class="number">32</span>; <span class="comment">// Wishbone data width</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// wb address is bus_data_width based , should know the low bits</span></span><br><span class="line"><span class="comment">// of the address should be aligned</span></span><br><span class="line"><span class="keyword">wire</span>	[<span class="built_in">$clog2</span>(WB_DATA_WIDTH)-<span class="number">4</span>:<span class="number">0</span>]	axi_lsbs = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (!o_axi_awvalid || i_axi_awready)</span><br><span class="line">     	<span class="comment">// convert wb bus_width based address to byte based address</span></span><br><span class="line">	o_axi_awaddr &lt;= &#123; m_addr, axi_lsbs &#125;;</span><br></pre></td></tr></table></figure>

<p>AW 通道的写操作和 W 通道相同，不过在位宽上增加了逻辑资源。</p>
<blockquote>
<p>Note that this also follows the same logical structure that <code>WDATA</code> followed above: <strong>the address gets updated if ever the channel isn’t stalled. As before, a lower power approach exists, but I’ve chosen to go with the lower logic approach here.</strong></p>
</blockquote>
<h3 id="4-The-advantage-above"><a href="#4-The-advantage-above" class="headerlink" title="4. The advantage above"></a>4. The advantage above</h3><p>该种设计可以满足如下的需求：</p>
<blockquote>
<p>Let me pause here for a moment to note that this is the structure your logic will need–even if you are building a pipelined master for a different purpose. Surprisingly, this write logic structure doesn’t change much from one design to the next. </p>
<ul>
<li><ol>
<li>You always want to reset any <code>*VALID</code> signals.</li>
</ol>
</li>
<li><ol start="2">
<li>You’ll always want to set both <code>AWVALID</code> and <code>WVALID</code> together on any new write request (even if the spec doesn’t require that they be synchronized).</li>
</ol>
</li>
<li><ol start="3">
<li>Once the the appropriate <code>*READY</code> line has been raised, you’ll want to clear each of <code>AWVALID</code> and <code>WVALID</code> individually.</li>
</ol>
</li>
<li><ol start="4">
<li>Don’t start a new request until both would otherwise be clear on the next cycle.</li>
</ol>
</li>
</ul>
</blockquote>
<p>并不是所有的设计都需要写数据和写地址进行同步，但是如果发送方不尽兴相关的同步处理，那么在接收方会花费较多的时间进行同步行为。</p>
<blockquote>
<p>Not all designs keep the write address and write data channels synchronized. I find that it’s easier to verify the designs if the two channels are synchronized, so we’ll force them to be synchronized here by not initiating any new transactions until both signals from the last transaction have been accepted. </p>
<p>Further, as I’ve learned from my new <a target="_blank" rel="noopener" href="https://github.com/ZipCPU/axidmacheck">DMA testbed project</a> shown in Fig. 8 above, if you don’t keep the two write channels synchronized, then the entire write operation will be slowed down every time a slave needs to synchronize them.</p>
</blockquote>
<h3 id="5-handle-“AR-channel”"><a href="#5-handle-“AR-channel”" class="headerlink" title="5.handle “AR channel”"></a>5.handle “AR channel”</h3><p>处理 <code>read channel</code> 和 <code>write channel</code>有异曲同工之处，但也有稍许不同。</p>
<blockquote>
<ul>
<li><strong>same</strong>: Read requests are similar. On any read request, where <code>i_wb_stb &amp;&amp; !i_wb_we</code>, set <code>ARVALID</code> and <code>ARADDR</code>.</li>
<li><strong>difference</strong>: Setting <code>ARADDR</code> is identical to what we did before with <code>AWADDR</code>, but <code>ARVALID</code> is just a touch different simply because we don’t have two channels that need synchronization.</li>
</ul>
</blockquote>
<p>The code is :</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">	<span class="keyword">if</span> (i_reset)</span><br><span class="line">		<span class="comment">// Clear on any reset</span></span><br><span class="line">		o_axi_arvalid &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (i_wb_stb &amp;&amp; !i_wb_we &amp;&amp; !o_wb_stall)</span><br><span class="line">		<span class="comment">// Set on any request</span></span><br><span class="line">		o_axi_arvalid &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (i_axi_arready)</span><br><span class="line">		<span class="comment">// Clear once the request is accepted</span></span><br><span class="line">		o_axi_arvalid &lt;= <span class="number">1&#x27;b0</span>;</span><br></pre></td></tr></table></figure>

<p>这种 <code>valid信号</code>拉高又拉低的处理方式，和 <code>xilinx</code>建议的 <code>ready</code>信号处理方式相同，不过实现的时序逻辑可能不尽相同。需要注意这段代码可能出现的时序信号错误的可能性。</p>
<h3 id="6-handle-“R-channel”"><a href="#6-handle-“R-channel”" class="headerlink" title="6.handle “R channel”"></a>6.handle “R channel”</h3><blockquote>
<p>As long as the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> widths are the same, we can just return the read values.</p>
</blockquote>
<p>如果两个总线的位宽位宽不一致，这个会比较复杂，后续的文章内容会解决这个问题。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line">	o_wb_data &lt;= i_axi_rdata;</span><br></pre></td></tr></table></figure>



<h3 id="7-no-ability-to-stall-any-returns"><a href="#7-no-ability-to-stall-any-returns" class="headerlink" title="7. no ability to stall any returns"></a>7. no ability to stall any returns</h3><p>将 <em>axi</em> 的返回信号转换为 <em>wb</em> 返回信号需要先了解下面两点：</p>
<ul>
<li><em>axi</em> 信号中只有一个 <em>return signal</em>，该信号宽度是 <code>2 bits</code>，一共有四种信号的返回类型。而 <em>wishbone</em> 有两个返回信号 <code>return signals </code>。</li>
<li><em>axi</em> 信号的 <code>high bit==1&#39;b1</code>意味着这里存在一个 <code>err</code>，若该信号为低电平，意味着 <code>ack signal</code>。</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span>	o_wb_ack = !flushing &amp;&amp; ((i_axi_bvalid &amp;&amp; !i_axi_bresp[<span class="number">1</span>])</span><br><span class="line">			||(i_axi_rvalid &amp;&amp; !i_axi_rresp[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span>	o_wb_err = !flushing &amp;&amp; ((i_axi_bvalid &amp;&amp; i_axi_bresp[<span class="number">1</span>])</span><br><span class="line">			||(i_axi_rvalid &amp;&amp; i_axi_rresp[<span class="number">1</span>]));</span><br></pre></td></tr></table></figure>

<p>在这个问题的处理方式上，涉及到了 <code>reset AXI BUS</code>，现在不需要立刻弄清楚里面的逻辑和道理，继续前进。</p>
<blockquote>
<p>The big difference here from what might otherwise be a simple return is this <code>flushing</code> signal. I use this signal as part of the <a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2020/03/14/axi-reset.html">core’s reset logic</a>. If we are ever <code>flushing</code> the pipeline, then we want to <a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2020/03/14/axi-reset.html">ignore any and all acknowledgments as we return back to an idle state</a>.</p>
</blockquote>
<h3 id="8-wb-ready-signal"><a href="#8-wb-ready-signal" class="headerlink" title="8. wb ready_signal"></a>8. wb ready_signal</h3><blockquote>
<p>Wb bus has no ability to stall the return acknowledgment, we can also hold the respective backpressure signals high. </p>
</blockquote>
<p>没有办法拒绝，那就只有接受。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span>	o_axi_bready = <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">assign</span>	o_axi_rready = <span class="number">1&#x27;b1</span>;</span><br></pre></td></tr></table></figure>

<p>作者建议将所有设计的 <code>master</code>模块的 <code>ready</code>信号都设置为<code>high</code>，这样不需要在 <code>interconnect</code>模块中加入额外的 <code>skidbuffer</code>模块。</p>
<blockquote>
<p>That said, I haven’t consistently held these values high within my own designs. While my <a target="_blank" rel="noopener" href="https://zipcpu.com/doc/axi-spec.pdf">AXI</a> <a target="_blank" rel="noopener" href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">S2MM</a> and <a target="_blank" rel="noopener" href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/aximm2s.v">MM2S</a> cores do hold these high, my <a target="_blank" rel="noopener" href="https://github.com/ZipCPU/dbgbus/blob/master/hexbus/rtl/hbexecaxi.v">AXI-lite debugging bus master</a> captures state information within these two ready signals so adjusting the logic so as to hold these signals high would require some rework.</p>
<p>这些话我也目前不知道，等待后续更新更多的细节。</p>
</blockquote>
<h2 id="2-4-Last-the-ugly-counter"><a href="#2-4-Last-the-ugly-counter" class="headerlink" title="2.4 Last: the ugly counter"></a>2.4 Last: the ugly counter</h2><p>这一部分单独放在一个小章节中叙述。</p>
<h3 id="1-the-counter-for"><a href="#1-the-counter-for" class="headerlink" title="1. the counter for"></a>1. the counter for</h3><blockquote>
<p>There’s one ugly trick remaining, and that is counting the number of transaction returns we are expecting so that we can </p>
<ul>
<li><ol>
<li><a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2020/03/14/axi-reset.html">flush the channel</a> on any error or bus abort,;</li>
</ol>
</li>
<li><ol start="2">
<li>know that the channel is clear in order to change direction.</li>
</ol>
</li>
</ul>
</blockquote>
<blockquote>
<p>The reason why this is ugly is that any time you place a counter within your design, a counter that should never overflow, then you also need to place a check within your design to make certain that the counter truly never overflows. Don’t forget this check!</p>
</blockquote>
<h3 id="2-baisc-counter"><a href="#2-baisc-counter" class="headerlink" title="2. baisc counter"></a>2. baisc counter</h3><p><code>basic counter</code> 如何实现：</p>
<blockquote>
<ul>
<li>count up any time <code>o_wb_stb &amp;&amp; !o_wb_stall</code>;<ul>
<li>这个信号为高意味着：信号接收</li>
</ul>
</li>
<li>count down any time <code>BVALID || RVALID</code>.<ul>
<li>信号为高意味着：过来了有效信号，需要被接收</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">	<span class="keyword">if</span> (i_reset)</span><br><span class="line">		npending &lt;= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">case</span>(&#123; (o_wb_stb &amp;&amp; !o_wb_stall), (i_axi_bvalid || i_axi_rvalid)&#125;)</span><br><span class="line">	<span class="number">2&#x27;b01</span>: npending &lt;= npending + <span class="number">1</span>;   <span class="comment">//来了信号，却不接收</span></span><br><span class="line">	<span class="number">2&#x27;b10</span>: npending &lt;= npending - <span class="number">1</span>;   <span class="comment">//不来信号，但是接收</span></span><br><span class="line">	<span class="keyword">endcase</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">assign</span>	empty = (npending == <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">assign</span>	full == (npending == (<span class="number">1</span>&lt;&lt;LGFIFO));</span><br><span class="line">	<span class="keyword">assign</span>	nearfull == (npending == (<span class="number">1</span>&lt;&lt;LGFIFO))-<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在后续的过程中，会将 <code>assign</code>的 <code>wire</code>信号使用 <code>register</code>进行寄存，不会加重时序压力。</p>
<h3 id="3-keep-track-of-direction"><a href="#3-keep-track-of-direction" class="headerlink" title="3. keep track of direction"></a>3. keep track of direction</h3><blockquote>
<p>Once we know when there are no requests outstanding, we can then keep track of direction. Specifically, we can change direction any time there’s nothing pending.</p>
<p>当bus中的trasaction为0的时候，接可以进行read or write的方向改变。</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (empty)</span><br><span class="line">	direction &lt;= i_wb_we;</span><br></pre></td></tr></table></figure>



<p>这里需要引入一个问题：when do we need to flush the bus pipeline of any pending requests? 什么时候需要清空具有被阻塞的请求信号的流水线bus？</p>
<ul>
<li>在这里，<code>flushing</code>变量用于表示是否需要清空（flush）流水线。初始化<code>flushing</code>为0，表示默认情况下不需要清空流水线。</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	flushing = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (i_reset)</span><br><span class="line">	flushing &lt;= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果接收到有效的读响应<code>i_axi_rvalid</code>并且响应错误<code>i_axi_rresp[1]</code>，或者接收到有效的写响应<code>i_axi_bvalid</code>并且响应错误<code>i_axi_bresp[1]</code>，则将<code>flushing</code>设置为1。</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((i_axi_rvalid &amp;&amp; i_axi_rresp[<span class="number">1</span>])</span><br><span class="line">	||(i_axi_bvalid &amp;&amp; i_axi_bresp[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<ul>
<li>如果主设备在请求待处理时放下周期线<code>i_wb_cyc</code>，并且流水线不为空<code>!empty</code>，我们也会希望清空正在进行的操作。在这种情况下，也将<code>flushing</code>设置为1。**<font color="orange">目前的操作尚不清楚</font>**</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">||(!i_wb_cyc &amp;&amp; !empty))</span><br><span class="line">flushing &lt;= <span class="number">1&#x27;b1</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>一旦流水线被清空并且没有更多的未完成事务，我们就可以返回到处理传入请求。</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (empty)</span><br><span class="line">	flushing &lt;= <span class="number">1&#x27;b0</span>;</span><br></pre></td></tr></table></figure>



<h2 id="2-5-conclusion"><a href="#2-5-conclusion" class="headerlink" title="2.5 conclusion"></a>2.5 conclusion</h2><blockquote>
<p><font color="red">Notice also that setting the the <code>Ax*</code> register fields was fairly simple. Handling returns wasn’t that hard either. The big trick to <a target="_blank" rel="noopener" href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v">this core</a> is the counter that counts the number of ongoing transactions.</font></p>
<p><font color="red">Imagine that: after years of studying FPGA designs you find that the tricky part of the design turns out to be a counter, the very same thing you studied back on day one when you started learning digital logic.</font></p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">冰蒂斯</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/11/13/5-1-basic-master/">http://example.com/2023/11/13/5-1-basic-master/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">冰蒂斯のformula</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/AXI/">AXI</a><a class="post-meta__tags" href="/tags/master/">master</a><a class="post-meta__tags" href="/tags/wishbone/">wishbone</a></div><div class="post_share"><div class="social-share" data-image="/img/chainsaw_makima04.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/15/5-1-1-basic-master/" title="5-1 basic_master(中)"><img class="cover" src="/img/chainsaw_makima04.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">5-1 basic_master(中)</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/11/hello-world/" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hello World</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/11/15/5-1-1-basic-master/" title="5-1 basic_master(中)"><img class="cover" src="/img/chainsaw_makima04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-15</div><div class="title">5-1 basic_master(中)</div></div></a></div><div><a href="/2023/11/23/5-1-2-basic-master/" title="5-1 basic_master(下)"><img class="cover" src="/img/chainsaw_makima04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-23</div><div class="title">5-1 basic_master(下)</div></div></a></div><div><a href="/2023/12/06/MM2S/" title="MM2S"><img class="cover" src="/img/chainsaw_red.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-06</div><div class="title">MM2S</div></div></a></div><div><a href="/2023/11/25/axi-master-full/" title="axi(full)master(上)"><img class="cover" src="/img/chainsaw_makima04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-25</div><div class="title">axi(full)master(上)</div></div></a></div><div><a href="/2023/12/03/axi-master-fulllast/" title="axi_(full)master(下)"><img class="cover" src="/img/chainsaw_makima04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-03</div><div class="title">axi_(full)master(下)</div></div></a></div><div><a href="/2023/11/18/Property-master/" title="Property_axil-master"><img class="cover" src="/img/chainsaw_makima04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-18</div><div class="title">Property_axil-master</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">冰蒂斯</div><div class="author-info__description">螺旋上升的人生,也是多线程的人生</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#5-1-AXI-master"><span class="toc-number">1.</span> <span class="toc-text">5-1 AXI master</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Classes-of-AXI-Masters"><span class="toc-number">2.</span> <span class="toc-text">1. Classes of AXI Masters</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-Single-beat"><span class="toc-number">2.1.</span> <span class="toc-text">1.1 Single beat</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Single-beat-pipelined"><span class="toc-number">2.2.</span> <span class="toc-text">1.2 Single beat pipelined</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-guilty-of-xilinx"><span class="toc-number">2.2.1.</span> <span class="toc-text">1. guilty of xilinx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-difference"><span class="toc-number">2.2.2.</span> <span class="toc-text">2. difference</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-key-problem"><span class="toc-number">2.2.3.</span> <span class="toc-text">3. key &amp; problem</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-Bursting-single-channel"><span class="toc-number">2.3.</span> <span class="toc-text">1.3 Bursting, single channel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-burst-ask-more"><span class="toc-number">2.3.1.</span> <span class="toc-text">1. burst ask more</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-challenging-changes"><span class="toc-number">2.3.2.</span> <span class="toc-text">2. challenging changes</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-Bursting-multiple-channel"><span class="toc-number">2.4.</span> <span class="toc-text">1.4 Bursting, multiple channel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-one-connection-without-ID"><span class="toc-number">2.4.1.</span> <span class="toc-text">1. one connection without ID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-connection-with-ID"><span class="toc-number">2.4.2.</span> <span class="toc-text">2. connection with ID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-single-vs-multichannel-masters"><span class="toc-number">2.4.3.</span> <span class="toc-text">3.  single vs multichannel masters</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-single-beat-pipelined-AXI-master"><span class="toc-number">3.</span> <span class="toc-text">2. single beat,pipelined AXI master</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-the-situation-you-can%E2%80%99t-use-AXI-protocol"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 the situation you can’t use AXI protocol</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-the-roughly-introduction"><span class="toc-number">3.2.</span> <span class="toc-text">2.2  the roughly introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-implement"><span class="toc-number">3.3.</span> <span class="toc-text">2.3 implement</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-wb-stall-signal"><span class="toc-number">3.3.1.</span> <span class="toc-text">1. wb_stall signal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-If-i-wb-stb-i-wb-we"><span class="toc-number">3.3.2.</span> <span class="toc-text">2. If (i_wb_stb &amp;&amp; i_wb_we)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-handle-%E2%80%9CAW-W-channel%E2%80%9D"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.handle “AW &amp; W  channel”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-The-advantage-above"><span class="toc-number">3.3.4.</span> <span class="toc-text">4. The advantage above</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-handle-%E2%80%9CAR-channel%E2%80%9D"><span class="toc-number">3.3.5.</span> <span class="toc-text">5.handle “AR channel”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-handle-%E2%80%9CR-channel%E2%80%9D"><span class="toc-number">3.3.6.</span> <span class="toc-text">6.handle “R channel”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-no-ability-to-stall-any-returns"><span class="toc-number">3.3.7.</span> <span class="toc-text">7. no ability to stall any returns</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-wb-ready-signal"><span class="toc-number">3.3.8.</span> <span class="toc-text">8. wb ready_signal</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-Last-the-ugly-counter"><span class="toc-number">3.4.</span> <span class="toc-text">2.4 Last: the ugly counter</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-the-counter-for"><span class="toc-number">3.4.1.</span> <span class="toc-text">1. the counter for</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-baisc-counter"><span class="toc-number">3.4.2.</span> <span class="toc-text">2. baisc counter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-keep-track-of-direction"><span class="toc-number">3.4.3.</span> <span class="toc-text">3. keep track of direction</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-conclusion"><span class="toc-number">3.5.</span> <span class="toc-text">2.5 conclusion</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/01/07/skid-buffer/" title="skid_buffer"><img src="/img/chainsaw_power01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="skid_buffer"/></a><div class="content"><a class="title" href="/2024/01/07/skid-buffer/" title="skid_buffer">skid_buffer</a><time datetime="2024-01-07T12:48:03.000Z" title="发表于 2024-01-07 20:48:03">2024-01-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/06/how2blog/" title="how2blog"><img src="/img/reze.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="how2blog"/></a><div class="content"><a class="title" href="/2024/01/06/how2blog/" title="how2blog">how2blog</a><time datetime="2024-01-06T14:34:23.000Z" title="发表于 2024-01-06 22:34:23">2024-01-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/27/S2MM/" title="S2MM"><img src="/img/chainsaw_red.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="S2MM"/></a><div class="content"><a class="title" href="/2023/12/27/S2MM/" title="S2MM">S2MM</a><time datetime="2023-12-27T05:57:36.000Z" title="发表于 2023-12-27 13:57:36">2023-12-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/24/auto2-using/" title="auto2-using"><img src="/img/chainsaw_makima04.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="auto2-using"/></a><div class="content"><a class="title" href="/2023/12/24/auto2-using/" title="auto2-using">auto2-using</a><time datetime="2023-12-24T14:17:24.000Z" title="发表于 2023-12-24 22:17:24">2023-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/12/auto1-introduction/" title="auto1_introduction"><img src="/img/flower.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="auto1_introduction"/></a><div class="content"><a class="title" href="/2023/12/12/auto1-introduction/" title="auto1_introduction">auto1_introduction</a><time datetime="2023-12-12T06:18:40.000Z" title="发表于 2023-12-12 14:18:40">2023-12-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 冰蒂斯</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>