<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MM2S | 冰蒂斯のformula</title><meta name="author" content="冰蒂斯"><meta name="copyright" content="冰蒂斯"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 前言 Project: WB2AXIPSP: bus bridges and other odds and ends Purpose: Converts an AXI (full) memory port to an AXI-stream interface.  对于 parameter 、 IO signal 、 localparam 三个部分不再做赘述，需要使用的使用再进行必要的禅阐述。">
<meta property="og:type" content="article">
<meta property="og:title" content="MM2S">
<meta property="og:url" content="http://example.com/2023/12/06/MM2S/index.html">
<meta property="og:site_name" content="冰蒂斯のformula">
<meta property="og:description" content="1. 前言 Project: WB2AXIPSP: bus bridges and other odds and ends Purpose: Converts an AXI (full) memory port to an AXI-stream interface.  对于 parameter 、 IO signal 、 localparam 三个部分不再做赘述，需要使用的使用再进行必要的禅阐述。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/chainsaw_red.jpg">
<meta property="article:published_time" content="2023-12-06T13:45:55.000Z">
<meta property="article:modified_time" content="2023-12-26T12:44:25.107Z">
<meta property="article:author" content="冰蒂斯">
<meta property="article:tag" content="AXI">
<meta property="article:tag" content="master">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/chainsaw_red.jpg"><link rel="shortcut icon" href="/img/bloodborn_lib.png"><link rel="canonical" href="http://example.com/2023/12/06/MM2S/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MM2S',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-26 20:44:25'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/reze.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="冰蒂斯のformula"><span class="site-name">冰蒂斯のformula</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MM2S</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-06T13:45:55.000Z" title="发表于 2023-12-06 21:45:55">2023-12-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-26T12:44:25.107Z" title="更新于 2023-12-26 20:44:25">2023-12-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/AXI/">AXI</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/AXI/master/">master</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MM2S"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><blockquote>
<p>Project: WB2AXIPSP: bus bridges and other odds and ends</p>
<p>Purpose: Converts an AXI (full) memory port to an AXI-stream interface.</p>
</blockquote>
<p>对于 <em>parameter</em> 、 <em>IO signal</em> 、 <em>localparam</em> 三个部分不再做赘述，需要使用的使用再进行必要的禅阐述。我会在前言部分，慢慢地，一步一步，讲解 <em>register</em> 的相关设置。</p>
<blockquote>
<ul>
<li><p><strong>[31]  r_busy</strong> : True if the core is in the middle of a transaction；</p>
</li>
<li><p><strong>[30]  r_err</strong> ： <strong>True</strong> if the core has detected an error, a bus error while the FIFO is reading. Writing a ‘1’ to this bit while the core is idle will clear it.  New transfers will not start until this bit is cleared.当核心处于空闲状态时，向这个位写入’1’将会清除它，也就是将它设置为假（False）。只有当这个位被清除（设置为假）后，新的传输才会开始。</p>
</li>
<li><p><strong>[29]  r_complete</strong>：<strong>True</strong> if the transaction has completed, whether normally or abnormally (error or abort). Any write to the <code>CMD_CONTROL</code> register will clear this flag.</p>
</li>
<li><p><strong>[28]  r_continuous</strong> :</p>
<p>Normally the FIFO gets cleared and reset between operations. </p>
<p>However, if you <strong>set</strong> r_continuous, the core will then expect a second operation to take place following the first one. In this case, the operation will complete but the FIFO won’t get cleared.  During this time, the FIFO will not fill further.</p>
<p>Any write to the <code>CMD_CONTROL</code> register while the core is <strong>not</strong> busy will adjust this bit.</p>
<ul>
<li><code>r_continuous</code>：这是一个标志位，用于控制是否在操作之间清除和重置FIFO。</li>
<li>如果<code>r_continuous</code>为假，那么在每次操作之后，FIFO队列会被清除和重置。这是正常的操作模式。</li>
<li>如果<code>r_continuous</code>为真，那么核心（core）会期望在第一个操作完成后立即进行第二个操作。在这种情况下，第一个操作会完成，但FIFO队列不会被清除。在这段时间内，FIFO队列不会进一步填充。</li>
<li>当核心处于空闲状态时，对<code>CMD_CONTROL</code>寄存器的写操作会调整<code>r_continuous</code>位</li>
</ul>
</li>
<li><p><strong>[27]  !r_increment</strong> ：</p>
<ul>
<li>If <strong>clear</strong>, the core reads from <strong>subsequent and incrementing</strong> addresses.</li>
</ul>
</li>
<li><p>If <strong>set</strong>, the core reads from the <strong>same</strong> address throughout a transaction. </p>
</li>
<li><p><code>Writes</code> to <code>CMD_CONTROL</code> while the core is <code>idle</code> will adjust this bit.</p>
</li>
<li><p>如果<code>!r_increment</code>为假（即<code>r_increment</code>为真），核心（core）会从连续并递增的地址中读取数据。这通常用于读取存储在连续内存地址中的数据，如数组。</p>
<ul>
<li>如果<code>!r_increment</code>为真（即<code>r_increment</code>为假），核心会在整个事务过程中从同一地址读取数据。这通常用于读取存储在固定内存地址中的数据，如硬件寄存器。</li>
</ul>
</li>
<li><p>当核心处于空闲状态时，对<code>CMD_CONTROL</code>的写操作会调整<code>r_increment</code>位。</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><p><strong><code>8-c</code>:    CMD_ADDRLO, CMD_ADDR_HI</strong> ：<code>[C_AXI_ADDR_WIDTH-1:($clog2(C_AXI_DATA_WIDTH)-3)]</code></p>
</li>
<li><p>If idle, the address the core will read from when it starts.</p>
</li>
<li><p>If busy, the address the core is currently reading from.</p>
</li>
</ul>
<p>Upon completion, the address <strong>either</strong> returns to the starting address (if r_continuous is clear), <strong>or</strong> otherwise becomes the address where the core left off.  In the case of an abort or an error, this will be (near) the address that was last read.Why “near”?  Because this address records the reads that have been issued while no error is pending.  If a bus error return comes back, there may have been several more reads issued before that error address.</p>
<p>我们有一个核心（core），它需要从一个内存地址读取一些数据。这个核心有两个寄存器：<code>CMD_ADDRLO</code>和<code>CMD_ADDRHI</code>，它们存储了核心将要读取的地址。当核心处于空闲状态时，这个地址是核心开始时将要读取的地址。当核心处于忙碌状态时，这个地址是核心当前正在读取的地址。假设<code>CMD_ADDRLO</code>和<code>CMD_ADDRHI</code>的值分别为8和12，那么核心将从地址8开始，读取到地址12。如果在读取过程中发生了中止或错误，那么这个地址将是最后读取的（或者说接近最后读取的）地址。</p>
<p>&#x2F;&#x2F;      comes back, there may have been several more reads issued before</p>
<p>&#x2F;&#x2F;      that error address.</p>
<ul>
<li><code>18-1c</code>:  <strong>CMD_LENLO</strong>, <strong>CMD_LENHI</strong>   <code>[LGLEN-1:0]</code></li>
</ul>
<p><strong><font color="red">The size of the transfer in bytes.</font></strong>  Only accepts aligned addresses, therefore bits <code>[($clog2(C_AXI_DATA_WIDTH)-3):0]</code> will always be forced to zero.  **<font color="darblue">To find out what size bus this core is conencted to, or the maximum transfer length, write a -1 to this value and read the returning result.</font>**Only the active bits will be set. While the core is busy, reads from this address will return the number of items still to be read from the bus.在代码中的定义如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">localparam</span> [<span class="number">2</span>:<span class="number">0</span>]		CMD_LENLO     = <span class="number">3&#x27;b110</span>,</span><br><span class="line">											CMD_LENHI     = <span class="number">3&#x27;b111</span>;</span><br></pre></td></tr></table></figure>


</blockquote>
<h1 id="2-AXI-lite-signaling"><a href="#2-AXI-lite-signaling" class="headerlink" title="2. AXI-lite signaling"></a>2. AXI-lite signaling</h1><blockquote>
<p>This is mostly the skidbuffer logic, and handling of the <em>VALID</em> and <em>READY</em> signals for the <em>AXI-lite</em> control logic in the next  section.</p>
</blockquote>
<h2 id="2-1-write-signaling"><a href="#2-1-write-signaling" class="headerlink" title="2.1 write signaling"></a>2.1 write signaling</h2><p>我们首先要了解，<em>axi address is based on byte</em> ， 所以想要使得 <em>address based on bus data</em> 需要对地址进行一定的处理。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The bottom ADDRLSB bits of any AXI address are subword bits</span></span><br><span class="line"><span class="keyword">localparam</span>	ADDRLSB = <span class="built_in">$clog2</span>(C_AXI_DATA_WIDTH)-<span class="number">3</span>,</span><br><span class="line"><span class="keyword">localparam</span>	AXILLSB = <span class="built_in">$clog2</span>(C_AXIL_DATA_WIDTH)-<span class="number">3</span>,</span><br></pre></td></tr></table></figure>

<h3 id="1-double-skidbuffer"><a href="#1-double-skidbuffer" class="headerlink" title="1. double skidbuffer"></a>1. double skidbuffer</h3><p>对于 <em>write address</em> 的处理如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">skidbuffer #(</span><br><span class="line">	<span class="variable">.OPT_OUTREG</span>(<span class="number">0</span>),</span><br><span class="line">	<span class="variable">.OPT_LOWPOWER</span>(OPT_LOWPOWER),</span><br><span class="line">     	<span class="comment">// make the address based on write data bus width</span></span><br><span class="line">	<span class="variable">.DW</span>(C_AXIL_ADDR_WIDTH-AXILLSB)</span><br><span class="line">) axilawskid(</span><br><span class="line">	<span class="variable">.i_clk</span>(S_AXI_ACLK), </span><br><span class="line">     	<span class="variable">.i_reset</span>(i_reset),</span><br><span class="line">	<span class="variable">.i_valid</span>(S_AXIL_AWVALID), </span><br><span class="line">     	<span class="variable">.o_ready</span>(S_AXIL_AWREADY),</span><br><span class="line">     	<span class="comment">// make the address based on write data bus width</span></span><br><span class="line">	<span class="variable">.i_data</span>(S_AXIL_AWADDR[C_AXIL_ADDR_WIDTH-<span class="number">1</span>:AXILLSB]),</span><br><span class="line">	<span class="variable">.o_valid</span>(awskd_valid), </span><br><span class="line">     	<span class="variable">.i_ready</span>(axil_write_ready),</span><br><span class="line">	<span class="variable">.o_data</span>(awskd_addr)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在对 <em>write data</em> 进行传输的时候，不仅仅需要传输 <em>data</em> ， 还需要将 <em>strb</em> 参数一起传递。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">skidbuffer #(</span><br><span class="line">	<span class="variable">.OPT_OUTREG</span>(<span class="number">0</span>),</span><br><span class="line">	<span class="variable">.OPT_LOWPOWER</span>(OPT_LOWPOWER),</span><br><span class="line">     	<span class="comment">// data width plus the width of data_strobe</span></span><br><span class="line">	<span class="variable">.DW</span>(C_AXIL_DATA_WIDTH+C_AXIL_DATA_WIDTH/<span class="number">8</span>)</span><br><span class="line">) axilwskid(</span><br><span class="line">	<span class="variable">.i_clk</span>(S_AXI_ACLK), </span><br><span class="line">     	<span class="variable">.i_reset</span>(i_reset),</span><br><span class="line">	<span class="variable">.i_valid</span>(S_AXIL_WVALID), </span><br><span class="line">     	<span class="variable">.o_ready</span>(S_AXIL_WREADY),</span><br><span class="line">     	<span class="comment">// data width plus the width of data_strobe</span></span><br><span class="line">	<span class="variable">.i_data</span>(&#123; S_AXIL_WDATA, S_AXIL_WSTRB &#125;),</span><br><span class="line">	<span class="variable">.o_valid</span>(wskd_valid), </span><br><span class="line">     	<span class="variable">.i_ready</span>(axil_write_ready),</span><br><span class="line">	<span class="variable">.o_data</span>(&#123; wskd_data, wskd_strb &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h3 id="2-align-AW-W"><a href="#2-align-AW-W" class="headerlink" title="2. align AW &amp; W"></a>2. align AW &amp; W</h3><p>注意到了 <em>2.1.1</em> 小结中 <code>skidbuffer</code>的 <code>ready</code>信号使用了吗？ 你可能会惊讶的发现对于 <code>AW</code>和 <code>W</code>两个 <em>channel</em> 的 <code>ready</code> 信号使用了同一个信号，这意味着 <code>axi-lite</code>协议中 <em>write address</em> 和 <em>write data</em> 两个部分是永远的被 <code>synchronize</code>的，在被 <em>master</em>发出的时候就已经 <code>synchronized</code>。</p>
<p>那么 <em>ready</em> 信号是通过何种方式被同步的呢？</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span>	axil_write_ready = clk_active </span><br><span class="line">     						&amp;&amp; awskd_valid &amp;&amp; wskd_valid</span><br><span class="line">						&amp;&amp; (!S_AXIL_BVALID || S_AXIL_BREADY);</span><br></pre></td></tr></table></figure>

<p>The signal <em>clk_active</em> will be assigned later, I do not think that it should be discussed now, just ignore it temperarily. Then I want to talk about the  <code>awskd_valid &amp;&amp; wskd_valid</code> , which means signal <em>axil_write_ready</em> should be asserted only when <em>awskd_valid</em> and <em>wskd_valid</em> are <code>asserted</code>.</p>
<p>Another  situation should be considered : when a <code>valid before ready</code> happen in the <code>B channel</code>,  the MM2S master should not allow ready asserted in these two channel. </p>
<p><strong>Attention</strong> : the signal names are capital letters，means that although we are designing a master module ，there is slave part will be used. </p>
<p>总结，在 <em>axi-lite</em> 的控制中， <em>MM2S</em> 被用于 <em>slave</em> 段，执行 <em>slave</em> 的相关操作。信号 <em>axil_write_ready</em> 为真表示， <em>MM2S</em> 作为一个 <em>slave</em> </p>
<h3 id="3-B-channel"><a href="#3-B-channel" class="headerlink" title="3. B channel"></a>3. B channel</h3><p>在 <em>B channel</em> 中，目前只有两个值得关注的信号，分别是 <em>B_valid</em> &amp; <em>b_resp</em> 。为了简化逻辑，返回的信号只有一种类型 <code>OKAY</code>（i.e. <code>2&#39;b00</code>）。通过控制寄存器 <code>axil_bvalid</code>控制 <em>MM2S</em> 的 <em>xxx_b_valid</em> 输出。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	axil_bvalid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (i_reset)</span><br><span class="line">	axil_bvalid &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (axil_write_ready)</span><br><span class="line">	axil_bvalid &lt;= <span class="number">1</span>;</span><br><span class="line"><span class="comment">// the signal S_AXIL_BREADY is from the upstream CUP_MASTER</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (S_AXIL_BREADY)</span><br><span class="line">	axil_bvalid &lt;= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span>	S_AXIL_BVALID = axil_bvalid;</span><br><span class="line"><span class="keyword">assign</span>	S_AXIL_BRESP = <span class="number">2&#x27;b00</span>;</span><br></pre></td></tr></table></figure>

<p>这种情况造成 <em>axil_bvalid</em> 信号的跳动，最高的吞吐量被限制在了 <code>50%</code> 的范围。这种方式胜在简单。</p>
<h2 id="2-2-read-signaling"><a href="#2-2-read-signaling" class="headerlink" title="2.2 read signaling"></a>2.2 read signaling</h2><h3 id="1-skidbuffer"><a href="#1-skidbuffer" class="headerlink" title="1. skidbuffer"></a>1. skidbuffer</h3><p>对于<em>axi-read</em> 也需要使用 <em>skidbuffer</em> ，其中也会对地址进行处理，将 <em>address based on bytes</em> 转化为 <em>address based on data_bus</em>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">skidbuffer #(</span><br><span class="line">	<span class="variable">.OPT_OUTREG</span>(<span class="number">0</span>),</span><br><span class="line">	<span class="variable">.OPT_LOWPOWER</span>(OPT_LOWPOWER),</span><br><span class="line">	<span class="variable">.DW</span>(C_AXIL_ADDR_WIDTH-AXILLSB)</span><br><span class="line">) axilarskid(</span><br><span class="line">	<span class="variable">.i_clk</span>(S_AXI_ACLK), </span><br><span class="line">   <span class="variable">.i_reset</span>(i_reset),</span><br><span class="line">	<span class="variable">.i_valid</span>(S_AXIL_ARVALID), </span><br><span class="line">   <span class="variable">.o_ready</span>(S_AXIL_ARREADY),</span><br><span class="line">	<span class="variable">.i_data</span>(S_AXIL_ARADDR[C_AXIL_ADDR_WIDTH-<span class="number">1</span>:AXILLSB]),</span><br><span class="line">	<span class="variable">.o_valid</span>(arskd_valid), </span><br><span class="line">   <span class="variable">.i_ready</span>(axil_read_ready),</span><br><span class="line">	<span class="variable">.o_data</span>(arskd_addr)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h3 id="2-handle-on-AR"><a href="#2-handle-on-AR" class="headerlink" title="2. handle on AR"></a>2. handle on AR</h3><p><em>axi-lite</em> 的 <em>read transaction</em> 不需要向 <em>write transaction</em> 一样在接受之前 <em>synchronize AW &amp; W channel</em> 。只需要在<em>active</em> 状态下接受到了有效的 <em>AR</em> 信号 <em>arskd_valid</em> ，并且没有 <em>valid before ready</em> 发生在 <code>R channel</code>，便可以接受 <code>NEW AR request</code> ！！！</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span>	axil_read_ready = clk_active </span><br><span class="line">     					&amp;&amp; arskd_valid</span><br><span class="line">					&amp;&amp; (!axil_read_valid || S_AXIL_RREADY);</span><br></pre></td></tr></table></figure>

<p>可以通过该方法，将 <em>AR</em> 指定读地址的数据送出，并发出读有效信号 <em>axil_read_valid</em> 。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	axil_read_valid = <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (i_reset)</span><br><span class="line">	axil_read_valid &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (axil_read_ready)</span><br><span class="line">	axil_read_valid &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (S_AXIL_RREADY)</span><br><span class="line">	axil_read_valid &lt;= <span class="number">1&#x27;b0</span>;</span><br></pre></td></tr></table></figure>

<p>关于 <code>axil_read_data</code>的逻辑在后续的代码中，暂时不需要了解。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span>	S_AXIL_RVALID = axil_read_valid;</span><br><span class="line"><span class="keyword">assign</span>	S_AXIL_RDATA  = axil_read_data;</span><br><span class="line"><span class="keyword">assign</span>	S_AXIL_RRESP = <span class="number">2&#x27;b00</span>;</span><br></pre></td></tr></table></figure>



<h1 id="3-AXI-lite-controlled-logic"><a href="#3-AXI-lite-controlled-logic" class="headerlink" title="3. AXI-lite controlled logic"></a>3. AXI-lite controlled logic</h1><p>该部分设计了很多的控制寄存器，和相关的命令，这些资料都可以在代码的顶端看见。</p>
<ul>
<li>也会在阅读代码的途中，我会不断的回顾这些知识点。</li>
<li>我会在这里不断的完善每个小结的重点</li>
</ul>
<h2 id="3-1-abort-transaction"><a href="#3-1-abort-transaction" class="headerlink" title="3.1 abort transaction"></a>3.1 abort transaction</h2><p>两个寄存器： <code>w_cmd_abort</code> , <code>cmd_abort</code>，定义了一个名为<code>cmd_abort</code>的信号，该信号用于表示是否需要中止事务。</p>
<ul>
<li><code>w_cmd_abort</code>是一个组合逻辑信号，它在以下条件下被设置为1：<ul>
<li>当 <em>axil_write_ready</em> 为真且<code>awskd_addr</code>等于<code>CMD_CONTROL</code>时，表示AXI总线上有一个写操作请求，并且目标地址是命令控制寄存器。</li>
<li>当<code>wskd_strb[3]</code>为真且<code>wskd_data[31:24]</code>等于<code>ABORT_KEY</code>时，表示写操作的strobes信号的第4位为真（表示这是一个有效的写操作），并且写操作的数据的最高8位等于<code>ABORT_KEY</code>（表示这是一个中止事务的命令）。</li>
<li>当<code>r_busy</code>为假时，<code>w_cmd_abort</code>被设置为0，表示当前没有正在进行的事务，因此不需要中止事务。</li>
</ul>
</li>
</ul>
<p>根据 <em>commont</em> 可以知道 <code>r_busy</code>代表的含义：</p>
<blockquote>
<p>[31]    <strong>r_busy</strong> : True if the core is in the middle of a transaction</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	w_cmd_abort = <span class="number">0</span>;</span><br><span class="line">	w_cmd_abort = (axil_write_ready </span><br><span class="line">         			&amp;&amp; awskd_addr == CMD_CONTROL)</span><br><span class="line">							&amp;&amp; (wskd_strb[<span class="number">3</span>] </span><br><span class="line">               &amp;&amp; wskd_data[<span class="number">31</span>:<span class="number">24</span>] == ABORT_KEY);</span><br><span class="line">     </span><br><span class="line">	<span class="keyword">if</span> (!r_busy)</span><br><span class="line">		w_cmd_abort = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<ul>
<li><code>cmd_abort</code>是一个寄存器，它在每个时钟上升沿更新。<ul>
<li>如果<code>r_busy</code>为真且<code>cmd_abort</code>为真 ;</li>
<li>或者<code>w_cmd_abort</code>为真，<code>cmd_abort</code>被设置为1，表示需要中止当前的事务。</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	cmd_abort = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (i_reset)</span><br><span class="line">	cmd_abort &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	cmd_abort &lt;= (cmd_abort &amp;&amp; r_busy)||w_cmd_abort;</span><br></pre></td></tr></table></figure>

<p>为什么这样设置呢，在开始的时候，<em>abort</em> 命令需要 <em>w_cmd_abort</em> 逻辑进行控制。该写入的控制逻辑，可能只持续一个时钟周期后消失，但如果设计需要保持 <em>cmd_abort</em> 几个连续的时钟周期才能退出，这种情况怎么办？于是逻辑确保，如果执行了 <em>cmd_abort</em> 并且保持状态 <em>busy</em>，那么就一直 <em>abort</em> ！</p>
<h2 id="3-2-Start-command"><a href="#3-2-Start-command" class="headerlink" title="3.2 Start command"></a>3.2 Start command</h2><blockquote>
<p>Purpose: w_cmd_start  ——  Start command</p>
<p>Desc:  定义了一个名为<code>w_cmd_start</code>的信号，该信号用于表示是否需要开始一个新的事务。</p>
</blockquote>
<p>需要了解一下 <em>localparam</em> ，以及  <em>register</em> 的设置：</p>
<ul>
<li><em>localparam</em>    <strong><code>CBIT_BUSY</code></strong>   &#x3D; 31</li>
<li><strong>[31]   r_busy</strong> : <strong>True</strong> if the core is in the middle of a transaction</li>
<li><strong>[30]    r_err</strong> ： <strong>True</strong> if the core has detected an error, a bus error while the FIFO is reading. Writing a ‘1’ to this bit while the core is <strong>idle</strong> will <strong>clear</strong> it.  New transfers <strong>will not start until</strong> this bit is <strong>cleared</strong>.</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line">    <span class="comment">// if we want to set the w_cmd_start true  to start a new transaction</span></span><br><span class="line">    <span class="comment">//  there should not be a transaction  happening, the state should be idle</span></span><br><span class="line"><span class="keyword">if</span> (r_busy)</span><br><span class="line">	w_cmd_start = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// no busy , so we can try to start a new transacrion this time !</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">	w_cmd_start = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> ((axil_write_ready </span><br><span class="line">        &amp;&amp; awskd_addr == CMD_CONTROL)</span><br><span class="line">        &amp;&amp; (wskd_strb[<span class="number">3</span>] 					<span class="comment">// the forth byte is valid</span></span><br><span class="line">        &amp;&amp; wskd_data[CBIT_BUSY]))	<span class="comment">// the 32th bit of data is true</span></span><br><span class="line">         </span><br><span class="line">         <span class="comment">// the operation above , means that there is no BUSY true in the 32th of </span></span><br><span class="line">         <span class="comment">// control register. But there is a valid write operation , the write address&#x27;</span></span><br><span class="line">         <span class="comment">// is the CMD_CONTROL register.</span></span><br><span class="line">         <span class="comment">// AND there is a valid wirting to the 32th bit of it. the operation wants to</span></span><br><span class="line">         <span class="comment">// set BUSY , it want to start a new transaction ! </span></span><br><span class="line">				w_cmd_start = <span class="number">1</span>;</span><br><span class="line">     </span><br><span class="line">     	<span class="comment">// r_err == 1 ,</span></span><br><span class="line">     	<span class="comment">//		means that there is an ERROR in last transaction , you are allow to set </span></span><br><span class="line">     	<span class="comment">//		a new transaction untill the ERROR_bit is cleared !</span></span><br><span class="line">      	<span class="comment">// !wskd_data[CBIT_ERR] == 1,</span></span><br><span class="line">     	<span class="comment">//		means that ,the (un)valid wirte operation did not want a new transaction</span></span><br><span class="line">	<span class="keyword">if</span> (r_err &amp;&amp; !wskd_data[CBIT_ERR])</span><br><span class="line">				w_cmd_start = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">     	<span class="comment">// I do not know it temperarily</span></span><br><span class="line">	<span class="keyword">if</span> (zero_length)</span><br><span class="line">		w_cmd_start = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// now I don&#x27;t care about the OPT_UNALIGNED situation temperarily</span></span><br><span class="line">	<span class="keyword">if</span> (OPT_UNALIGNED &amp;&amp; unaligned_cmd_addr</span><br><span class="line">			&amp;&amp; wskd_data[CBIT_INCREMENT])</span><br><span class="line">		w_cmd_start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><font color="red">这里的信号 <strong>zero_length</strong> 我暂时不对这里进行修改。</font></p>
<h2 id="3-3-Calculate-busy-or-complete-flags"><a href="#3-3-Calculate-busy-or-complete-flags" class="headerlink" title="3.3 Calculate busy or complete flags"></a>3.3 Calculate busy or complete flags</h2><p>上面多次提及到了 <code>r_busy</code>，这里第一次出现 <code>r_complete</code>的 <em>flag</em> ， 需要回顾一下这是什么。</p>
<blockquote>
<ul>
<li><strong>[29]    r_complete</strong>:</li>
</ul>
<p>  <strong>Desc</strong> : <strong>True</strong> if the transaction has <strong>completed</strong>, whether <em>normally or  abnormally (error or abort)</em>. </p>
<p>  <strong>Attention</strong>  :  <strong>Any</strong> write to the <em>CMD_CONTROL</em> register will clear this flag.</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// r_busy, r_complete: Calculate busy or complete flags</span></span><br><span class="line"><span class="keyword">initial</span>	r_busy     = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">initial</span>	r_complete = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (i_reset)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	r_busy     &lt;= <span class="number">0</span>;<span class="comment">//no busy</span></span><br><span class="line">	r_complete &lt;= <span class="number">0</span>;<span class="comment">//no complete</span></span><br><span class="line"> <span class="keyword">end</span>  </span><br><span class="line"> <span class="comment">// the r_busy ==1,</span></span><br><span class="line"> <span class="comment">// means	there is no transaction happening , the control state is idle</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!r_busy) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span> (w_cmd_start)</span><br><span class="line">         	<span class="comment">// there is transaction cmd_start , there is a r_busy asserted !</span></span><br><span class="line">     			<span class="comment">// means: we get a command to start a new transaction, the design will busy</span></span><br><span class="line">					r_busy &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">     </span><br><span class="line">	<span class="keyword">if</span> (axil_write_ready &amp;&amp; awskd_addr == CMD_CONTROL)</span><br><span class="line">					<span class="comment">// Any write to the control register will clear the</span></span><br><span class="line">					<span class="comment">// completion flag</span></span><br><span class="line">					r_complete &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line"> <span class="keyword">end</span> </span><br><span class="line"><span class="comment">// there is a transaction happening</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (r_busy) <span class="keyword">begin</span></span><br><span class="line">   <span class="keyword">if</span> (w_complete) <span class="keyword">begin</span></span><br><span class="line">		r_complete &lt;= <span class="number">1</span>;   <span class="comment">// waiting any write operation to the control register</span></span><br><span class="line">		r_busy &lt;= <span class="number">1&#x27;b0</span>;	<span class="comment">// once completed , there is no r_busy next time_clock</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>这里可以明白， <code>COMTROL_REGISTER</code> 并不是一个 <em>32bits</em> 的整块寄存器。而是分散的 <em>single bit or some bits register combined</em> 组合起来的。</p>
<p>在 <code>3.3.2</code> 中 <code>w_cmd_start</code>是由写有效和<code>wksd_data[CBIT_BUSY]</code>是否有效一起实现的，寄存器 <code>r_busy</code>只是一个判断信号，并不是真正的控制信号，在 <code>3.3.3</code>中才实现了真正的控制。</p>
<p><font color="red"><strong>PS : w_complete 信号由后面的逻辑实现，这里暂时忽略。</strong></font></p>
<h2 id="3-4-Interrupt"><a href="#3-4-Interrupt" class="headerlink" title="3.4 Interrupt"></a>3.4 Interrupt</h2><blockquote>
<p>Create an output signal to indicate that we’ve finished</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">output</span>  <span class="keyword">reg</span>             o_int</span><br></pre></td></tr></table></figure>
</blockquote>
<p>当系统忙（<code>r_busy</code>为真）并且完成了一项操作（<code>w_complete</code>为真）时，就会产生一个中断（<code>o_int</code>被设置为1）。这样，处理器就可以知道已经完成了一项操作，可以进行下一步处理。</p>
<p>这个 <em>interrupt</em> 和我认识到的不一样，只是一个 <em>flag</em> ，只一点注意。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// o_int: Interrupts</span></span><br><span class="line"><span class="keyword">initial</span>	o_int = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (i_reset)</span><br><span class="line">	o_int &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	o_int &lt;= (r_busy &amp;&amp; w_complete);</span><br></pre></td></tr></table></figure>



<h2 id="3-5-ERR-condition"><a href="#3-5-ERR-condition" class="headerlink" title="3.5 ERR condition"></a>3.5 ERR condition</h2><p>参数介绍：</p>
<blockquote>
<ul>
<li>localparam     <code>CBIT_ERR</code>    &#x3D; 30</li>
<li>localparam     <code>CBIT_INCREMENT</code>  &#x3D; 27;</li>
<li><strong>[30]    r_err</strong> ： <ul>
<li><strong>True</strong> if the core has detected an error, a bus error while the FIFO is reading. </li>
<li><strong>Writing</strong> a ‘1’ to this bit while the core is idle will clear it.  </li>
<li>New transfers will <strong>not</strong> start <strong>until</strong> this bit is cleared.</li>
</ul>
</li>
<li><strong>[27]	 !r_increment</strong> ：<ul>
<li>If <strong>clear</strong>, the core reads from <strong>subsequent and incrementing</strong> addresses.  </li>
<li>If <strong>set</strong>, the core reads from the <strong>same</strong> address throughout a transaction. </li>
<li><code>Writes</code> to <code>CMD_CONTROL</code> while the core is <code>idle</code> will adjust this bit.</li>
<li>如果<code>!r_increment</code>为假（即<code>r_increment</code>为真），核心（core）会从连续并递增的地址中读取数据。这通常用于读取存储在连续内存地址中的数据，如数组。</li>
<li>如果<code>!r_increment</code>为真（即<code>r_increment</code>为假），核心会在整个事务过程中从同一地址读取数据。这通常用于读取存储在固定内存地址中的数据，如硬件寄存器。</li>
<li>当核心处于空闲状态时，对<code>CMD_CONTROL</code>的写操作会调整<code>r_increment</code>位。</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// r_err : Error conditions</span></span><br><span class="line"><span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (i_reset)</span><br><span class="line">	r_err &lt;= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CONTROL_R r_busy is zero , no transaction </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!r_busy)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">     	<span class="comment">// new writing to control register happens just now</span></span><br><span class="line">	<span class="keyword">if</span> (axil_write_ready &amp;&amp; awskd_addr == CMD_CONTROL)</span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">         <span class="keyword">if</span> (!w_cmd_abort)		</span><br><span class="line">					r_err &lt;= 	r_err &amp;&amp; </span><br><span class="line">           					(!wskd_strb[<span class="number">3</span>] || </span><br><span class="line">                      !wskd_data[CBIT_ERR]);</span><br><span class="line">         </span><br><span class="line">		<span class="comment">// On any request to start a transfer with an unaligned</span></span><br><span class="line">		<span class="comment">// address, that&#x27;s not incrementing--declare an</span></span><br><span class="line">		<span class="comment">// immediate error</span></span><br><span class="line">         <span class="keyword">if</span> (wskd_strb[<span class="number">3</span>] </span><br><span class="line">           &amp;&amp; wskd_data[CBIT_BUSY]</span><br><span class="line">					&amp;&amp; wskd_data[CBIT_INCREMENT]</span><br><span class="line">					&amp;&amp; (OPT_UNALIGNED &amp;&amp; unaligned_cmd_addr))</span><br><span class="line">             </span><br><span class="line">			r_err &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">else</span> <span class="comment">// if (r_busy)</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">     <span class="comment">// the read_resp[1] must be zero</span></span><br><span class="line">	<span class="keyword">if</span> (M_AXI_RVALID &amp;&amp; M_AXI_RREADY &amp;&amp; M_AXI_RRESP[<span class="number">1</span>])</span><br><span class="line">		r_err &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// &#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure>



<p><font color="red"><strong>PS : 错误条件没有弄清楚，暂时忽略。</strong></font></p>
<h2 id="3-6-r-continuous"><a href="#3-6-r-continuous" class="headerlink" title="3.6 r_continuous"></a>3.6 r_continuous</h2><blockquote>
<ul>
<li><strong>[28]	r_continuous</strong> :</li>
</ul>
<p> Normally the FIFO gets cleared and reset between operations. </p>
<p> However, if you <strong>set</strong> r_continuous, the core will then expect a second operation to take place following the first one. In this case, the operation will complete but the FIFO won’t get cleared.  During this time, the FIFO will not fill further.</p>
<p> Any write to the <code>CMD_CONTROL</code> register while the core is <strong>not</strong> busy will adjust this bit.</p>
<ul>
<li><code>r_continuous</code>：这是一个标志位，用于控制是否在操作之间清除和重置FIFO。</li>
<li>如果<code>r_continuous</code>为假，那么在每次操作之后，FIFO队列会被清除和重置。这是正常的操作模式。</li>
<li>如果<code>r_continuous</code>为真，那么核心（core）会期望在第一个操作完成后立即进行第二个操作。在这种情况下，第一个操作会完成，但FIFO队列不会被清除。在这段时间内，FIFO队列不会进一步填充。</li>
<li>当核心处于空闲状态时，对<code>CMD_CONTROL</code>寄存器的写操作会调整<code>r_continuous</code>位</li>
</ul>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// r_continuous</span></span><br><span class="line"><span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line"><span class="keyword">initial</span>	r_continuous = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (i_reset)</span><br><span class="line">			r_continuous &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span> (!r_busy </span><br><span class="line">       &amp;&amp; axil_write_ready </span><br><span class="line">       &amp;&amp; awskd_addr == CMD_CONTROL</span><br><span class="line">			&amp;&amp; !w_cmd_abort)</span><br><span class="line">         	<span class="comment">// r_busy == 1, means no transaction is happening;</span></span><br><span class="line">         	<span class="comment">// axil_write_ready , awskd_addr == CMD_CONTROL</span></span><br><span class="line">         	<span class="comment">//		means, there is a valid write to control_register;</span></span><br><span class="line">         	<span class="comment">// w_cmd_abort == 0 ,</span></span><br><span class="line">         	<span class="comment">//		means , no abort operation from uper MASTWR(CPU)</span></span><br><span class="line">         </span><br><span class="line">         <span class="comment">// the design is idle (r_busy == 0) , the r_continuous can be changed !</span></span><br><span class="line">				r_continuous &lt;= wskd_strb[<span class="number">3</span>] &amp;&amp; wskd_data[CBIT_CONTINUOUS];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// &#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="3-7-apply-wstrb"><a href="#3-7-apply-wstrb" class="headerlink" title="3.7 apply_wstrb"></a>3.7 apply_wstrb</h2><ul>
<li>如果<code>wstrb[k]</code>为真，那么将<code>new_data</code>的相应字节赋值给<code>apply_wstrb</code>的相应字节；</li>
<li>如果<code>wstrb[k]</code>为假，那么将<code>prior_data</code>的相应字节赋值给<code>apply_wstrb</code>的相应字节。</li>
</ul>
<p>这个函数的主要作用是根据写入字节使能信号<code>wstrb</code>来决定是否更新数据。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> [C_AXIL_DATA_WIDTH-<span class="number">1</span>:<span class="number">0</span>]	apply_wstrb;</span><br><span class="line">	<span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line">	<span class="keyword">input</span>	[C_AXIL_DATA_WIDTH-<span class="number">1</span>:<span class="number">0</span>]		prior_data;</span><br><span class="line">	<span class="keyword">input</span>	[C_AXIL_DATA_WIDTH-<span class="number">1</span>:<span class="number">0</span>]		new_data;</span><br><span class="line">	<span class="keyword">input</span>	[C_AXIL_DATA_WIDTH/<span class="number">8</span>-<span class="number">1</span>:<span class="number">0</span>]	wstrb;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">integer</span>	k;</span><br><span class="line">	<span class="keyword">for</span>(k=<span class="number">0</span>; k&lt;C_AXIL_DATA_WIDTH/<span class="number">8</span>; k=k+<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		apply_wstrb[k*<span class="number">8</span> +: <span class="number">8</span>]</span><br><span class="line">			= wstrb[k] ? new_data[k*<span class="number">8</span> +: <span class="number">8</span>] : prior_data[k*<span class="number">8</span> +: <span class="number">8</span>];</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"><span class="comment">// &#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure>





<h2 id="3-8-address-length"><a href="#3-8-address-length" class="headerlink" title="3.8 address &amp; length"></a>3.8 address &amp; length</h2><p>这一段虽然小，不过要涵盖的内容较多，可能需要较多的片段来记录。</p>
<p>在开始之前，我对这些信号的声明长度十分感兴趣，他们使用的 <em>data_width</em> 进行 <em>addr</em> 相关的声明如下，数据的宽度使用的 AXIL-LIte_data_width*2.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>	[<span class="number">2</span>*C_AXIL_DATA_WIDTH-<span class="number">1</span>:<span class="number">0</span>]	wide_address, 	wide_length,</span><br><span class="line">															new_wideaddr, 	new_widelen;</span><br></pre></td></tr></table></figure>

<p>赋值的信号定义：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>	[C_AXI_ADDR_WIDTH-<span class="number">1</span>:<span class="number">0</span>]	cmd_addr;</span><br></pre></td></tr></table></figure>

<p>这里回顾一下 <em>axi-lite</em> 相关的 <em>parameter</em> 设置：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We support five 32-bit AXI-lite registers, requiring 5-bits</span></span><br><span class="line"><span class="comment">// of AXI-lite addressing</span></span><br><span class="line"><span class="keyword">localparam</span>	C_AXIL_ADDR_WIDTH = <span class="number">5</span>,</span><br><span class="line"><span class="keyword">localparam</span>	C_AXIL_DATA_WIDTH = <span class="number">32</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// The bottom ADDRLSB bits of any AXI address are subword bits</span></span><br><span class="line"><span class="keyword">localparam</span>	ADDRLSB = <span class="built_in">$clog2</span>(C_AXI_DATA_WIDTH)-<span class="number">3</span>,</span><br><span class="line"><span class="keyword">localparam</span>	AXILLSB = <span class="built_in">$clog2</span>(C_AXIL_DATA_WIDTH)-<span class="number">3</span>,</span><br></pre></td></tr></table></figure>



<h3 id="3-8-1-wide-addr-le"><a href="#3-8-1-wide-addr-le" class="headerlink" title="3.8.1 wide addr&amp;le"></a>3.8.1 wide addr&amp;le</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>	[C_AXI_ADDR_WIDTH-<span class="number">1</span>:<span class="number">0</span>]	cmd_addr;</span><br></pre></td></tr></table></figure>

<p>查看相关的代码。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wide_address, wide_length</span></span><br><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">	wide_address = <span class="number">0</span>;</span><br><span class="line">	wide_address[C_AXI_ADDR_WIDTH-<span class="number">1</span>:<span class="number">0</span>] = cmd_addr;</span><br><span class="line">	<span class="keyword">if</span> (!OPT_UNALIGNED)</span><br><span class="line">		wide_address[ADDRLSB-<span class="number">1</span>:<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	wide_length  = <span class="number">0</span>;</span><br><span class="line">	wide_length[ADDRLSB +: LGLENW] = cmd_length_w;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>这里需要再次回顾一些参数的相关表达：</p>
<ul>
<li><code>LGLEN</code>：这是一个参数，表示在一次传输中，可以传输的最大字节数的对数（以2为底）。在这个例子中，<code>LGLEN</code>的值为20，所以一次传输中可以传输的最大字节数为220，即1MB</li>
<li><code>LGLENW</code>：这是一个局部参数，可以进行多少次的全 <em>data_width_size</em> 传输，多少次 beat 传输</li>
<li><code>LGLENWA</code>：这是一个局部参数，可以允许分对齐传输，意义不明，暂时不了解</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Maximum number of bytes that can ever be transferred, in log-base 2</span></span><br><span class="line"><span class="comment">// 表达在一次 transfer 中，能传输的最大 byte数量</span></span><br><span class="line"><span class="keyword">parameter</span>		LGLEN  = <span class="number">20</span>,</span><br><span class="line"><span class="keyword">localparam</span>	LGLENW  = LGLEN  - (<span class="built_in">$clog2</span>(C_AXI_DATA_WIDTH)-<span class="number">3</span>),</span><br><span class="line">						LGLENWA = LGLENW + (OPT_UNALIGNED ? <span class="number">1</span>:<span class="number">0</span>);</span><br></pre></td></tr></table></figure>





<h1 id="4-state-address"><a href="#4-state-address" class="headerlink" title="4. state-address"></a>4. state-address</h1><p>所有的状态机如下：一共五个有效地址。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">localparam</span> [<span class="number">2</span>:<span class="number">0</span>]	</span><br><span class="line">			CMD_CONTROL   = <span class="number">3&#x27;b000</span>,</span><br><span class="line">			<span class="comment">// CMD_UNUSED_1  = 3&#x27;b001,</span></span><br><span class="line">			CMD_ADDRLO    = <span class="number">3&#x27;b010</span>,</span><br><span class="line">			CMD_ADDRHI    = <span class="number">3&#x27;b011</span>,</span><br><span class="line">			<span class="comment">// CMD_UNUSED_2  = 3&#x27;b100,</span></span><br><span class="line">			<span class="comment">// CMD_UNUSED_3  = 3&#x27;b101,</span></span><br><span class="line">			CMD_LENLO     = <span class="number">3&#x27;b110</span>,</span><br><span class="line">			CMD_LENHI     = <span class="number">3&#x27;b111</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 触发条件：必须是 <em>idle</em> 状态才能进行控制写。</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">     	<span class="comment">// no transaction is happening and </span></span><br><span class="line">     	<span class="comment">// there is a write operation</span></span><br><span class="line">	<span class="keyword">if</span> (axil_write_ready &amp;&amp; !r_busy)</span><br><span class="line">       <span class="keyword">begin</span></span><br><span class="line">         	<span class="comment">// swith in all valid address</span></span><br><span class="line">		<span class="keyword">case</span>(awskd_addr)</span><br></pre></td></tr></table></figure>



<h2 id="4-1-CMD-CONTROL"><a href="#4-1-CMD-CONTROL" class="headerlink" title="4.1   CMD_CONTROL"></a>4.1   CMD_CONTROL</h2><p>第一个地址的设置：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">localparam</span> [<span class="number">2</span>:<span class="number">0</span>]	 	CMD_CONTROL   = <span class="number">3&#x27;b000</span>,</span><br><span class="line"><span class="keyword">localparam</span>					CBIT_INCREMENT	= <span class="number">27</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><strong>[27]  !r_increment</strong> ：</li>
<li>If <strong>clear</strong>, the core reads from <strong>subsequent and incrementing</strong> addresses.  </li>
<li>If <strong>set</strong>, the core reads from the <strong>same</strong> address throughout a transaction. </li>
<li><code>Writes</code> to <code>CMD_CONTROL</code> while the core is <code>idle</code> will adjust this bit.</li>
<li>如果<code>!r_increment</code>为假（即<code>r_increment</code>为真），核心（core）会从连续并递增的地址中读取数据。这通常用于读取存储在连续内存地址中的数据，如数组。</li>
<li>如果<code>!r_increment</code>为真（即<code>r_increment</code>为假），核心会在整个事务过程中从同一地址读取数据。这通常用于读取存储在固定内存地址中的数据，如硬件寄存器。</li>
<li>当核心处于空闲状态时，对<code>CMD_CONTROL</code>的写操作会调整<code>r_increment</code>位。</li>
</ul>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span>(awskd_addr)</span><br><span class="line">CMD_CONTROL:</span><br><span class="line">	r_increment &lt;= !wskd_data[CBIT_INCREMENT];</span><br></pre></td></tr></table></figure>



<h2 id="4-2-CMD-ADDRLO"><a href="#4-2-CMD-ADDRLO" class="headerlink" title="4.2 CMD_ADDRLO"></a>4.2 CMD_ADDRLO</h2><h2 id="w-status-word"><a href="#w-status-word" class="headerlink" title="w_status_word"></a>w_status_word</h2><p>信号定义：  <code>reg [C_AXIL_DATA_WIDTH-1:0] w_status_word;</code> 已经知道 <em>axi-lite</em> 的 <em>data_bus_width</em> 是 <em>32 bits</em>。</p>
<p>在这一段有必要回顾这些信号的作用，请查看 <code>1.前言</code> 部分 [这里跳转](#1. 前言)。该部分应该是 <em>CPU</em> 通过 <em>read_transaction</em> 读取 <em>MM2S</em> 现在的 <em>status</em> 是什么状态。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	w_status_word = <span class="number">0</span>;</span><br><span class="line">	w_status_word[CBIT_BUSY]				= r_busy;</span><br><span class="line">	w_status_word[CBIT_ERR]					= r_err;</span><br><span class="line">	w_status_word[CBIT_COMPLETE]		= r_complete;</span><br><span class="line">	w_status_word[CBIT_CONTINUOUS]	= r_continuous;</span><br><span class="line">	w_status_word[CBIT_INCREMENT]		= !r_increment;</span><br><span class="line">	w_status_word[<span class="number">20</span>:<span class="number">16</span>] 						= LGFIFO;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="axil-read-data"><a href="#axil-read-data" class="headerlink" title="axil_read_data"></a>axil_read_data</h2><p>回顾信号定义如下，逻辑实现可以参考 <code>2. handle on AR</code></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>				axil_read_valid; <span class="comment">// if this signal equal to 1 ,means valid read request !</span></span><br></pre></td></tr></table></figure>

<p>实现的 <em>read_logic</em> 的相关代码。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// axil_read_data</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"> <span class="comment">// 	this &quot;if-state&quot; happens when there is no </span></span><br><span class="line"> <span class="comment">//	valid_before_ready situation in R channel</span></span><br><span class="line"><span class="keyword">if</span> (!axil_read_valid || S_AXIL_RREADY)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	axil_read_data &lt;= <span class="number">0</span>;</span><br><span class="line">   <span class="comment">// looking the read_address information , the address config is below :</span></span><br><span class="line">   <span class="comment">// 	localparam [2:0]	CMD_CONTROL   = 3&#x27;b000,</span></span><br><span class="line">	<span class="comment">//										CMD_ADDRLO    = 3&#x27;b010,</span></span><br><span class="line">	<span class="comment">//										CMD_ADDRHI    = 3&#x27;b011,</span></span><br><span class="line">	<span class="comment">//										CMD_LENLO     = 3&#x27;b110,</span></span><br><span class="line">	<span class="comment">//										CMD_LENHI     = 3&#x27;b111;</span></span><br><span class="line">	<span class="keyword">case</span>(arskd_addr)</span><br><span class="line">   <span class="comment">// 读取控制寄存器现在的 status 数据</span></span><br><span class="line">	CMD_CONTROL:	axil_read_data &lt;= w_status_word;</span><br><span class="line">   <span class="comment">// read the low  bits of address signal name wide_address</span></span><br><span class="line">   <span class="comment">// read the high bits of address signal name wide_address</span></span><br><span class="line">	CMD_ADDRLO:		axil_read_data &lt;= wide_address[	C_AXIL_DATA_WIDTH-<span class="number">1</span>:<span class="number">0</span>];</span><br><span class="line">	CMD_ADDRHI:		axil_read_data &lt;= wide_address[<span class="number">2</span>*C_AXIL_DATA_WIDTH-<span class="number">1</span>:C_AXIL_DATA_WIDTH];</span><br><span class="line">   <span class="comment">// read the low  bits of length signal name wide_length</span></span><br><span class="line">   <span class="comment">// read the high bits of length signal name wide_length</span></span><br><span class="line">	CMD_LENLO:		axil_read_data &lt;= wide_length[	C_AXIL_DATA_WIDTH-<span class="number">1</span>:<span class="number">0</span>];</span><br><span class="line">	CMD_LENHI:		axil_read_data &lt;= wide_length[<span class="number">2</span>*C_AXIL_DATA_WIDTH-<span class="number">1</span>:C_AXIL_DATA_WIDTH	];</span><br><span class="line">	<span class="keyword">default</span>				axil_read_data &lt;= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">endcase</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// if the parameter OPT_LOWPWER was set , every time the axil_read_ready siganl</span></span><br><span class="line">   <span class="comment">// from upstream_master , the axil_read_data must be zero</span></span><br><span class="line">	<span class="keyword">if</span> (OPT_LOWPOWER &amp;&amp; !axil_read_ready)</span><br><span class="line">		axil_read_data &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>在这个代码模块中我突然想清楚了为什么无论<em>address</em> 数据， 还是 <em>length</em> 数据都使用了统一的位宽长度—— <em>C_AXIL_DATA_WIDTH</em> 。因为这些数据都要通过 <em>axi-lite</em>协议进行读取，而 <em>axi-lite</em> 协议的数据读取最大只能是 <em>32bits</em> 的数据位宽。 </p>
<h1 id="5-Data-FIFO-section"><a href="#5-Data-FIFO-section" class="headerlink" title="5. Data -FIFO section"></a>5. Data -FIFO section</h1><h2 id="5-1-reset-fifo"><a href="#5-1-reset-fifo" class="headerlink" title="5.1 reset fifo"></a>5.1 reset fifo</h2><blockquote>
<ul>
<li><p><strong>[31]  r_busy</strong> : True if the core is in the middle of a transaction；</p>
</li>
<li><p><strong>[30]  r_err</strong> ： <strong>True</strong> if the core <u>has detected an error</u>, a bus error while the FIFO is reading. Writing a ‘1’ to this bit while the core is idle will <strong>clear</strong> it.  New transfers <strong><u>will not start until</u></strong> this bit is cleared.<em>当核心处于空闲状态时，向这个位写入’1’将会清除它，也就是将它设置为假（False）。只有当这个位被清除（设置为假）后，新的传输才会开始。</em></p>
</li>
<li><p><strong>[28]  r_continuous</strong> :</p>
<p><strong>Normally</strong> the FIFO gets cleared and reset between operations.</p>
<p>However, if you <strong>set</strong> r_continuous, <u><em>the core will then expect a second operation to take place following the first one</em>.</u> In this case, the operation will complete <u><em>but the FIFO won’t get cleared</em></u>.  <strong>During this time, the FIFO will not fill further</strong>.</p>
<p>Any write to the <code>CMD_CONTROL</code> register while the core is <strong>not</strong> busy will adjust this bit.</p>
<ul>
<li><code>r_continuous</code>：这是一个标志位，用于控制是否在操作之间清除和重置FIFO。</li>
<li>如果<code>r_continuous</code>为假，那么在每次操作之后，FIFO队列会被清除和重置。这是正常的操作模式。</li>
<li>如果<code>r_continuous</code>为真，那么核心（core）会期望在第一个操作完成后立即进行第二个操作。在这种情况下，第一个操作会完成，但FIFO队列不会被清除。<strong>在这段时间内，FIFO队列不会进一步填充</strong>。</li>
<li>当核心处于空闲状态时，对<code>CMD_CONTROL</code>寄存器的写操作会调整<code>r_continuous</code>位</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span>	reset_fifo = i_reset || (!r_busy &amp;&amp; (!r_continuous || r_err));</span><br></pre></td></tr></table></figure>

<p>如果输入复位信号<code>i_reset</code>为真，或者核心不忙碌且（不进行连续读取或检测到错误），那么<code>reset_fifo</code>将被设置为真。</p>
<h2 id="5-2-OPT-unaligned（略）"><a href="#5-2-OPT-unaligned（略）" class="headerlink" title="5.2 OPT_unaligned（略）"></a>5.2 OPT_unaligned（略）</h2><blockquote>
<p><strong>Purpose</strong> : Realign the data (if OPT_UNALIGN) before sending it to the FIFO.在发送数据到FIFO之前对数据进行重新对齐</p>
<p><strong>Desc</strong> : allows us to handle unaligned addresses.</p>
</blockquote>
<p>声明了一些寄存器和变量，用于存储一些状态和数据:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>													r_write_to_fifo;</span><br><span class="line"><span class="comment">// the data width is AXI protocol , not axi-lite</span></span><br><span class="line"><span class="keyword">reg</span>	[C_AXI_DATA_WIDTH-<span class="number">1</span>:<span class="number">0</span>]	last_data,</span><br><span class="line">														r_write_data;</span><br><span class="line"><span class="keyword">reg</span>	[ADDRLSB-<span class="number">1</span>:<span class="number">0</span>]						corollary_shift;</span><br><span class="line"><span class="keyword">reg</span>													last_valid;</span><br><span class="line"><span class="keyword">reg</span>	[ADDRLSB-<span class="number">1</span>:<span class="number">0</span>]						realignment;</span><br></pre></td></tr></table></figure>

<ul>
<li>将 <em>realignment</em> 的数值设置为地址的对齐偏移量</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line">    realignment = cmd_addr[ADDRLSB-<span class="number">1</span>:<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li><em>unaligned_cmd_addr</em> 是一个信号，表示这个地址是否是非对齐的</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>				unaligned_cmd_addr;</span><br></pre></td></tr></table></figure>

<p><strong>作用：</strong> <code>last_data</code> 的作用是在读取数据后，通过右移操作将数据重新对齐。这是因为外部总线可能从非对齐地址返回数据，而设计中的 FIFO 或其他存储器可能要求数据按照某种对齐方式进行存储。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	last_data = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">  <span class="comment">// if reset_fifo  or we detect that the address is aligned , </span></span><br><span class="line">  <span class="comment">// the last_data should be zero</span></span><br><span class="line"><span class="keyword">if</span> (reset_fifo || !unaligned_cmd_addr)</span><br><span class="line">	last_data &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (M_AXI_RVALID &amp;&amp; M_AXI_RREADY)</span><br><span class="line">   <span class="comment">// otherwise , </span></span><br><span class="line">	last_data &lt;= M_AXI_RDATA &gt;&gt; (realignment * <span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><font color="red">直接跳过unaligned 部分，这部分代码过分难以理解</font></p>
</li>
<li><p><font color="red">这部分代码直接浓缩为三行代码</font></p>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span>				realign_last_valid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">generate</span> <span class="keyword">if</span> (OPT_UNALIGNED)</span><br><span class="line">	<span class="keyword">begin</span> : REALIGN_DATA</span><br><span class="line">	<span class="comment">/////</span></span><br><span class="line">  <span class="comment">// get rid of this</span></span><br><span class="line">	<span class="comment">/////</span></span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span> : ALIGNED_DATA</span><br><span class="line">		<span class="comment">// the R channel handshake , means wrtie to FIFO</span></span><br><span class="line">		<span class="keyword">assign</span>	write_to_fifo  = M_AXI_RVALID &amp;&amp; M_AXI_RREADY;</span><br><span class="line">    <span class="comment">// the RDATA from AXI channel is the data which should be writen to the FIFO</span></span><br><span class="line">		<span class="keyword">assign</span>	write_data = M_AXI_RDATA;</span><br><span class="line">    <span class="comment">// this signal maybe we don&#x27;t need to care about it</span></span><br><span class="line">		<span class="keyword">assign</span>	realign_last_valid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">endgenerate</span></span><br><span class="line">	<span class="comment">// &#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="5-3-some-middle-signal"><a href="#5-3-some-middle-signal" class="headerlink" title="5.3 some middle signal"></a>5.3 some middle signal</h2><p><em>go back and check the stream interface</em>:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The stream interface</span></span><br><span class="line"><span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">wire</span>														M_AXIS_TVALID,</span><br><span class="line"><span class="keyword">input</span>		<span class="keyword">wire</span>														M_AXIS_TREADY,</span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">wire</span>	[C_AXI_DATA_WIDTH-<span class="number">1</span>:<span class="number">0</span>]		M_AXIS_TDATA,</span><br><span class="line"><span class="keyword">output</span>	<span class="keyword">wire</span>														M_AXIS_TLAST,</span><br><span class="line"><span class="comment">// &#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>If the handshake happens in the <u><em>stream interface</em></u> (e.g. <code>TVALID &amp;&amp; TREADY</code>) , which means a valid <em><u>read request from fifo</u></em>.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FIFO signals</span></span><br><span class="line"><span class="keyword">wire</span>				reset_fifo, </span><br><span class="line">						write_to_fifo,</span><br><span class="line">						read_from_fifo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span>	read_from_fifo = M_AXIS_TVALID &amp;&amp; M_AXIS_TREADY;</span><br></pre></td></tr></table></figure>

<p>Now , let’s check that how to generate the two signals named <u><code>M_AXIS_TAVALID</code> and <code>M_AXIS_TREADY</code>  separately</u>.   The signal <code>TVALID</code>  is depend on the fifo signal <code>fifo_empty</code>  . If there have data in fifo (e.g. <em><u>the signal fifo_empty is not zero</u></em>) , the siganl <code>TVALID</code> should be <em><strong>asserted</strong></em> to tell the downstream_compont that there are still data need to be transfered !</p>
<h2 id="5-4-write2fifo"><a href="#5-4-write2fifo" class="headerlink" title="5.4 write2fifo"></a>5.4 write2fifo</h2><p>firstly , you should look back to the parameter named <code>OPT_TLAST</code>, the defination is below :</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OPT_TLAST: If enabled, will embed TLAST=1 at the end of every</span></span><br><span class="line"><span class="comment">// commanded burst.  If  disabled, TLAST will be set to a</span></span><br><span class="line"><span class="comment">// constant 1&#x27;b1.</span></span><br><span class="line">		<span class="keyword">parameter</span> [<span class="number">0</span>:<span class="number">0</span>]	OPT_TLAST = <span class="number">1&#x27;b0</span>,</span><br></pre></td></tr></table></figure>



<p>如果我们像要简化 <em>axi address</em> ，可以简化 <em>last</em> 信号，让每个有效信号都带有 <em>last assert</em>，这样就可以不用一直计算什么时候是最后一个数据。首先，启动 <code>OPT_LAST</code> 的部分：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write the results to the FIFO</span></span><br><span class="line"><span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line"><span class="keyword">generate</span> <span class="keyword">if</span> (OPT_TLAST)</span><br><span class="line"><span class="keyword">begin</span> : FIFO_W_TLAST</span><br><span class="line">	<span class="comment">// FIFO section--used if we have to add a TLAST signal to the</span></span><br><span class="line">	<span class="comment">// data stream</span></span><br><span class="line">	<span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line">	<span class="keyword">reg</span>	pre_tlast;</span><br><span class="line">	<span class="keyword">wire</span>	tlast;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>tlast</code> will be set on the <u><em>last data word</em></u> of any commanded burst.</p>
<p>Appropriately, <code>pre_tlast = (something) &amp;&amp; M_AXI_RVALID &amp;&amp; M_AXI_RREADY &amp;&amp; M_AXI_RLAST</code>. </p>
<ul>
<li>We can simplify this greatly, since any time <code>M_AXI_RVALID</code> is true, we also know that <code>M_AXI_RREADY</code> will be true.  This allows us to get rid of the <code>RREADY</code> condition.  </li>
<li>Next, we can simplify the <code>RVALID</code> condition since we’ll never write to the <code>FIFO</code> if <code>RVALID</code> isn’t also true.  </li>
<li>Finally, we can get rid of <code>M_AXI_RLAST</code> since this is captured by <code>rd_last_remaining</code>.</li>
</ul>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line">	pre_tlast = rd_last_remaining;</span><br></pre></td></tr></table></figure>

<p><strong><font color="orange">这部分不理解</font></strong></p>
<h2 id="5-5-sfifo"><a href="#5-5-sfifo" class="headerlink" title="5.5 sfifo"></a>5.5 sfifo</h2><h1 id="6-full-axi-protocol"><a href="#6-full-axi-protocol" class="headerlink" title="6. full axi protocol"></a>6. full axi protocol</h1><p>we need some counter to keep track of our state.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Speed up checking for zeros</span></span><br><span class="line"><span class="keyword">reg</span>				ar_none_remaining,</span><br><span class="line">					ar_none_outstanding,</span><br><span class="line">					phantom_start, start_burst;</span><br><span class="line"><span class="keyword">reg</span>				ar_multiple_full_bursts,</span><br><span class="line">					ar_multiple_fixed_bursts,</span><br><span class="line">					ar_multiple_bursts_remaining,</span><br><span class="line">					ar_needs_alignment;</span><br><span class="line"><span class="keyword">wire</span>			partial_burst_requested;</span><br><span class="line"><span class="keyword">reg</span>	[LGMAXBURST-<span class="number">1</span>:<span class="number">0</span>]	addralign;</span><br><span class="line"><span class="keyword">reg</span>	[LGFIFO:<span class="number">0</span>]				rd_uncommitted;</span><br><span class="line"><span class="keyword">reg</span>	[LGMAXBURST:<span class="number">0</span>]		initial_burstlen;</span><br><span class="line"><span class="keyword">reg</span>	[LGLENWA-<span class="number">1</span>:<span class="number">0</span>]			rd_reads_remaining;</span><br><span class="line"><span class="keyword">reg</span>										rd_none_remaining,</span><br><span class="line">											rd_last_remaining;</span><br><span class="line"></span><br><span class="line"><span class="keyword">wire</span>									realign_last_valid;</span><br></pre></td></tr></table></figure>



<h2 id="6-1-Write-left-to-be-requested"><a href="#6-1-Write-left-to-be-requested" class="headerlink" title="6.1 Write left to be requested"></a>6.1 Write left to be requested</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">冰蒂斯</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/12/06/MM2S/">http://example.com/2023/12/06/MM2S/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">冰蒂斯のformula</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/AXI/">AXI</a><a class="post-meta__tags" href="/tags/master/">master</a></div><div class="post_share"><div class="social-share" data-image="/img/chainsaw_red.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/12/09/AXIL-test-script/" title="AXIL_test_script"><img class="cover" src="/img/chainsaw_makima04.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">AXIL_test_script</div></div></a></div><div class="next-post pull-right"><a href="/2023/12/03/axi-master-fulllast/" title="axi_(full)master(下)"><img class="cover" src="/img/chainsaw_makima04.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">axi_(full)master(下)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/11/13/5-1-basic-master/" title="5-1 basic_master(上)"><img class="cover" src="/img/chainsaw_makima04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-13</div><div class="title">5-1 basic_master(上)</div></div></a></div><div><a href="/2023/11/15/5-1-1-basic-master/" title="5-1 basic_master(中)"><img class="cover" src="/img/chainsaw_makima04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-15</div><div class="title">5-1 basic_master(中)</div></div></a></div><div><a href="/2023/11/23/5-1-2-basic-master/" title="5-1 basic_master(下)"><img class="cover" src="/img/chainsaw_makima04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-23</div><div class="title">5-1 basic_master(下)</div></div></a></div><div><a href="/2023/11/18/Property-master/" title="Property_axil-master"><img class="cover" src="/img/chainsaw_makima04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-18</div><div class="title">Property_axil-master</div></div></a></div><div><a href="/2023/11/25/axi-master-full/" title="axi(full)master(上)"><img class="cover" src="/img/chainsaw_makima04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-25</div><div class="title">axi(full)master(上)</div></div></a></div><div><a href="/2023/12/27/S2MM/" title="S2MM"><img class="cover" src="/img/chainsaw_red.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-27</div><div class="title">S2MM</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">冰蒂斯</div><div class="author-info__description">螺旋上升的人生,也是多线程的人生</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">1. 前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-AXI-lite-signaling"><span class="toc-number">2.</span> <span class="toc-text">2. AXI-lite signaling</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-write-signaling"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 write signaling</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-double-skidbuffer"><span class="toc-number">2.1.1.</span> <span class="toc-text">1. double skidbuffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-align-AW-W"><span class="toc-number">2.1.2.</span> <span class="toc-text">2. align AW &amp; W</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-B-channel"><span class="toc-number">2.1.3.</span> <span class="toc-text">3. B channel</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-read-signaling"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 read signaling</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-skidbuffer"><span class="toc-number">2.2.1.</span> <span class="toc-text">1. skidbuffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-handle-on-AR"><span class="toc-number">2.2.2.</span> <span class="toc-text">2. handle on AR</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-AXI-lite-controlled-logic"><span class="toc-number">3.</span> <span class="toc-text">3. AXI-lite controlled logic</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-abort-transaction"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 abort transaction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Start-command"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 Start command</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Calculate-busy-or-complete-flags"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 Calculate busy or complete flags</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-Interrupt"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 Interrupt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-ERR-condition"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 ERR condition</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-r-continuous"><span class="toc-number">3.6.</span> <span class="toc-text">3.6 r_continuous</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-apply-wstrb"><span class="toc-number">3.7.</span> <span class="toc-text">3.7 apply_wstrb</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-address-length"><span class="toc-number">3.8.</span> <span class="toc-text">3.8 address &amp; length</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-1-wide-addr-le"><span class="toc-number">3.8.1.</span> <span class="toc-text">3.8.1 wide addr&amp;le</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-state-address"><span class="toc-number">4.</span> <span class="toc-text">4. state-address</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-CMD-CONTROL"><span class="toc-number">4.1.</span> <span class="toc-text">4.1   CMD_CONTROL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-CMD-ADDRLO"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 CMD_ADDRLO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#w-status-word"><span class="toc-number">4.3.</span> <span class="toc-text">w_status_word</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#axil-read-data"><span class="toc-number">4.4.</span> <span class="toc-text">axil_read_data</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Data-FIFO-section"><span class="toc-number">5.</span> <span class="toc-text">5. Data -FIFO section</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-reset-fifo"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 reset fifo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-OPT-unaligned%EF%BC%88%E7%95%A5%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 OPT_unaligned（略）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-some-middle-signal"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 some middle signal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-write2fifo"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 write2fifo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-sfifo"><span class="toc-number">5.5.</span> <span class="toc-text">5.5 sfifo</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-full-axi-protocol"><span class="toc-number">6.</span> <span class="toc-text">6. full axi protocol</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-Write-left-to-be-requested"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 Write left to be requested</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/01/07/skid-buffer/" title="skid_buffer"><img src="/img/chainsaw_power01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="skid_buffer"/></a><div class="content"><a class="title" href="/2024/01/07/skid-buffer/" title="skid_buffer">skid_buffer</a><time datetime="2024-01-07T12:48:03.000Z" title="发表于 2024-01-07 20:48:03">2024-01-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/06/how2blog/" title="how2blog"><img src="/img/reze.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="how2blog"/></a><div class="content"><a class="title" href="/2024/01/06/how2blog/" title="how2blog">how2blog</a><time datetime="2024-01-06T14:34:23.000Z" title="发表于 2024-01-06 22:34:23">2024-01-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/27/S2MM/" title="S2MM"><img src="/img/chainsaw_red.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="S2MM"/></a><div class="content"><a class="title" href="/2023/12/27/S2MM/" title="S2MM">S2MM</a><time datetime="2023-12-27T05:57:36.000Z" title="发表于 2023-12-27 13:57:36">2023-12-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/24/auto2-using/" title="auto2-using"><img src="/img/chainsaw_makima04.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="auto2-using"/></a><div class="content"><a class="title" href="/2023/12/24/auto2-using/" title="auto2-using">auto2-using</a><time datetime="2023-12-24T14:17:24.000Z" title="发表于 2023-12-24 22:17:24">2023-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/12/auto1-introduction/" title="auto1_introduction"><img src="/img/flower.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="auto1_introduction"/></a><div class="content"><a class="title" href="/2023/12/12/auto1-introduction/" title="auto1_introduction">auto1_introduction</a><time datetime="2023-12-12T06:18:40.000Z" title="发表于 2023-12-12 14:18:40">2023-12-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 冰蒂斯</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>