<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>S2MM | 冰蒂斯のformula</title><meta name="author" content="冰蒂斯"><meta name="copyright" content="冰蒂斯"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. first you should read Filename: axis2mm Purpose:  Converts an AXI-stream (input) to an AXI (full) memory interface.  1.1 register address这里的寄存器地址按照下面的分布：  X00-03 (4&#39;b0000-0011):CMD_CONTROL regi">
<meta property="og:type" content="article">
<meta property="og:title" content="S2MM">
<meta property="og:url" content="http://example.com/2023/12/27/S2MM/index.html">
<meta property="og:site_name" content="冰蒂斯のformula">
<meta property="og:description" content="1. first you should read Filename: axis2mm Purpose:  Converts an AXI-stream (input) to an AXI (full) memory interface.  1.1 register address这里的寄存器地址按照下面的分布：  X00-03 (4&#39;b0000-0011):CMD_CONTROL regi">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/chainsaw_red.jpg">
<meta property="article:published_time" content="2023-12-27T05:57:36.000Z">
<meta property="article:modified_time" content="2024-01-08T06:10:17.564Z">
<meta property="article:author" content="冰蒂斯">
<meta property="article:tag" content="AXI">
<meta property="article:tag" content="master">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/chainsaw_red.jpg"><link rel="shortcut icon" href="/img/bloodborn_lib.png"><link rel="canonical" href="http://example.com/2023/12/27/S2MM/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'S2MM',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-08 14:10:17'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/reze.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="冰蒂斯のformula"><span class="site-name">冰蒂斯のformula</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">S2MM</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-27T05:57:36.000Z" title="发表于 2023-12-27 13:57:36">2023-12-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-08T06:10:17.564Z" title="更新于 2024-01-08 14:10:17">2024-01-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/AXI/">AXI</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/AXI/master/">master</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="S2MM"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-first-you-should-read"><a href="#1-first-you-should-read" class="headerlink" title="1. first you should read"></a>1. first you should read</h1><blockquote>
<p><code>Filename</code>: <em><u>axis2mm</u></em></p>
<p><code>Purpose</code>:  <em><u>Converts an AXI-stream (input) to an AXI (full) memory interface.</u></em></p>
</blockquote>
<h2 id="1-1-register-address"><a href="#1-1-register-address" class="headerlink" title="1.1 register address"></a>1.1 register address</h2><p>这里的寄存器地址按照下面的分布：</p>
<ul>
<li><p><code>X00-03 (4&#39;b0000-0011)</code>:<em>CMD_CONTROL register</em>，有 <em>32bits(4 bytes)</em> 的数据</p>
</li>
<li><p><code>x04-0c (4&#39;b0100-1100)</code>: <em>(Unused and reserved)</em></p>
</li>
<li><p><code>x10-14 (5&#39;b1_0000-1_0100)</code>: <em>CMD_ADDR</em> , 将会读写的地址是什么，由 <em>axi-lite</em> 来控制</p>
</li>
<li><p><code>x18-1c (5&#39;b1_1000-1_1100)</code>  :  <em>CMD_LEN ，the size of the transfer in bytes</em>.</p>
</li>
</ul>
<blockquote>
<p><code>CMD_ADDR：[C_AXI_ADDR_WIDTH-1:($clog2(C_AXI_DATA_WIDTH)-3)]</code></p>
<p>If <code>idle</code>, this is <em><u><strong>address the core will write to</strong></u></em> when it <u><em><strong>starts</strong></em></u>. </p>
<p>If <code>busy</code>, this is the <u><em>address</em></u> of <u><em><strong>either the current or next address the core will request writing to</strong></em></u>. </p>
<p>Upon <code>completion</code>, the address either <font color="red"><u><em>returns to the starting address</em></u> </font>(if r_continuous is clear), or otherwise becomes the address where the core left off.  In the case of an abort or an error, this will be (near) the address that was last written.</p>
<p>Why “near”?  Because this address records the writes that have been issued while no error is pending.  If a bus error return comes back, there may have been several writes issued before that error address.  Likewise if an overflow is detected, the data associated with the overflow may have already been somewhat written–the AXI bus doesn’t stop on a dime.</p>
</blockquote>
<ul>
<li><p><strong>[26]  ! tlast_syncd</strong></p>
<p><u><em><strong>Read only status indicator</strong></em></u>.  </p>
<p>Reads 0 if <code>OPT_TLAST_SYNC</code> isn’t set.  If <code>OPT_TLAST_SYNC</code> is set, then this bit indicates whether or not the memory transfer is currently aligned with any stream packets, or whether it is out of synchronization and waiting to sync with the incoming stream.  (只读状态指示器的。如果 <code>OPT_TLAST_SYNC</code> 没有被设置，那么这个状态指示器的值为0。如果 <code>OPT_TLAST_SYNC</code> 被设置了，那么这个位就会指示内存传输是否与任何流数据包对齐，或者它是否处于非同步状态并等待与传入流同步。)</p>
<p>If the IP is <u><em>out of alignment</em></u> and <code>OPT_TLAST_SYNC</code> is set, then the core will synchronize itself automatically by <u><em><strong>holding <code>TREADY</code> high</strong></em></u> and *<u><strong>ignoring data until the first sample after <code>TLAST</code></strong></u>*.</p>
</li>
</ul>
<p><font color="red">如何使用这个功能，需要在后续的过程中不断实践</font>&#x2F;&#x2F;      until the first sample after TLAST.</p>
<ul>
<li><p><strong>[27]   ! r_increment</strong> ：</p>
<p>If <strong>clear</strong>, the core writes to <u><em><strong>subsequent and incrementing addresses</strong></em></u>–the normal copy to memory case.  If <code>!r_increment</code> is <strong>set</strong>, the core writes to the same address throughout the transaction.  This is useful if you want to <u><em><strong>copy data to a FIFO</strong></em></u> or <strong><u><em>other device living at a single address</em></u></strong> in the memory map.</p>
<p><u><em><strong>Writes to <code>CMD_CONTROL</code> while the core is idle will adjust this bit</strong></em></u>.</p>
</li>
<li><p><strong>[20:16]  LGFIFO</strong></p>
<p>These are <u><em>read-only</em></u> bits, <u><em>returning the size</em></u> of the FIFO.</p>
<blockquote>
<p>The size of the FIFO, <u>log-based two</u>.  Hence <code>LGFIFO=9</code> gives you a FIFO of size <code>2^(LGFIFO)</code> or 512 elements.  This is about as big as the FIFO should ever need to be, since AXI bursts can be 256 in length. <code>parameter   LGFIFO = 9</code>.</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="1-2-parameter"><a href="#1-2-parameter" class="headerlink" title="1.2 parameter"></a>1.2 parameter</h2><p><u><em><strong>parameter</strong></em></u> 参数设置</p>
<ul>
<li><p><code>parameter LGFIFO = 9</code>：</p>
<p><u><em><strong>The size of the FIFO, log-based two</strong></em></u>.  Hence <code>LGFIFO=9</code> gives you a FIFO of size <code>2^(LGFIFO)</code> or <code>512</code> elements.  This is about <u><em>as big as the FIFO should ever need to be, since AXI bursts can be 256 in length</em></u>.</p>
<p>如果 <em>FIFO</em> 的长度大于 <code>8</code>，那么 <em>FIFO</em> 最大可以容纳长度为 <em>256</em> 的 <em>burst transfer</em>。否则，一次 <em>burst</em> 最大传输 <em>size</em>就只能是 <code>FIFO_SIZE - 1 </code>。</p>
</li>
<li><p><code>parameter [0:0]   OPT_TREADY_WHILE_IDLE = 1</code>:</p>
</li>
</ul>
<p>  <code>OPT_TREADY_WHILE_IDLE</code> controls how the stream <strong>idle</strong> is set when the memory copy isn’t running.  </p>
<ul>
<li><p>If <code>1</code>, then <code>TREADY</code> will be <code>1</code> and the core will <u><em><strong>ignore&#x2F;throw out data when the core isn’t busy</strong></em></u>.  </p>
</li>
<li><p>Otherwise, if this is set to <code>0</code>, the core will <em><strong>force the stream to stall</strong></em> if ever no data is being copied</p>
<p>如何控制在内存复制未运行时流空闲的设置。如果 <code>OPT_TREADY_WHILE_IDLE</code> 的值为1，那么 <code>TREADY</code> 将被设置为1，当核心不忙时，核心将忽略或丢弃数据。否则，如果 <code>OPT_TREADY_WHILE_IDLE</code> 的值为0，那么如果没有数据被复制，核心将强制流暂停。</p>
</li>
</ul>
<hr>
<h2 id="1-3-localparam"><a href="#1-3-localparam" class="headerlink" title="1.3 localparam"></a>1.3 localparam</h2><p><u><strong>localparam</strong></u> 参数设置：</p>
<ul>
<li><p><code>TMP_LGMAXBURST</code>：</p>
<p>The maximum burst size is <u><em><strong>either 256, or half the FIFO size</strong></em></u>, whichever is smaller. 这个参数是最大突发大小的临时值。它的值取决于FIFO的大小（<code>LGFIFO</code>）。如果<code>LGFIFO</code>大于8，那么<code>TMP_LGMAXBURST</code>就等于8，否则等于<code>LGFIFO-1</code>。这意味着最大突发大小要么是256（即28），要么是FIFO大小的一半，取较小者;（至于这里为什么是 <em>FIFO_size</em> 的一半，因为 <em>fifo</em>地址的最高位不会使用，只是一个标志位 <em>flag</em> 参数 )</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">localparam</span>	TMP_LGMAXBURST=(LGFIFO &gt; <span class="number">8</span>) ? <span class="number">8</span> : LGFIFO-<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>LGMAXBURST</code>：</p>
<p>首先计算 <code>4KB</code>大小数据是多少次 <code>C_AXI_DATA_WIDTH/8</code>位宽的数据 <em>transfer</em>。将这个数值，和 <em>FIFO</em> 能够支持的最大 *burst length (e.g. <u>*<em>1&lt;&lt;TMP_LGMAXBURST**</u> )</em> 进行比较。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">localparam</span>	LGMAXBURST = </span><br><span class="line">			((<span class="number">4096</span> / (C_AXI_DATA_WIDTH / <span class="number">8</span>))  &gt; (<span class="number">1</span>&lt;&lt;TMP_LGMAXBURST))? </span><br><span class="line">				<span class="comment">// if greater :</span></span><br><span class="line">				<span class="comment">//		we can use TMP_LGMAXBURST to be our max burst length</span></span><br><span class="line">				TMP_LGMAXBURST : </span><br><span class="line">				<span class="comment">// if not:</span></span><br><span class="line">				<span class="comment">//		the FIFO_size is too big , </span></span><br><span class="line">				<span class="built_in">$clog2</span>(<span class="number">4096</span> * <span class="number">8</span> / C_AXI_DATA_WIDTH);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>LGMAX_FIXED_BURST</code>：</p>
<p><em>axilite fixed address burst</em> 的 <em>data width</em> 限制为 <code>1,2,4,8,16</code>，如果大于 <code>2^4</code>那么最大的<em>fixed_burst_len</em> 只能是 <code>4</code>，否则只能更小。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">localparam</span>	MAX_FIXED_BURST = (<span class="number">1</span>&lt;&lt;LGMAX_FIXED_BURST);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="2-axis-skidbuffer"><a href="#2-axis-skidbuffer" class="headerlink" title="2. axis skidbuffer"></a>2. axis skidbuffer</h1><p>这里进行了一个选项： <code>formal or not</code>，如果选择了 <em>formal</em> 那么<em>stream interface</em>将会表现为 <em>passthrough</em>，如果选择<em>not fomrmal</em> 那么就会在 <em>interface</em> 使用 <em>skidbuffer module</em>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">ifdef</span>	FORMAL</span></span><br><span class="line">	<span class="keyword">assign</span>	sskd_valid    = S_AXIS_TVALID;</span><br><span class="line">	<span class="keyword">assign</span>	S_AXIS_TREADY = sskd_ready;</span><br><span class="line">	<span class="keyword">assign</span>	sskd_user     = (C_AXIS_TUSER_WIDTH &gt; <span class="number">0</span>) ? S_AXIS_TUSER : <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">assign</span>	sskd_data     = S_AXIS_TDATA;</span><br><span class="line">	<span class="keyword">assign</span>	sskd_last     = S_AXIS_TLAST;</span><br><span class="line"><span class="meta">`<span class="keyword">else</span></span></span><br></pre></td></tr></table></figure>

<p>如果使用了 <em>skidbuffer</em> 那么代码逻辑如下：</p>
<ul>
<li><code>OPT_AXIS_SKIDREGISTER</code> : <em>OPT_AXIS_SKIDREGISTER</em> will force the outputs of the skid buffer to be <em><u>registered</u></em>.  This is something you would do primarily <em><u>if you are trying to hit high speeds through this core</u></em>.</li>
<li><code>DW</code> : 传输的数据包括了三个部分，<code>C_AXI_DATA_WIDTH</code>表示传输的数据位宽， <code>1 bit</code> 表示传输的 <em>TLAST</em> 数据， 如果<em>tusr_width</em> 的位宽大于 <code>0</code>，那么增加 <em>user</em> 的数据位宽；</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">	skidbuffer #(</span><br><span class="line">		<span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line">		<span class="variable">.OPT_OUTREG</span>(OPT_AXIS_SKIDREGISTER),</span><br><span class="line">    <span class="variable">.DW</span>(C_AXI_DATA_WIDTH + <span class="number">1</span> + </span><br><span class="line">       ((C_AXIS_TUSER_WIDTH &gt; <span class="number">0</span>) ? C_AXIS_TUSER_WIDTH:<span class="number">1</span>)),</span><br><span class="line">		<span class="variable">.OPT_LOWPOWER</span>(OPT_LOWPOWER),</span><br><span class="line">		<span class="variable">.OPT_PASSTHROUGH</span>(!OPT_AXIS_SKIDBUFFER)</span><br><span class="line">		<span class="comment">// &#125;&#125;&#125;</span></span><br><span class="line">	) skd_stream(</span><br><span class="line">		<span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line">		<span class="variable">.i_clk</span>(S_AXI_ACLK), </span><br><span class="line">    <span class="variable">.i_reset</span>(reset_fifo),</span><br><span class="line">		<span class="variable">.i_valid</span>(S_AXIS_TVALID), </span><br><span class="line">    <span class="variable">.o_ready</span>(S_AXIS_TREADY),</span><br><span class="line">		<span class="variable">.i_data</span>(&#123; S_AXIS_TUSER, S_AXIS_TDATA, S_AXIS_TLAST &#125;),</span><br><span class="line">		<span class="variable">.o_valid</span>(sskd_valid),</span><br><span class="line">    <span class="variable">.i_ready</span>(sskd_ready),</span><br><span class="line">		<span class="variable">.o_data</span>(&#123; sskd_user, sskd_data, sskd_last &#125;)</span><br><span class="line">		<span class="comment">// &#125;&#125;&#125;</span></span><br><span class="line">	);</span><br><span class="line"><span class="meta">`<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h1 id="3-axi-lite-signaling"><a href="#3-axi-lite-signaling" class="headerlink" title="3. axi-lite signaling"></a>3. axi-lite signaling</h1><blockquote>
<p><strong>Purpose</strong>:  This is mostly the <em><u>skidbuffer logic</u></em>, and handling of the <em><u>VALID and READY</u></em> signals for the <em><u>AXI-lite control logic</u></em> in the next section.</p>
</blockquote>
<p>​					<strong>(Fig 8. Buffer all three incoming channels)</strong></p>
<img src="https://zipcpu.com/img/easyaxil/skidslave.svg" alt="img" style="zoom: 50%;" />

<p>​								<strong>Fig 4. Backpressure</strong></p>
<img src="https://zipcpu.com/img/easyaxil/backpressure.png" alt="img" style="zoom:50%;" />

<h2 id="3-1-Write-signaling"><a href="#3-1-Write-signaling" class="headerlink" title="3.1  Write signaling"></a>3.1  Write signaling</h2><h3 id="1-AW-W-channel-signal"><a href="#1-AW-W-channel-signal" class="headerlink" title="1. AW W channel signal"></a>1. AW W channel signal</h3><p>分为 <code>AW</code> ，<code>W</code>   two channel ：</p>
<ul>
<li><code>DW (C_AXIL_ADDR_WIDTH-AXILLSB)</code> :  传输的地址由 <em>base on bytes</em> 转换为 <em>base on bus_data_width</em> </li>
<li><code>S_AXIL_AWVALID</code> 和  <code>S_AXIL_AWREADY</code> 两个信号是 <em>axi-lite interface</em> 信号</li>
<li><code>awskd_valid</code> 和 <code>axil_write_ready</code> 两个信号来是 <em>component</em> 的 <em>internal signal</em>， <em>awskd_valid</em> 来自于 <em>upstream</em>由外部控制， <em>axil_write_ready</em> 来自于内部逻辑控制。</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">skidbuffer #(</span><br><span class="line">	<span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line">	<span class="variable">.OPT_OUTREG</span>(<span class="number">0</span>), </span><br><span class="line">	<span class="variable">.DW</span>(C_AXIL_ADDR_WIDTH-AXILLSB),</span><br><span class="line">	<span class="variable">.OPT_LOWPOWER</span>(OPT_LOWPOWER)</span><br><span class="line">	<span class="comment">// &#125;&#125;&#125;</span></span><br><span class="line">) axilawskid(</span><br><span class="line">	<span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line">	<span class="variable">.i_clk</span>(S_AXI_ACLK), </span><br><span class="line">	<span class="variable">.i_reset</span>(i_reset),</span><br><span class="line">	<span class="variable">.i_valid</span>(S_AXIL_AWVALID), </span><br><span class="line">	<span class="variable">.o_ready</span>(S_AXIL_AWREADY),</span><br><span class="line">	<span class="variable">.i_data</span>(S_AXIL_AWADDR[C_AXIL_ADDR_WIDTH-<span class="number">1</span>:AXILLSB]),</span><br><span class="line">	<span class="variable">.o_valid</span>(awskd_valid), </span><br><span class="line">	<span class="variable">.i_ready</span>(axil_write_ready),</span><br><span class="line">	<span class="variable">.o_data</span>(awskd_addr)</span><br><span class="line">	<span class="comment">// &#125;&#125;&#125;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>使用在 <em>W channel</em> 的 <em>skidbuffer</em> ，需要一同传输 <em>write_data</em> 以及相应的 <em>write_data_strobe</em> 。 <em>valid &amp; ready</em> 信号和 <em>AW</em> 相同。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">skidbuffer #(</span><br><span class="line">	<span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line">	<span class="variable">.OPT_OUTREG</span>(<span class="number">0</span>), </span><br><span class="line">   <span class="variable">.DW</span>(C_AXIL_DATA_WIDTH+C_AXIL_DATA_WIDTH/<span class="number">8</span>),</span><br><span class="line">	<span class="variable">.OPT_LOWPOWER</span>(OPT_LOWPOWER)</span><br><span class="line">	<span class="comment">// &#125;&#125;&#125;</span></span><br><span class="line">) axilwskid(</span><br><span class="line">	<span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line">	<span class="variable">.i_clk</span>(S_AXI_ACLK), </span><br><span class="line">   <span class="variable">.i_reset</span>(i_reset),</span><br><span class="line">	<span class="variable">.i_valid</span>(S_AXIL_WVALID), </span><br><span class="line">   <span class="variable">.o_ready</span>(S_AXIL_WREADY),</span><br><span class="line">	<span class="variable">.i_data</span>(&#123; S_AXIL_WDATA, S_AXIL_WSTRB &#125;),</span><br><span class="line">	<span class="variable">.o_valid</span>(wskd_valid), </span><br><span class="line">   <span class="variable">.i_ready</span>(axil_write_ready),</span><br><span class="line">	<span class="variable">.o_data</span>(&#123; wskd_data, wskd_strb &#125;)</span><br><span class="line">	<span class="comment">// &#125;&#125;&#125;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h3 id="2-ready-bvalid-logic"><a href="#2-ready-bvalid-logic" class="headerlink" title="2. ready &amp; bvalid logic"></a>2. ready &amp; bvalid logic</h3><p><em>write_ready_signal</em> 信号需要使用两个部分：</p>
<ul>
<li><p><strong><font color="red"><em>axi-lite</em> 的 <em>AW</em> 、 <em>W</em>  通道的信号需要被同步( <em>synchronized</em> )</font></strong> :only skidbuffer internal siganls awskd_valid and wskd_valid both are asserted* , <em>write_ready signal can be asserted</em>  . </p>
</li>
<li><p><em><em><font color="red">no <em><u>valid before ready</u></em> situation happens in <em><u>B channel</u></em></font></em>* :  <em>axi-lite potocol</em> 要求 <em>master</em> 在发出一次 <em>request</em> 之后，必须接受 <em>salve</em> 端发出的 <em>bvalid</em> 才能第二次发出*request</em> ，所以需要查看  <em><u>B channel</u></em> 是否有 <em>B_valid_data</em> 还没有发出去,如果没有不能 <em>assert the write_ready_signal to accept the new request from master</em>.</p>
</li>
</ul>
<blockquote>
<p>Then we’ll <strong><u><em>accept</em></u></strong> a write request (and unstall the skid buffers above) any time there’s both a <em><u><strong>write address and write data available</strong></u></em>. </p>
<p>That is, unless the outgoing interface is <u><em><strong>stalled</strong></em></u>.</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span>	axil_write_ready = clk_active </span><br><span class="line">							&amp;&amp; awskd_valid &amp;&amp; wskd_valid</span><br><span class="line">							&amp;&amp; (!S_AXIL_BVALID || S_AXIL_BREADY);  </span><br></pre></td></tr></table></figure>

<p>关于 <em>B_valid</em> 信号表现如下：</p>
<ul>
<li><p><strong><font color="red">when to assert signal axil_valid ?</font></strong> : when there is request from master (e.g. <em><u>awvalid &amp; wvalid</u></em>) and <em><u>no valid before ready situation</u></em> happens in B channel (e.g. <em><u>no stall</u></em> ) , the <code>axil_bvalid</code> signel will be asserted next clock (e.g. <em>return response in one clock cycle</em>)</p>
</li>
<li><p><strong><font color="red">what happens if BREADY is high ?</font></strong>: once <code>BREADY</code> is high , there is no <em>new_valid_request</em> will be sent from master , this is <em><u>limited by axi-lite protocol</u></em> ! axi-lite。协议必须要求 <em>ready</em> 信号有起伏的变化，<em>ready</em> 信号一旦被拉高并且发生了 handshake （e.g. *<u>valid &amp; ready &#x3D;&#x3D; 1</u>*）, <em>ready</em> 信号第二次被拉高之前必须维持最少一个时钟周期的 <em>low status</em> 。</p>
<p><strong>更正：上面的解释有错。详情请参考 read_valid logic 这部分的解释[跳转](#2. Read_valid logic)</strong></p>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	axil_bvalid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (i_reset)</span><br><span class="line">	axil_bvalid &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (axil_write_ready)</span><br><span class="line">	axil_bvalid &lt;= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (S_AXIL_BREADY)</span><br><span class="line">	axil_bvalid &lt;= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span>	S_AXIL_BVALID = axil_bvalid;</span><br><span class="line"><span class="keyword">assign</span>	S_AXIL_BRESP = <span class="number">2&#x27;b00</span>;</span><br></pre></td></tr></table></figure>

<p>​								<strong>(Fig 5. 100% Write throughput)</strong></p>
<img src="https://zipcpu.com/img/easyaxil/writeskd-stalled.svg" alt="img" style="zoom:67%;" />

<blockquote>
<p>You’ll notice that certain values <u><em><strong>disappear for a time</strong></em></u>. </p>
<p>For example, the <code>A0</code> (white) value <strong><u><em>vanished</em></u></strong> for a clock period <strong><u><em>before</em></u></strong> the <u><em><strong>white</strong></em></u> <code>BVALID</code> response was generated. Similarly, the brown <code>A2</code> and <code>D2</code> values vanished while the yellow <code>BVALID</code> output was stalled. Those values were maintained for us within the skid buffers–making sure that we didn’t lose them in spite of the fact that the various interfaces have stalled.</p>
</blockquote>
<h2 id="3-2-Read-signaling"><a href="#3-2-Read-signaling" class="headerlink" title="3.2  Read signaling"></a>3.2  Read signaling</h2><h3 id="1-AR-channel"><a href="#1-AR-channel" class="headerlink" title="1. AR channel"></a>1. AR channel</h3><p><code>DW (C_AXIL_ADDR_WIDTH-AXILLSB)</code> :  传输的地址由 <em>base on bytes</em> 转换为 <em>base on bus_data_width</em> </p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">skidbuffer #(</span><br><span class="line">	<span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line">	<span class="variable">.OPT_OUTREG</span>(<span class="number">0</span>), </span><br><span class="line">   <span class="variable">.DW</span>(C_AXIL_ADDR_WIDTH-AXILLSB),</span><br><span class="line">	<span class="variable">.OPT_LOWPOWER</span>(OPT_LOWPOWER)</span><br><span class="line">	<span class="comment">// &#125;&#125;&#125;</span></span><br><span class="line">) axilarskid(</span><br><span class="line">	<span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line">	<span class="variable">.i_clk</span>(S_AXI_ACLK), </span><br><span class="line">   <span class="variable">.i_reset</span>(i_reset),</span><br><span class="line">	<span class="variable">.i_valid</span>(S_AXIL_ARVALID), </span><br><span class="line">   <span class="variable">.o_ready</span>(S_AXIL_ARREADY),</span><br><span class="line">	<span class="variable">.i_data</span>(S_AXIL_ARADDR[C_AXIL_ADDR_WIDTH-<span class="number">1</span>:AXILLSB]),</span><br><span class="line">	<span class="variable">.o_valid</span>(arskd_valid), </span><br><span class="line">   <span class="variable">.i_ready</span>(axil_read_ready),</span><br><span class="line">	<span class="variable">.o_data</span>(arskd_addr)</span><br><span class="line">	<span class="comment">// &#125;&#125;&#125;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="2-Read-valid-logic"><a href="#2-Read-valid-logic" class="headerlink" title="2. Read_valid logic"></a>2. Read_valid logic</h3><p><code>arskd_valid</code> , <code>axil_read_valid</code> , <code>S_AXIL_RREADY</code> 三者都是寄存器信号，前两个分别来自于 <em>skidbuffer</em> 和 <em>internal_logic</em> ， 后者是外部信号。所以 <em>axil_read_ready</em> 信号的数值也是稳定的。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span>	axil_read_ready = </span><br><span class="line">   				clk_active &amp;&amp; arskd_valid &amp;&amp; </span><br><span class="line">   				(!axil_read_valid || S_AXIL_RREADY);</span><br></pre></td></tr></table></figure>

<p>We’ll move on to the <code>BVALID</code> signal. This signal needs to be set <u><em>following any successful write</em></u> to our core.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	axil_read_valid = <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (i_reset)</span><br><span class="line">	axil_read_valid &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (axil_read_ready)</span><br><span class="line">	axil_read_valid &lt;= <span class="number">1&#x27;b1</span>;</span><br></pre></td></tr></table></figure>

<p>it(e.g. axil_read_valid) needs to remain set until <code>S_AXI_BVALID &amp;&amp; S_AXI_BREADY</code> are both true together.We can simplify clearing this register to just checking if <code>S_AXI_BREADY</code> as blow .</p>
<p><strong>Q</strong>：什么情况下  <code>axil_read_ready == 0</code></p>
<p><strong>A</strong>：通过代码的角度可能很难理解什么情况下 <code>axil_read_ready == 0</code>，但是从逻辑的角度可能更直观。两种情况：</p>
<ul>
<li>1） <em>skidbuffer</em> 中无有效数据，且 <em>upstream</em> 没有直接的 <em>valid_data</em> ； </li>
<li>2）<em>R channel</em> 发生 <em><u>valid before ready</u></em> ， 对 <em>upstream</em> 发起 <em>stall</em>。</li>
</ul>
<p>所以当 <em>skidbuffer</em> 中没有 <em>valid_data</em> 传输时，接收端发起<em>S_AXIL_RREADY</em> 后， <em>axil_read_valid</em> 信号拉低，表示没有更多的信号接收。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (S_AXIL_RREADY)</span><br><span class="line">	axil_read_valid &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span>	S_AXIL_RVALID = axil_read_valid;</span><br><span class="line"><span class="keyword">assign</span>	S_AXIL_RDATA  = axil_read_data;</span><br><span class="line"><span class="keyword">assign</span>	S_AXIL_RRESP = <span class="number">2&#x27;b00</span>;</span><br></pre></td></tr></table></figure>

<p>​							<strong><u>(Fig 10. 100% Read throughput)</u></strong></p>
<img src="https://zipcpu.com/img/easyaxil/readskd-stalled.svg" alt="img" style="zoom:80%;" />



<h1 id="3-axil-control-logic"><a href="#3-axil-control-logic" class="headerlink" title="3. axil control logic"></a>3. axil control logic</h1><h2 id="3-1-last-signal-√"><a href="#3-1-last-signal-√" class="headerlink" title="3.1 last_signal (√)"></a>3.1 last_signal (√)</h2><blockquote>
<p><strong>Purpose</strong> :  将 <em>axi-stream</em> 的数据传输进入 <em>core</em> 的同时，使用其他寄存器对这些读入的数据进行一个备份。这样就可以观察连续两个时钟周期内传输的两个信号之间，是否有 <em>change</em>.</p>
</blockquote>
<p><strong>补充1： 这部分代码用于记录每次的数据，用于 stall 之后比较数据之间是否相同，判断是否 overflow ！</strong></p>
<blockquote>
<p><code>last_stalled</code> – used in overflow checking</p>
</blockquote>
<ul>
<li><code>!i_reset ==1</code> , means no reset component;</li>
<li><code>S_AXIS_TVALID &amp;&amp; !S_AXIS_TREADY</code> ,  <em><u>valid before ready situation</u></em> in B channel.</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	last_stalled = <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">	last_stalled &lt;= (!i_reset) &amp;&amp; </span><br><span class="line">   (S_AXIS_TVALID &amp;&amp; !S_AXIS_TREADY);</span><br></pre></td></tr></table></figure>

<p><em><strong>last_stalled</strong></em> signal is high means the component is working and <em><u>a stall</u></em> happens in <u>AXI-stream channel</u>.</p>
<hr>
<blockquote>
<p><code>last_tlast</code> – used to check for protocol violations in overflow next</p>
</blockquote>
<p>Firstly we should understand the parameter named <code>OPT_TLAST_SYNC</code>.</p>
<blockquote>
<ul>
<li><code>OPT_TLAST_SYNC</code> will synchronize the write with any incoming packets.  Packets are assumed to be synchronized initially after any reset, or on the <code>TVALID</code> following any <code>TLAST</code></li>
</ul>
</blockquote>
<p>如果设置了参数 <code>OPT_TLAST_SYNC</code>，那么每次记录的上一个 <code>last_tlast</code>信号数据一直保持 <code>0</code>，否则就正常记录。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (!OPT_TLAST_SYNC)</span><br><span class="line">	last_tlast &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	last_tlast &lt;= S_AXIS_TLAST;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">	last_tdata &lt;= sskd_data;</span><br></pre></td></tr></table></figure>



<h2 id="3-2-Overflow-√"><a href="#3-2-Overflow-√" class="headerlink" title="3.2 Overflow (√)"></a>3.2 Overflow (√)</h2><blockquote>
<p> <strong>Purpose</strong>: </p>
<ul>
<li>Capture and check whether or not the <em><u>incoming data stream overflowed</u></em></li>
<li>This will be caught by <code>r_err</code> and <code>r_continuous</code>.(overflow 会被 err 和 continue 两个 flag 捕获使用，<font color="red">具体怎么产生的不清楚</font>)</li>
</ul>
<p> <strong>Description</strong>: </p>
<ul>
<li><p>This is primarily <u>a check for AXI-stream protocol violations</u>, since you can’t really overflow an AXI stream when following protocol.  </p>
</li>
<li><p>The problem is that <strong><u>many stream sources</u></strong>–such as ADCs for example–<u><strong>can’t handle back-pressure</strong></u>.  </p>
</li>
<li><p>Hence, checking for stream violations can be used in those cases to check for overflows.  The check is only so good, however, since an overflow condition might take place if an ADC produces two consecutive (identical) values, one of which gets skipped–and this check will not capture that. (如果连续传入两个相同的数据，这个方法不能判断是否 <em>overflow</em>)</p>
</li>
</ul>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	overflow = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (i_reset)</span><br><span class="line">	overflow &lt;= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (last_stalled)</span><br><span class="line"><span class="comment">// if last_stalled signal is true , means a stall happens in </span></span><br><span class="line"><span class="comment">// axi_stream interface</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="comment">// The overflow pulse is only one clock period long</span></span><br><span class="line">	overflow &lt;= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!sskd_valid)</span><br><span class="line">		overflow &lt;= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (S_AXIS_TDATA != last_tdata)</span><br><span class="line">		overflow &lt;= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (OPT_TLAST_SYNC &amp;&amp; S_AXIS_TLAST != last_tlast)</span><br><span class="line">		overflow &lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This will be caught by r_err and r_continuous</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>Q：在代码的注释中有一个具有疑惑：<u><em><strong>The overflow pulse is only one clock period long</strong></em></u> ， 你确定这是保持一个周期</p>
<p>A ：首先看每一个时钟周期开始的时候 <em>overflow</em> 都会被 <em>set zero</em>（e.g. <code>overflow &lt;= 0;</code>），如果每个时钟周期都满足下面的条件才会继续 assert 拉高。 <strong><font color="red">个人认为这是一个非常好的方法，用于维持信号只有一个时钟周期</font></strong></p>
<ul>
<li><p><em>situation one</em> :  <code>!sskd_valid ==1</code> . </p>
<p>A <u><em>valid before ready</em></u> situation in axi-stream interface ,  the signal <code>sskd_valid</code>  should keep it’s valid(e.g. <u><em>keep stable</em></u>) , there should have property  <code>$past(sskd_valid == 1 ,1)</code> .</p>
</li>
<li><p><em>situation two</em> : <code>S_AXIS_TDATA != last_tdata</code></p>
<p>same as <em><u>valid signal above</u></em> , the data should also <u><em>keep it’s data stable</em></u> and not change.</p>
</li>
<li><p><em>situation three</em> : </p>
<p>if the user use the parameter  <code>OPT_TLAST_SYNC</code> , the signal <em><u>last tlast</u></em> should keep stable !</p>
</li>
</ul>
<h2 id="3-3-abort-command-√"><a href="#3-3-abort-command-√" class="headerlink" title="3.3 abort command (√)"></a>3.3 abort command (√)</h2><blockquote>
<p><strong>Purp</strong> : provide two command named <code>w_cmd_abort</code>, <code>cmd_abort</code> – Abort transaction on user request</p>
<p><strong>Description</strong> : </p>
<ul>
<li><code>w_cmd_abort</code> is a <strong>combinational</strong> value <u><em>capturing a user abort request</em></u>. (所以这个信号前面的字母 <em>w</em> 表示 <em>wire</em>)</li>
<li><code>cmd_abort</code> <strong><font color=red>latches</font></strong> the user request <u><em>until the abort is complete</em></u> .（一个寄存器采样信号）</li>
</ul>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	w_cmd_abort = <span class="number">0</span>;</span><br><span class="line">   	<span class="comment">//axil_write_ready == 1 , </span></span><br><span class="line">   	<span class="comment">//		a handshake happens in axi-lite write channel</span></span><br><span class="line">   	<span class="comment">//awskd_addr == CMD_CONTROL,</span></span><br><span class="line">   	<span class="comment">//		the axi-lite write address is pointed to control_register</span></span><br><span class="line">   	<span class="comment">//the data writed to CONTROL_register, it&#x27;s 4th byte is valid </span></span><br><span class="line">   	<span class="comment">//and the data is equal to ABORT_KEY (e.g. ABORT_KEY = 8&#x27;h26)</span></span><br><span class="line">	w_cmd_abort = (axil_write_ready </span><br><span class="line">     &amp;&amp; awskd_addr == CMD_CONTROL)</span><br><span class="line">   	&amp;&amp; (wskd_strb[<span class="number">3</span>] </span><br><span class="line">     &amp;&amp; wskd_data[<span class="number">31</span>:<span class="number">24</span>] == ABORT_KEY);</span><br><span class="line">   </span><br><span class="line">   	<span class="comment">// if the component is not in the middle of one transaction,</span></span><br><span class="line">   	<span class="comment">// we should have right to use w_cmd_abort command !</span></span><br><span class="line">	<span class="keyword">if</span> (!r_busy)</span><br><span class="line">     <span class="comment">//</span></span><br><span class="line">     <span class="comment">// 把这个 set zero situation 放置在最后的一个逻辑位置，十分巧妙</span></span><br><span class="line">		w_cmd_abort = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>这里补充 <code>ABORT_KEY</code> 的参数：</p>
<blockquote>
<p>If the <code>ABORT_KEY</code> is written to the <u><em>upper 8-bits of the control&#x2F;status word</em></u>, the current operation will be <strong>halted</strong>. </p>
<p>Any currently active (<code>AxVALID</code> through <code>xVALID &amp; xREADY</code>) requests will continue to completion, and the core will then come to a halt.</p>
<p><font color="darb">如果在执行中有任何请求处于活动状态，这些请求将会继续进行，直到达到完成状态。活动的请求可能包括发送方发出的有效数据 (<code>AxVALID</code>) 和接收方准备好接收的信号 (<code>xVALID &amp; xREADY</code>)。这种机制确保了在中止当前操作后，系统仍然允许之前已经开始的请求完成其操作，而不会意外中断正在进行的操作。</font></p>
</blockquote>
<hr>
<ul>
<li><code>!r_busy == 1</code> , means <u>no transaction</u> is happening , we can not assert abort register.</li>
<li><code>cmd_abort</code> is  a registered signal to <strong><font color=red>latches</font></strong> the user request <u><em>until the abort is complete</em></u> , if there is one tracsaction is happening (e.g. <code>r_busy == 1</code> ) and  user wants to write an abort command to the control register (e.g. <code>w_cmd_abort</code> is asserted , which is a combinatorical signal) . The registered signal <code>cmd_abort</code> will be high  untill the transaction is abort correctly (e.g. <code>cmd_abort &amp;&amp; r_busy</code>) .</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cmd_abort latches the user request until the abort is complete</span></span><br><span class="line"><span class="keyword">initial</span>	cmd_abort = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (i_reset)</span><br><span class="line">	cmd_abort &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!r_busy)</span><br><span class="line">	cmd_abort &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	cmd_abort &lt;= cmd_abort || w_cmd_abort;</span><br><span class="line"><span class="comment">//cmd_abort &lt;= (cmd_abort &amp;&amp; r_busy)||w_cmd_abort;</span></span><br></pre></td></tr></table></figure>

<p><font color="red">这段代码也表象的说明了什么时候 cmd_abort 会 set zero。可以结合下面的注释代码一起理解，此注释代码来源于 MM2S.v 文件</font></p>
<p><strong>两个信号的波形</strong>：注意这里的 <em>cmd_abort</em> 信号一旦被组合逻辑 <em>w_cmd_abort</em> 拉高之后，会一直维持高信号，知道 <em>r_busy</em> 被拉低。无论什么情况， <em>cmd_abort</em> 都相比于 <em>r_busy</em> 延迟一个时钟周期才拉低。</p>
<p>作图：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;signal: [</span><br><span class="line">  &#123;name: &#x27;clk&#x27;, wave: &#x27;P.....|...&#x27;&#125;,</span><br><span class="line">  &#123;name: &#x27;r_busy&#x27; , wave : &#x27;1........0.&#x27;&#125;,</span><br><span class="line">  &#123;name: &#x27;axil_write_ready&#x27; , wave : &#x27;0.10........&#x27;&#125;,</span><br><span class="line">  &#123;name: &#x27;awskd_addr[2:0]&#x27; , wave : &#x27;xx4xxxxxxxxx&#x27;, data: [&#x27;000&#x27;]&#125;,</span><br><span class="line">  &#123;name: &#x27;wskd_strb[2:0]&#x27; , wave : &#x27;x.3x........&#x27;, data: [&#x27;0xF&#x27;]&#125;,</span><br><span class="line">  &#123;name: &#x27;wskd_data[31:0]&#x27; , wave : &#x27;x3.x........&#x27; , data: [&#x27;0x26000000&#x27;]&#125;,</span><br><span class="line">  &#123;name: &#x27;w_cmd_abort&#x27; , wave : &#x27;0.10........&#x27;&#125;,</span><br><span class="line">  &#123;name: &#x27;cmd_abort&#x27; , wave : &#x27;0..1......0.&#x27;&#125;,</span><br><span class="line">  &#123;name: &#x27;axi_abort_pending&#x27; , wave : &#x27;0...1.....0.&#x27;&#125;,</span><br><span class="line">]&#125;</span><br></pre></td></tr></table></figure>

<img src="https://github.com/xlxwzybds/X-Y-xlxwzybds-github-pages/blob/main/S2MM/02_abort.jpg?raw=true" alt="02_abort.jpg" style="zoom:50%;" />



<h2 id="3-4-wire-start-command-√"><a href="#3-4-wire-start-command-√" class="headerlink" title="3.4 wire_start command (√)"></a>3.4 wire_start command (√)</h2><blockquote>
<p>Purpose : 该组合逻辑说明什么逻辑情况下，被允许 <em>start the core</em>。</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虽然这个信号写着 register type ，但是前缀 w 已经</span></span><br><span class="line"><span class="comment">// 暴露了这是一个 wire type 的事实</span></span><br><span class="line"><span class="keyword">reg</span> w_cmd_start;</span><br></pre></td></tr></table></figure>

<ul>
<li>if status  <code>r_busy == 1</code> :  means the component is in the middle of one transaction , we are supposed not to start a new request.</li>
<li><code>[31] r_busy</code> : <strong>True</strong> if the core is in the middle of a transaction.  Set this bit to one <u><em>to begin a transaction</em></u>.</li>
<li><code>[30] r_err</code>:  <ul>
<li><strong>True</strong> if the core has <u><em>detected an error</em></u>, such as FIFO <u><em>overflow while writing</em></u>, or FIFO <u><em>overflow in continuous mode</em></u>. </li>
<li>Writing a ‘1’ to this bit <u>while the core is <strong>idle</strong> will <strong>clear</strong> it.</u> New transfers <u><em>will not start until this bit is cleared</em></u>.  For this reason, I often <em><u><strong>start a new transfer by writing to bits 31 and 30 of this register</strong></u></em>.</li>
<li><code>_s2mm-&gt;a_control = 0xc0000000</code>; Other bits may be appropriate as well, as discussed below, depending on your application.</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start command . </span></span><br><span class="line"><span class="comment">// there are combitorical logic</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line"><span class="keyword">if</span> (r_busy)</span><br><span class="line">	w_cmd_start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">	w_cmd_start = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> ((axil_write_ready </span><br><span class="line">     &amp;&amp; awskd_addr == CMD_CONTROL)</span><br><span class="line">		&amp;&amp; (wskd_strb[<span class="number">3</span>] &amp;&amp; wskd_data[<span class="number">31</span>]))</span><br><span class="line">     <span class="comment">//axil_write_ready == 1 , </span></span><br><span class="line">   	<span class="comment">//		a handshake happens in axi-lite write channel</span></span><br><span class="line">   	<span class="comment">//awskd_addr == CMD_CONTROL,</span></span><br><span class="line">   	<span class="comment">//		the axi-lite write address is pointed to control_register</span></span><br><span class="line">     <span class="comment">//(wskd_strb[3] &amp;&amp; wskd_data[31] == 1</span></span><br><span class="line">   	<span class="comment">//		the data writed to CONTROL_register, it&#x27;s 4th byte is valid </span></span><br><span class="line">     <span class="comment">//		and 32th bit in write_data is true , means user wants to </span></span><br><span class="line">     <span class="comment">//		begin one transaction !</span></span><br><span class="line">		w_cmd_start = <span class="number">1</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// go back to here later !!!</span></span><br><span class="line">	<span class="keyword">if</span> (r_err &amp;&amp; !wskd_data[<span class="number">30</span>])</span><br><span class="line">		w_cmd_start = <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">if</span> (zero_length)</span><br><span class="line">		w_cmd_start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><font color = "red">r_err 部分设计很巧妙</font> ：存在 <em>r_err &#x3D;&#x3D;1</em> 的情况下，对 <code>wskd_data[30]</code> 写入 <code>1</code> 可以防止失误未启动 <em>cmd_start</em> 命令。</p>
<p>zero_legnth 的信号赋值如下：如果没有对 <em>axi protocol</em> 定义他的 <em>transfer_length</em> ,无数据长度传输，不应该启动 <em>cmd_start</em> 信号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zero_length &lt;= (new_widelen[ADDRLSB +: LGLENW] == 0);</span><br></pre></td></tr></table></figure>

<p>图片如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;signal: [</span><br><span class="line">  &#123;name: &#x27;clk&#x27;, wave: &#x27;P.....|...&#x27;&#125;,</span><br><span class="line">  &#123;name: &#x27;axil_write_ready&#x27; , wave : &#x27;01.0...10.&#x27;,&#125;,</span><br><span class="line">  &#123;name: &#x27;awskd_valid&#x27; , wave : &#x27;01.0...10.&#x27;,&#125;,</span><br><span class="line">  &#123;name: &#x27;awskd_addr[2:0]&#x27; , wave : &#x27;x552...7xx&#x27;, data: [&#x27;110&#x27;,&#x27;111&#x27;,&#x27;000&#x27;,&#x27;000&#x27;]&#125;,</span><br><span class="line">  &#123;name: &#x27;wskd_strb[2:0]&#x27; , wave : &#x27;5..x..7.x...&#x27;, data: [&#x27;0xF&#x27;,&#x27;0xF&#x27;]&#125;,</span><br><span class="line">  &#123;name: &#x27;wskd_data[31:0]&#x27; , wave : &#x27;5.5x..7.x...&#x27; , data: [&#x27;0x00008000&#x27;,&#x27;0x0&#x27;,&#x27;0xC0000000&#x27;]&#125;,</span><br><span class="line">  &#123;name: &#x27;zero_lenth&#x27; , wave : &#x27;1.0.......&#x27;,&#125;,</span><br><span class="line">  &#123;name: &#x27;w_cmd_start&#x27; , wave : &#x27;0......10.&#x27;&#125;,</span><br><span class="line">  &#123;name: &#x27;r_busy&#x27; , wave : &#x27;0.......1.&#x27;&#125;,</span><br><span class="line">]&#125;</span><br></pre></td></tr></table></figure>

<img src="https://github.com/xlxwzybds/X-Y-xlxwzybds-github-pages/blob/main/S2MM/03_start.jpg?raw=true" alt="03_start_new.jpg" style="zoom:67%;" />



<h2 id="3-5-r-busy-r-complete-O"><a href="#3-5-r-busy-r-complete-O" class="headerlink" title="3.5 r_busy &amp; r_complete (O?)"></a>3.5 r_busy &amp; r_complete (O?)</h2><blockquote>
<p><strong>Purp</strong> :  r_busy, r_complete – Calculate busy or complete flags</p>
</blockquote>
<p>The initial state of two register is zero , and they should be set to zero after reset.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	r_busy     = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">initial</span>	r_complete = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (i_reset)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	r_busy     &lt;= <span class="number">0</span>;</span><br><span class="line">	r_complete &lt;= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>If there is not in the middle of one transaction (e.g. <em>r_busy&#x3D;&#x3D; 0</em> ) ,  once we recognize the start command named <code>w_cmd_start</code>  , we will set the <em><u>flag register</u></em> namd <code>r_busy</code> <strong>high</strong> (e.g. start one transaction).</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (!r_busy)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="comment">// Core is idle, waiting for a command to start</span></span><br><span class="line">	<span class="keyword">if</span> (w_cmd_start)</span><br><span class="line">		r_busy &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Any write to the control register will clear the</span></span><br><span class="line">	<span class="comment">// completion flag</span></span><br><span class="line">	<span class="keyword">if</span> (axil_write_ready &amp;&amp; </span><br><span class="line">     awskd_addr == CMD_CONTROL)</span><br><span class="line">     </span><br><span class="line">		r_complete &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure>

<ul>
<li><code>[29] r_complete</code>: <strong>True</strong> if the transaction has completed, whether <strong>normally</strong> or <strong>abnormally</strong> (error or abort). Any write to the <code>CMD_CONTROL</code> register will clear this flag.如果一次传输结束（无论是正常结束，还是发生<code>err</code>或者认为<code>abort</code>中断结束）， <em>r_complete</em> 寄存器会被拉高表示传输结束。对 <code>CMD_CONTROL</code>寄存器的写操作表示有会有新的读写控制会继续，需要 clear r_complete 信号。</li>
</ul>
<p><font color="red">Q：传输结束的标志，是否是 <code>r_busy == 0 &amp;&amp; r_complete==1</code> </font></p>
<p><strong>A</strong>：我个人这个想法是正确的。那么与之对应传输开始的标志位是 <code>r_busy == 1 &amp;&amp; r_complete == 0</code></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (w_complete)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="comment">// Clear busy once the transaction is complete</span></span><br><span class="line">	<span class="comment">//  This includes clearing busy on any error</span></span><br><span class="line">	r_complete &lt;= <span class="number">1</span>;</span><br><span class="line">	r_busy &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><strong><font color="red">Q：w_complete &#x3D;&#x3D; 1 , 表示什么意思 ？ </font></strong></p>
<p><strong>A</strong> : 注意这个的满足条件是 <code>r_busy==1 &amp;&amp; w_complete == 1</code> ， 需要 <em>core</em> 在工作的时候 <em>w_complete</em> 这个组合逻辑信号才会发挥作用，否则会一直保持低电压信号 <code>0</code>。 <em>w_compelte &#x3D;&#x3D;1</em> 表示在 <em>core_busy</em> 的工作状态下，组合逻辑信号将会被采样，告知<em>core</em>下一时钟周期将会完成传输任务，因此需要拉高寄存器信号 <code>r_complete</code>表示任务完成，拉低 <code>r_busy</code>信号表示<em>core</em>将在下一时钟周期处于 <code>idle</code> 状态。</p>
<p><strong>图片如下</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;signal: [</span><br><span class="line">  &#123;name: &#x27;clk&#x27;, wave: &#x27;P.....|...&#x27;&#125;,</span><br><span class="line">  &#123;name: &#x27;r_busy&#x27; , wave : &#x27;1........0.&#x27;&#125;,</span><br><span class="line">  &#123;name: &#x27;r_complete&#x27; , wave : &#x27;0........1.&#x27;&#125;,</span><br><span class="line">  &#123;name: &#x27;w_complete&#x27; , wave : &#x27;0.......10.&#x27;&#125;,</span><br><span class="line">  &#123;name: &#x27;o_int&#x27; , wave : &#x27;0........10.&#x27;&#125;,</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;name: &#x27;axil_write_ready&#x27; , wave : &#x27;0.10........&#x27;&#125;,</span><br><span class="line">  &#123;name: &#x27;awskd_addr[2:0]&#x27; , wave : &#x27;xx4xxxxxxxxx&#x27;, data: [&#x27;000&#x27;]&#125;,</span><br><span class="line">  &#123;name: &#x27;wskd_strb[2:0]&#x27; , wave : &#x27;x.3x........&#x27;, data: [&#x27;0xF&#x27;]&#125;,</span><br><span class="line">  &#123;name: &#x27;wskd_data[31:0]&#x27; , wave : &#x27;x3.x........&#x27; , data: [&#x27;0x26000000&#x27;]&#125;,</span><br><span class="line">  &#123;name: &#x27;w_cmd_abort&#x27; , wave : &#x27;0.10........&#x27;&#125;,</span><br><span class="line">  &#123;name: &#x27;cmd_abort&#x27; , wave : &#x27;0..1......0.&#x27;&#125;,</span><br><span class="line">  &#123;name: &#x27;axi_abort_pending&#x27; , wave : &#x27;0...1.....0.&#x27;&#125;,</span><br><span class="line">]&#125;</span><br></pre></td></tr></table></figure>

<img src="https://github.com/xlxwzybds/X-Y-xlxwzybds-github-pages/blob/main/S2MM/busy_complete_04.jpg?raw=true" alt="busy_complete_04.jpg" style="zoom: 50%;" />



<h2 id="3-6-o-int-O"><a href="#3-6-o-int-O" class="headerlink" title="3.6 o_int (O?)"></a>3.6 o_int (O?)</h2><blockquote>
<p><strong>Purpose</strong> : Create an output signal to indicate that <u><em>we’ve finished</em></u></p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// o_int -- interrupt generation</span></span><br><span class="line"><span class="keyword">initial</span>	o_int = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (i_reset)</span><br><span class="line">	o_int &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	o_int &lt;= (r_busy &amp;&amp; w_complete)</span><br><span class="line">		|| (r_continuous &amp;&amp; overflow);</span><br></pre></td></tr></table></figure>

<img src="https://github.com/xlxwzybds/X-Y-xlxwzybds-github-pages/blob/main/S2MM/busy_complete_04.jpg?raw=true" alt="busy_complete_04.jpg" style="zoom: 33%;" />

<ul>
<li><p><strong>situation1</strong>: <code>(r_busy &amp;&amp; w_complete)</code></p>
<p>只有在 <code>r_busy == 1 </code>下(<em>core is working</em> ) <strong>组合逻辑</strong>信号 <em>w_complte</em> 才会有效而不是不知保持 <code>0</code>。当 <code>(r_busy &amp;&amp; w_complete)</code>被采样的时候表示下一时钟次周期会发生 ：<code>r_busy &lt;= 1&#39;b0; r_complete &lt;= 1 ; </code></p>
</li>
<li><p><strong>situation2</strong>: 暂时没有弄清楚这个 <code>r_continue</code>是什么作用。这个玩意在 <code>S2MM.v</code>并没有使用，在 <code>MM2S.v</code>中会有 <em>r_continue</em> 的使用。</p>
</li>
</ul>
<h2 id="3-7-r-err-X"><a href="#3-7-r-err-X" class="headerlink" title="3.7 r_err (X)"></a>3.7 r_err (X)</h2><p>参考链接：<a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2020/03/08/easyaxil.html">Buidilng an AXI-Lite slave the easy way (zipcpu.com)</a></p>
<blockquote>
<p><strong>Purpose</strong> : r_err, r_errcode , <u><em>Error conditions checking</em></u></p>
</blockquote>
<ul>
<li><p>寄存器设置<code>[30] r_err</code>:  </p>
<ul>
<li><p><strong>True</strong> if the core has <u><em>detected an error</em></u>, such as FIFO <u><em>overflow while writing</em></u>, or FIFO <u><em>overflow in continuous mode</em></u>. </p>
</li>
<li><p>Writing a ‘1’ to this bit <u>while the core is <strong>idle</strong> will <strong>clear</strong> it.</u> New transfers <u><em>will not start until this bit is cleared</em></u>.  For this reason, I often <em><u><strong>start a new transfer by writing to bits 31 and 30 of this register</strong></u></em>.</p>
</li>
<li><p><code>_s2mm-&gt;a_control = 0xc0000000</code>; Other bits may be appropriate as well, as discussed below, depending on your application.</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>	 				r_err；</span><br><span class="line"><span class="keyword">reg</span>	[<span class="number">2</span>:<span class="number">0</span>]		r_errcode;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>localparam</code> 设置</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">localparam</span>	ERRCODE_NOERR    = <span class="number">0</span>,</span><br><span class="line">ERRCODE_OVERFLOW = <span class="number">0</span>,</span><br><span class="line">ERRCODE_SLVERR   = <span class="number">1</span>,</span><br><span class="line">ERRCODE_DECERR   = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>初始寄存器设置和复位设置。<strong>First</strong>, the register is <em><u><strong>cleared</strong></u></em> on any reset.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	r_err = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">initial</span>	r_errcode = ERRCODE_NOERR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (i_reset)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	r_err &lt;= <span class="number">0</span>;</span><br><span class="line">	r_errcode &lt;= ERRCODE_NOERR;</span><br><span class="line"> <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li><code>[28] r_continuous</code>: <ul>
<li>Normally the <em><u>FIFO gets cleared and reset</u></em> between operations. However, if you <strong>set</strong> <code>r_continuous</code>, the core will then <u><em>expect a second operation to take place following the first one</em></u>. In this case, the FIFO doesn’t get cleared. </li>
<li>However, if the FIFO fills and the incoming data is both valid and changing,  the <code>r_err</code> flag will be set.  违背了 <em>valid before ready situation</em> 下的 <em>stable property</em> 原则</li>
<li>Any write to the <code>CMD_CONTROL</code> register while the <em><u>core is not busy will adjust this bit</u></em>.</li>
</ul>
</li>
</ul>
<blockquote>
<p>Since this <code>r_err</code> register was drawn from a stream data to memory copy core, I wanted to know *<u>if the FIFO within was ever overrun</u>*–even when the core isn’t busy. Hence, we’ll set the error on any overflow.</p>
<p><strong><font color="red">暂时不明白为什么 !r_busy 也要 overflow</font></strong></p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NOT in the middle of one transaction</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!r_busy)</span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// the core wants to continuous operations and there is </span></span><br><span class="line">    <span class="comment">// a overflow in FIFO.</span></span><br><span class="line">		<span class="keyword">if</span> (r_continuous &amp;&amp; overflow)</span><br><span class="line">		<span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// set the ERR flag , and set the type of ERR same time</span></span><br><span class="line">			r_err &lt;= <span class="number">1</span>;</span><br><span class="line">			r_errcode[ERRCODE_OVERFLOW] &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		</span><br><span class="line">    <span class="comment">// a valid handshake happens in axi-lite wrtie channels , the address</span></span><br><span class="line">    <span class="comment">// is pointed to the command_control register</span></span><br><span class="line">		<span class="keyword">if</span> (axil_write_ready </span><br><span class="line">      &amp;&amp; awskd_addr == CMD_CONTROL</span><br><span class="line">      <span class="comment">// Any write to the CMD_CONTROL register while the </span></span><br><span class="line">      <span class="comment">// core is not busy will adjust this bit.</span></span><br><span class="line">			&amp;&amp; wskd_strb[<span class="number">3</span>] &amp;&amp; wskd_data[<span class="number">30</span>])</span><br><span class="line">		<span class="keyword">begin</span></span><br><span class="line">			r_err     &lt;= <span class="number">0</span>;</span><br><span class="line">			r_errcode &lt;= ERRCODE_NOERR;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><font color="red">我有点不明白 ！r_busy 情况下为什么可以判断 overflowERR ？？？？</font>  </p>
<hr>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (r_busy)</span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span> (M_AXI_BVALID &amp;&amp; M_AXI_BREADY &amp;&amp; M_AXI_BRESP[<span class="number">1</span>])</span><br><span class="line">		<span class="keyword">begin</span></span><br><span class="line">			r_err &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">			<span class="keyword">if</span> (M_AXI_BRESP[<span class="number">0</span>])</span><br><span class="line">				r_errcode[ERRCODE_DECERR] &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				r_errcode[ERRCODE_SLVERR] &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (overflow)</span><br><span class="line">		<span class="keyword">begin</span></span><br><span class="line">			r_err &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">			r_errcode[ERRCODE_OVERFLOW] &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="3-8-r-continuous-x"><a href="#3-8-r-continuous-x" class="headerlink" title="3.8 r_continuous (x)"></a>3.8 r_continuous (x)</h2><p>在 <code>o_int</code> 、 <code>r_err</code> 、 <code>r_continuous</code> 三个寄存器的逻辑处理中都有 <code>(r_continuous &amp;&amp; overflow)</code>这个 <em>situation</em> 的出现， why ？</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// r_continuous</span></span><br><span class="line"><span class="keyword">initial</span>	r_continuous = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (i_reset)</span><br><span class="line">	r_continuous &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span> (r_continuous &amp;&amp; overflow)</span><br><span class="line">		r_continuous &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">if</span> (!r_busy &amp;&amp; axil_write_ready &amp;&amp; awskd_addr == CMD_CONTROL)</span><br><span class="line">		r_continuous &lt;= wskd_strb[<span class="number">3</span>] &amp;&amp; wskd_data[<span class="number">28</span>];</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><font color="red">我最好奇的一个地方是， r_continue 和 overflow 是怎么发生在的 core_idle 状态下的</font></p>
<h1 id="4-wide"><a href="#4-wide" class="headerlink" title="4. wide_*"></a>4. wide_*</h1><p>可以先阅读 [这部分的configuration设置](#1.  configuration)</p>
<h2 id="4-1-function–apply-wstrb-√"><a href="#4-1-function–apply-wstrb-√" class="headerlink" title="4.1 function–apply_wstrb (√)"></a>4.1 function–apply_wstrb (√)</h2><p>参考链接：<a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2020/03/08/easyaxil.html">Buidilng an AXI-Lite slave the easy way (zipcpu.com)</a></p>
<blockquote>
<p>这里有很多可以读写的寄存器 。For example, </p>
<ul>
<li><p><code>cmd_abort</code> (<em><u>user has commanded an abort</u></em>), </p>
</li>
<li><p><code>r_busy</code> (<em><u>the core is busy working</u></em>), </p>
</li>
<li><p><code>cmd_addr</code> (<em><u>the address to write to</u></em>), </p>
</li>
<li><p><code>cmd_length_w</code> (<font color="red"><em><u>length command, in words</u></em></font>),</p>
</li>
<li><p><code>r_increment</code> (<em><u>whether or not to increment the address</u></em>), etc.</p>
</li>
</ul>
<p>  Register values don’t need to be 32-bits in length either. In <a target="_blank" rel="noopener" href="https://github.com/ZipCPU/wb2axip/blob/53dafe2d54e7a72304afe36e73875a940a351b70/rtl/axis2mm.v#L681-L694">one particular example, a register word</a> is composed of many little bits of information, <code>r_busy</code>, <code>r_err</code>, <code>r_complete</code>, <code>r_continuous</code>, and more. These fields are then all concatenated together into a <code>w_status_word</code>.（链接会跳转到 S2MM.v的相关文件）</p>
</blockquote>
<p>Create a Verilog function to apply write strobes to a <em><u>prior piece of data</u></em>, producing a new piece of data. Remember, if <code>S_AXI_WSTRB[0]</code> is true, then we want to adjust bits <code>7:0</code>, if <code>S_AXI_WSTRB[1]</code> is true, then we’d want to adjust bits <code>15:8</code>, and so on. <font color="red"><em><u><strong>If none of the strobes are true, then nothing should be changed</strong></u></em>.</font></p>
<p>This little function below captures all of that.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> [C_AXI_DATA_WIDTH-<span class="number">1</span>:<span class="number">0</span>]			apply_wstrb;</span><br><span class="line">		<span class="keyword">input</span>	[C_AXI_DATA_WIDTH-<span class="number">1</span>:<span class="number">0</span>]		prior_data;</span><br><span class="line">		<span class="keyword">input</span>	[C_AXI_DATA_WIDTH-<span class="number">1</span>:<span class="number">0</span>]		new_data;</span><br><span class="line">		<span class="keyword">input</span>	[C_AXI_DATA_WIDTH/<span class="number">8</span>-<span class="number">1</span>:<span class="number">0</span>]	wstrb;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">integer</span>	k;</span><br><span class="line">		<span class="keyword">for</span>(k=<span class="number">0</span>; k&lt;C_AXI_DATA_WIDTH/<span class="number">8</span>; k=k+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">begin</span></span><br><span class="line">			apply_wstrb[k*<span class="number">8</span> +: <span class="number">8</span>]</span><br><span class="line">				= wstrb[k] ? new_data[k*<span class="number">8</span> +: <span class="number">8</span>] : prior_data[k*<span class="number">8</span> +: <span class="number">8</span>];</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>

<p>How to use the little function :</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// apply_wstrb(old_data, new_data, write_strobes)</span></span><br><span class="line"><span class="keyword">assign</span>	wskd_r0 = apply_wstrb(r0, wskd_data, wskd_strb);</span><br><span class="line"><span class="keyword">assign</span>	wskd_r1 = apply_wstrb(r1, wskd_data, wskd_strb);</span><br></pre></td></tr></table></figure>

<p>总结：该<em>function</em> 实现一个很简单的功能，如果 <em>wskd_strb is true</em> ，更改<em>data</em> 数据，否则保留 <em>old_data</em>。</p>
<p>下面是如何使用该 <em>function</em>，非常简单的更新方式，但是需要注意的是：每次 <em>wskd_strb&#x3D;&#x3D;1</em> 会将高位和低位都一起更新为一样的数值，这个问题后续的代码会解决。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span>	new_cmdaddrlo= apply_wstrb(</span><br><span class="line">		wide_address[C_AXIL_DATA_WIDTH-<span class="number">1</span>:<span class="number">0</span>],</span><br><span class="line">		wskd_data, wskd_strb);</span><br><span class="line"><span class="keyword">assign</span>	new_cmdaddrhi=apply_wstrb(</span><br><span class="line">		wide_address[<span class="number">2</span>*C_AXIL_DATA_WIDTH-<span class="number">1</span>:C_AXIL_DATA_WIDTH],</span><br><span class="line">		wskd_data, wskd_strb);</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span>	new_lengthlo= apply_wstrb(</span><br><span class="line">		wide_length[C_AXIL_DATA_WIDTH-<span class="number">1</span>:<span class="number">0</span>],</span><br><span class="line">		wskd_data, wskd_strb);</span><br><span class="line"><span class="keyword">assign</span>	new_lengthhi= apply_wstrb(</span><br><span class="line">		wide_length[<span class="number">2</span>*C_AXIL_DATA_WIDTH-<span class="number">1</span>:C_AXIL_DATA_WIDTH],</span><br><span class="line">		wskd_data, wskd_strb);</span><br></pre></td></tr></table></figure>



<h2 id="4-2-wide-signal-√"><a href="#4-2-wide-signal-√" class="headerlink" title="4.2 wide__*   signal (√)"></a>4.2 wide__*   signal (√)</h2><h3 id="1-configuration-√"><a href="#1-configuration-√" class="headerlink" title="1.  configuration (√)"></a>1.  configuration (√)</h3><p>回顾 <em>axi-lite</em> 的参数设置：Size of the AXI-lite bus.  These are <strong>fixed</strong>, since</p>
<ul>
<li>1） AXI-lite is fixed at a width of <code>32-bits</code> by Xilinx def’n, </li>
<li>2）since we only ever have <em><u>4 configuration words</u></em>.</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">localparam</span>  C_AXIL_ADDR_WIDTH = <span class="number">5</span>,</span><br><span class="line"><span class="keyword">localparam</span>  C_AXIL_DATA_WIDTH = <span class="number">32</span></span><br></pre></td></tr></table></figure>

<p>axi-lite address <em><u>based on bytes</u></em> . 这里需要 4 configuration word ，所以需要 32bits 的寄存器需要控制，所以 axi-lite 的 <em><u>address width is 5</u></em> .</p>
<p>回顾 <em>axi-full</em> 的参数设置：</p>
<ul>
<li><p><code>Downstream AXI (MM) address width</code>.  Remember, this is <em>byte</em> oriented, so an address width of 32 means this core can interact with a full <code>2^(C_AXI_ADDR_WIDTH)</code> <em>bytes</em>.</p>
</li>
<li><p>the <code>downstream AXI (MM) data width</code>.  High speed can be achieved by increasing this data width.</p>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">parameter</span>	C_AXI_ADDR_WIDTH = <span class="number">32</span>,</span><br><span class="line"><span class="keyword">parameter</span>	C_AXI_DATA_WIDTH = <span class="number">32</span>,</span><br></pre></td></tr></table></figure>

<hr>
<p>注意下面的数据位宽是 <em>axi-lite_data_width</em>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>	[<span class="number">2</span>*C_AXIL_DATA_WIDTH-<span class="number">1</span>:<span class="number">0</span>]	</span><br><span class="line"> wide_address, </span><br><span class="line"> wide_length,</span><br><span class="line"> new_wideaddr, </span><br><span class="line"> new_widelen,</span><br><span class="line"> wide_len_remaining,</span><br><span class="line"> wide_current_address;</span><br><span class="line"></span><br><span class="line"><span class="keyword">wire</span>	[C_AXIL_DATA_WIDTH-<span class="number">1</span>:<span class="number">0</span>]	</span><br><span class="line"> new_cmdaddrlo, </span><br><span class="line"> new_cmdaddrhi,</span><br><span class="line"> new_lengthlo,  </span><br><span class="line"> new_lengthhi;</span><br></pre></td></tr></table></figure>



<h3 id="2-wide-address-current-address-length-√"><a href="#2-wide-address-current-address-length-√" class="headerlink" title="2.wide_address , current_address &amp; length (√)"></a>2.wide_address , current_address &amp; length (√)</h3><p>现在很好理解这几个不同的地址分别是什么作用了</p>
<ul>
<li><code>wide_addresss</code>，用于存放<em>dile</em>状态下的 <em>command start address</em>，一个 <em>write address</em> 的起始地址将会在这个寄存器中体现，赋值 <code>cmd_addr</code></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wide_address = <span class="number">0</span>;</span><br><span class="line">wide_address[C_AXI_ADDR_WIDTH-<span class="number">1</span>:<span class="number">0</span>] = cmd_addr;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>wide_current_address</code>，存放 <em>r_busy</em> 下的写地址 ，<u><em><strong>If busy, this is the address of either the current or next address the core will request writing to</strong></em></u>.</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wide_current_address = <span class="number">0</span>;</span><br><span class="line">wide_current_address[C_AXI_ADDR_WIDTH-<span class="number">1</span>:<span class="number">0</span>] = axi_addr;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>wide_length</code>，用于存放本次<em>operation</em>需要传输的 <em>bytes</em>总数。如果只是<em>one beat</em> 传输 ，<em>wide_length</em> 的长度就等于<em>axifull_data_width</em> 的宽度。注意该信号有前缀 <code>cmd_*</code>，所以这个信号也是在<em>idle</em> 状态的相关控制逻辑设置的。</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Maximum number of bytes that can ever be transferred, in</span></span><br><span class="line"><span class="comment">// log-base 2.  Hence LGLEN=20 will transfer 1MB of data.</span></span><br><span class="line"><span class="comment">// parameter		LGLEN  	= C_AXI_ADDR_WIDTH-1；</span></span><br><span class="line"><span class="comment">// localparam	ADDRLSB = $clog2(C_AXI_DATA_WIDTH)-3;</span></span><br><span class="line"><span class="comment">// localparam	LGLENW  = LGLEN  - ADDRLSB;</span></span><br><span class="line">wide_length = <span class="number">0</span>;</span><br><span class="line">wide_length[ADDRLSB +: LGLENW] = cmd_length_w;</span><br></pre></td></tr></table></figure>

<p>可以看出 <em>wide_length</em> 是以 <em>bytes</em> 为单位的。</p>
<ul>
<li><code>wide_len_remaining</code> ， 记录 <em>burst</em> 中还需要多少个 <em>bytes</em> 需要传输；具体参考[Count remaining words](#Count remaining words)这个部分。</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wide_len_remaining = <span class="number">0</span>;</span><br><span class="line">wide_len_remaining[ADDRLSB +: LGLENW] = r_remaining_w;</span><br></pre></td></tr></table></figure>



<h3 id="3-new-wideaddr-widelen-√"><a href="#3-new-wideaddr-widelen-√" class="headerlink" title="3. new_wideaddr&#x2F;widelen (√)"></a>3. new_wideaddr&#x2F;widelen (√)</h3><p>相关的参数设置[1.  configuration](#1.  configuration), 两个信号：<code>new_wideaddr</code> 和 <code>new_widelen</code> 两者都是 <em>wire type</em>，相当于这里创建了一个多路选择器 <em>MUX</em>。</p>
<p><strong>Q</strong>：为什么之前有了 <em>wideaddr</em> 和 <em>widelen</em> 两个信号之后，还需要 <em>new_wideaddr</em> 和 <em>new_len</em> 两个信号？</p>
<p><strong>A</strong>：在之前代码逻辑中，注意一个细节：只要 <code>wskd_strb</code> 信号为 <code>true</code> ，那么<code>new_cmdaddrlo</code> 和 <code>new_cmdaddrhi</code>  两个信号都会被更新为 <em>wskd_data</em> 的数据。这样拼接的数据肯定是错误的，蓄意需要使用 <em>MUX</em> 进行筛选。</p>
<blockquote>
<p><strong>signal name</strong> : <code>new_wideaddr</code>, <code>new_widelen</code></p>
<p><strong>Purpose</strong> : These are the wide_* adjusted for <u><em><strong>any write</strong></em></u>, and then <u><em>adjusted again</em></u> to make sure <strong><u><em>they are within the correct number of bits</em></u></strong> for the interface.</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">   <span class="comment">// adjust for wide_addr signal aganin</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// if do not come out the *if state*as below</span></span><br><span class="line">   <span class="comment">// the data in new_wideaddr shoudl keep stable</span></span><br><span class="line">   <span class="comment">// (e.g. equal to the wide_address)</span></span><br><span class="line">	new_wideaddr = wide_address;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// if operate at the lower bits of command_address</span></span><br><span class="line">	<span class="keyword">if</span> (awskd_addr == CMD_ADDRLO)</span><br><span class="line">		new_wideaddr[C_AXIL_DATA_WIDTH-<span class="number">1</span>:<span class="number">0</span>]</span><br><span class="line">			= new_cmdaddrlo;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// if operate at the higher bits of command_address</span></span><br><span class="line">	<span class="keyword">if</span> (awskd_addr == CMD_ADDRHI)</span><br><span class="line">		new_wideaddr[<span class="number">2</span>*C_AXIL_DATA_WIDTH-<span class="number">1</span>:C_AXIL_DATA_WIDTH]</span><br><span class="line">			= new_cmdaddrhi;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">if</span> (!OPT_UNALIGNED)</span><br><span class="line">		new_wideaddr[ADDRLSB-<span class="number">1</span>:<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// adjust for wide_len signal aganin</span></span><br><span class="line">   <span class="comment">// all operation is same as the wide_address above!</span></span><br><span class="line">   new_widelen = wide_length;</span><br><span class="line">	<span class="keyword">if</span> (awskd_addr == CMD_LENLO)</span><br><span class="line">		new_widelen[C_AXIL_DATA_WIDTH-<span class="number">1</span>:<span class="number">0</span>] = new_lengthlo;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">if</span> (awskd_addr == CMD_LENHI)</span><br><span class="line">		new_widelen[<span class="number">2</span>*C_AXIL_DATA_WIDTH-<span class="number">1</span>:C_AXIL_DATA_WIDTH]</span><br><span class="line">			= new_lengthhi;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>在信号的处理过程中还需要注意下面的 <code>Attention</code> ：</p>
<blockquote>
<p>1.We only support <code>C_AXI_ADDR_WIDTH</code> address bits (超出axifull_addr的部分需要保持 <code>0</code> )</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_wideaddr[<span class="number">2</span>*C_AXIL_DATA_WIDTH-<span class="number">1</span>:C_AXI_ADDR_WIDTH] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>2.We only support <u><em>integer numbers of <strong>words</strong></em></u>–even if unaligned (<strong>只以 word 或者说以 axi_data_width为单位进行传输！！</strong>)</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//	localparam	ADDRLSB = $clog2(C_AXI_DATA_WIDTH)-3;</span></span><br><span class="line"><span class="comment">//	because the width of axi-full data is 32 bits (we set here) , so it is a word,</span></span><br><span class="line"><span class="comment">//	ADDRLSB is word_width !</span></span><br><span class="line">new_widelen[ADDRLSB-<span class="number">1</span>:<span class="number">0</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>3.We only support <code>LGLEN</code> length bits （最高的传输 <em>byte</em> 数量限制为 <strong>LGLEN</strong> ，也就是 <code>1MB</code> 数据）</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_widelen[<span class="number">2</span>*C_AXIL_DATA_WIDTH-<span class="number">1</span>:LGLEN] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="4-My-picture-√"><a href="#4-My-picture-√" class="headerlink" title="4. My picture (√)"></a>4. My picture (√)</h3><img src="https://github.com/xlxwzybds/X-Y-xlxwzybds-github-pages/blob/main/S2MM/s2mm_newaddr.jpg?raw=true" alt="s2mm_newaddr.jpg" style="zoom: 50%;" />



<h2 id="4-3-set-command-√"><a href="#4-3-set-command-√" class="headerlink" title="4.3 set command (√)"></a>4.3 set command (√)</h2><p>首先回顾这些寄存器的位宽设置：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> r_increment;</span><br><span class="line"><span class="keyword">reg</span>	[C_AXI_ADDR_WIDTH-<span class="number">1</span>:<span class="number">0</span>]	cmd_addr;</span><br><span class="line"><span class="comment">// Maximum number of bytes that can ever be transferred, in</span></span><br><span class="line"><span class="comment">// log-base 2.  Hence LGLEN=20 will transfer 1MB of data.</span></span><br><span class="line"><span class="comment">// parameter	LGLEN  = C_AXI_ADDR_WIDTH-1,</span></span><br><span class="line"><span class="comment">// localparam	LGLENW  = LGLEN  - ADDRLSB;  based on axi-data-width</span></span><br><span class="line"> <span class="keyword">reg</span>	[LGLENW-<span class="number">1</span>:<span class="number">0</span>]	cmd_length_w;</span><br><span class="line"><span class="comment">// 如果是 single transfer ， 设置为 1</span></span><br><span class="line"><span class="keyword">reg</span> zero_length;</span><br><span class="line"><span class="keyword">reg</span>	aw_multiple_full_bursts, </span><br><span class="line">aw_multiple_fixed_bursts,</span><br></pre></td></tr></table></figure>

<p>关于 <code>r_increment</code> 寄存器的阐述：</p>
<ul>
<li><p><code>[27] !r_increment</code> ：If <strong>clear</strong>, the core writes to <u><em><strong>subsequent and incrementing addresses</strong></em></u>–the normal copy to memory case.  If <code>!r_increment</code> is <strong>set</strong>, the core writes to the same address throughout the transaction.  This is useful if you want to <u><em><strong>copy data to a FIFO</strong></em></u> or <strong><u><em>other device living at a single address</em></u></strong> in the memory map.</p>
<p><u><em><strong>Writes to <code>CMD_CONTROL</code> while the core is idle will adjust this bit</strong></em></u>.</p>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cmd_addr, cmd_length_w, r_increment, zero_length, aw_multiple_*</span></span><br><span class="line"><span class="keyword">initial</span>	r_increment   = <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">initial</span>	cmd_addr      = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">initial</span>	cmd_length_w  = <span class="number">0</span>;	<span class="comment">// Counts in bytes</span></span><br><span class="line"><span class="keyword">initial</span>	zero_length   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">initial</span> aw_multiple_full_bursts  = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">initial</span> aw_multiple_fixed_bursts = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (i_reset)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	r_increment &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">	cmd_addr      &lt;= <span class="number">0</span>;</span><br><span class="line">	cmd_length_w  &lt;= <span class="number">0</span>;</span><br><span class="line">	zero_length   &lt;= <span class="number">1</span>;</span><br><span class="line">	aw_multiple_full_bursts  &lt;= <span class="number">0</span>;</span><br><span class="line">	aw_multiple_fixed_bursts &lt;= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="1-control-address-√"><a href="#1-control-address-√" class="headerlink" title="1. control &amp; address (√)"></a>1. control &amp; address (√)</h3><p>If you want to control the core to operate , you must wait the core to go to <strong>idle</strong> state.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (axil_write_ready &amp;&amp; !r_busy)</span><br><span class="line"><span class="keyword">begin</span> <span class="comment">// Set the command, address, and length prior to operation</span></span><br><span class="line">   		<span class="keyword">case</span>(awskd_addr)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Control</strong> :关于 <code>r_increment</code> 寄存器的阐述：If <strong>clear</strong>, the core writes to <u><em><strong>subsequent and incrementing addresses</strong></em></u></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMD_CONTROL:</span><br><span class="line">	r_increment &lt;= !wskd_data[<span class="number">27</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ADDRLO</strong>:将 <em>new_wide_addr</em> 的低位传输给 <em><strong>command_address_register</strong></em></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMD_ADDRLO:</span><br><span class="line">	cmd_addr &lt;= new_wideaddr[C_AXI_ADDR_WIDTH-<span class="number">1</span>:<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ADDRHI</strong>：逻辑可以见 [2 . CMD_LEN_high&#x2F;low](#2 . CMD_LEN_high&#x2F;low) ，在cmd_length中有一样的实现逻辑。</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CMD_ADDRHI: <span class="keyword">if</span> (C_AXI_ADDR_WIDTH &gt; C_AXIL_DATA_WIDTH)</span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">	cmd_addr &lt;= new_wideaddr[C_AXI_ADDR_WIDTH-<span class="number">1</span>:<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h3 id="2-cmd-len-high-low-√"><a href="#2-cmd-len-high-low-√" class="headerlink" title="2 . cmd_len_high&#x2F;low (√)"></a>2 . cmd_len_high&#x2F;low (√)</h3><p>对于这部分的代码理解，我和上面的 [1. control &amp; address](#1. control &amp; address) 部分中之前带有一样的疑惑。我的疑惑如下：</p>
<ul>
<li><p><strong>Q</strong>：为什么对于控制信号 <code>HI/LO</code> 两个都是一样的信号逻辑？</p>
</li>
<li><p><strong>A</strong>：如果先进行 <code>CMD_LENLO</code> 的控制状态，那么首先进行的寄存器信号赋值逻辑如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reg	[LGLENW-1:0]		cmd_length_w;</span></span><br><span class="line"><span class="comment">// localparam	ADDRLSB = $clog2(C_AXI_DATA_WIDTH)-3;</span></span><br><span class="line"><span class="comment">// localparam	LGLENW  = LGLEN  - ADDRLSB;</span></span><br><span class="line">CMD_LENLO: <span class="keyword">begin</span></span><br><span class="line">		cmd_length_w &lt;= new_widelen[ADDRLSB +: LGLENW];</span><br></pre></td></tr></table></figure>

<p>该代码逻辑会将 <em>new_widelen</em>赋予给 <em>cmd_length_w</em> ，不过这个时候信号 <em>new_widelen</em> 信号**<u><em>只有低32bit</em></u>** 被更新到正确的数值。在将 <em>new_widelen</em> 信号的高<em>32bits</em> 正确写入之后，还需要再次更新！</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMD_LENHI: <span class="keyword">if</span> (LGLEN &gt; C_AXIL_DATA_WIDTH)</span><br><span class="line">		<span class="keyword">begin</span></span><br><span class="line">		cmd_length_w &lt;= new_widelen[ADDRLSB +: LGLENW];</span><br></pre></td></tr></table></figure>

<p>如果传输的数据总量大 <em>axilite_data_width</em> (e.g.<code>LGLEN &gt; C_AXIL_DATA_WIDTH</code> ), 那么需要将 <code>cmd_lengthHI</code>的高位进行传输，再进行正确的 <em>wide_length_w</em> 正确更新之后，将该信号在此赋值给 <em>cmd_length_w</em> 寄存。</p>
</li>
</ul>
<hr>
<p>下面对这个逻辑部分的逻辑功能进行解读：</p>
<ul>
<li><code>cmd_length_w</code> 信号：在此注意这个寄存器的长度问题。</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// localparam	ADDRLSB = $clog2(C_AXI_DATA_WIDTH)-3;</span></span><br><span class="line"><span class="comment">// localparam	LGLENW  = LGLEN  - ADDRLSB;</span></span><br><span class="line"><span class="keyword">reg</span>	[LGLENW-<span class="number">1</span>:<span class="number">0</span>]		cmd_length_w;</span><br></pre></td></tr></table></figure>

<p>通过地位LOW &#x2F; 高位 HIGH 的两个赋值，将 <em>new_widelen</em> 正确更新之后，信号赋值给 <em>cmd_length_w</em> 寄存器。该传输长度😑不在以 <em>byte</em> 为单位，而是以 <em>word</em> 为长度单位。</p>
<ul>
<li><code>zero_length</code> 信号：如果该信号是 <code>0</code>，意味着该 <em>operation</em> 只进行一次长度恰好为 <em>cmd_length_w</em> 的 <em>axifull_data_width</em> 的数据传输。（上述理解错误，应该是再无数据需要读写）</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zero_length &lt;= (new_widelen[ADDRLSB +: LGLENW] == <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>aw_multiple_full_bursts</code>信号、<code>aw_multiple_fixed_bursts</code>信号，主要靠判定高位是否有非零信号<em>bit</em>位置</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aw_multiple_full_bursts  &lt;= |new_widelen[LGLEN-<span class="number">1</span>:(ADDRLSB+LGMAXBURST)];</span><br><span class="line">aw_multiple_fixed_bursts &lt;= |new_widelen[LGLEN-<span class="number">1</span>:(ADDRLSB+LGMAX_FIXED_BURST)];</span><br></pre></td></tr></table></figure>



<h3 id="3-busy-xx"><a href="#3-busy-xx" class="headerlink" title="3. busy (xx??)"></a>3. busy (xx??)</h3><blockquote>
<p><strong>Purpose</strong> : Updated <code>cmd_addr</code> &amp;&amp; <code>cmd_length</code> during operation </p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (r_busy)</span><br></pre></td></tr></table></figure>

<p>我这里有一个 <code>bing</code>编写的 <code>c</code>代码程序，不一定和 <code>verilog</code>代码贴切，但是方便理解：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> r_continuous = <span class="number">1</span>; 			<span class="comment">// 表示我们正在连续读取数据</span></span><br><span class="line"><span class="type">int</span> axi_abort_pending = <span class="number">0</span>; 	<span class="comment">// 表示我们没有收到中止信号</span></span><br><span class="line"><span class="type">int</span> axi_addr = <span class="number">0</span>; <span class="comment">// 当前正在写入的内存地址</span></span><br><span class="line"><span class="type">int</span> cmd_addr = <span class="number">0</span>; <span class="comment">// 最后写入的内存地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (r_continuous) &#123;</span><br><span class="line">    <span class="comment">// 从设备读取数据</span></span><br><span class="line">    <span class="type">int</span> data = <span class="built_in">read_from_device</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据写入内存</span></span><br><span class="line">    <span class="built_in">write_to_memory</span>(axi_addr, data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果我们正在连续读 burst，或者收到了中止信号，</span></span><br><span class="line">    <span class="comment">// 我们就记录下当前写入的内存地址</span></span><br><span class="line">    <span class="keyword">if</span> (r_continuous || axi_abort_pending) &#123;</span><br><span class="line">        cmd_addr = axi_addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新内存地址，准备下一次写入</span></span><br><span class="line">    axi_addr += <span class="built_in">sizeof</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否收到了中止信号</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check_abort_signal</span>()) &#123;</span><br><span class="line">        axi_abort_pending = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Capture</strong> </p>
<ul>
<li>the <em><u><strong>last address</strong></u></em> written to in case of <code>r_continuous</code> (<em><u><strong>where we’ll want to start again from this address</strong></u></em>),</li>
<li><code>cmd_abort</code> (where we’ll want to <em><u><strong>know how far we got</strong></u></em>),</li>
<li>or a <code>bus error</code> (where <u><em><strong>again we’ll want to know how far we got</strong></em></u>)</li>
</ul>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (r_continuous||axi_abort_pending)</span><br><span class="line">	cmd_addr &lt;= axi_addr;</span><br></pre></td></tr></table></figure>

<p>可以看出，如果是 <code>r_continue</code>传输，那么最后一次或者说每次的新 <em>axi_addr</em> 都会采样到 <em>cmd_addr</em> 中。如果发生了 <em>axi_abort</em> 事件，中断点附近的地址也会采样进 <code>cmd_addr</code> 寄存器。</p>
<hr>
<p>Capture the number of remaining requests on either <u><strong>an error or an abort</strong></u>.  Need to be careful here that we don’t capture this address twice–hence the check for <code>w_cmd_abort &amp;&amp; !cmd_abort</code>（<code>wire_cmd_abort</code>信号即将拉高 <code>r_cmd_abort</code> 信号的一个周期）, and again for <code>BVALID &amp;&amp; !r_err</code> （<code>BVALID</code>信号即将拉高 <code>r_err</code> 信号的一个周期）</p>
<p>Note that we can’t check for <code>axi_abort_pending</code> here, since as soon as <code>axi_abort_pending</code> becomes true then <code>cmd_length_w</code> will get set to zero.  Hence we <u><em><strong>need to capture this before <code>axi_abort_pending</code> gets set</strong></em></u>. 于<em>axi_abort_pending</em> 设置相关的代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span> (M_AXI_BVALID &amp;&amp; M_AXI_BREADY &amp;&amp; M_AXI_BRESP[<span class="number">1</span>])</span><br><span class="line">			axi_abort_pending &lt;= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (cmd_abort)</span><br><span class="line">			axi_abort_pending &lt;= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (r_err)</span><br><span class="line">			axi_abort_pending &lt;= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="comment">// there for author has code as below:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//		if (!axi_abort_pending &amp;&amp; (cmd_abort || r_err</span></span><br><span class="line"><span class="comment">//				|| (M_AXI_BVALID &amp;&amp; M_AXI_BRESP[1])))</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note that this is only an <em>approximate</em> length–especially in the case of <u>either a bus error or an overflow</u>, in which cases we won’t really know what <em>writes have been accomplished</em> <u>only that the last one failed</u>.  </p>
<p>In that case, this will indicate the amount of writes we haven’t requested (yet)–knowing that at least one (or more) of those prior must’ve failed.  In the case of an overflow error, the overflow error may (or may not) have been written to memory by this time. （<font color="red">总之一句话就是，计算会有误差不准确</font>）</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line">	cmd_length_w &lt;= aw_requests_remaining;</span><br><span class="line">	zero_length  &lt;= (aw_requests_remaining == <span class="number">0</span>);</span><br><span class="line">	aw_multiple_full_bursts  &lt;= |aw_requests_remaining[LGLENW-<span class="number">1</span>:LGMAXBURST];</span><br><span class="line">	aw_multiple_fixed_bursts &lt;= |aw_requests_remaining[LGLENW-<span class="number">1</span>:LGMAX_FIXED_BURST];</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>





<h2 id="4-4-axil-read-data-√"><a href="#4-4-axil-read-data-√" class="headerlink" title="4.4  axil_read_data (√)"></a>4.4  axil_read_data (√)</h2><p>首先是对 <em>skidbuffer</em> 传入的 <code>AR channel</code>  地址信号 <code>arskd_addr</code> 进行解析。回顾地址信息：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">localparam</span> [<span class="number">2</span>:<span class="number">0</span>]	</span><br><span class="line">			CMD_CONTROL   = <span class="number">3&#x27;b000</span>,</span><br><span class="line">			CMD_ADDRLO    = <span class="number">3&#x27;b100</span>,</span><br><span class="line">			CMD_ADDRHI    = <span class="number">3&#x27;b101</span>,</span><br><span class="line">			CMD_LENLO     = <span class="number">3&#x27;b110</span>,</span><br><span class="line">			CMD_LENHI     = <span class="number">3&#x27;b111</span>;</span><br></pre></td></tr></table></figure>

<p><strong>Q</strong>：什么时候可以对该信号进行地址解析呢？</p>
<p><strong>A</strong>： <code>R channel</code> 没有发生 <em><u>valid before ready situation</u></em></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>				axil_read_valid;</span><br><span class="line"></span><br><span class="line"><span class="comment">// axil_read_data</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (!axil_read_valid || S_AXIL_RREADY)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">case</span>(arskd_addr)</span><br></pre></td></tr></table></figure>

<h3 id="1-CMD-CONTROL-√"><a href="#1-CMD-CONTROL-√" class="headerlink" title="1. CMD_CONTROL : (√)"></a>1. <code>CMD_CONTROL</code> : (√)</h3><p>将 <em>w_status_word</em> 的信息读取到 <u><em>axil read data</em></u>中。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD_CONTROL: axil_read_data &lt;= w_status_word;</span><br></pre></td></tr></table></figure>

<p><em>w_status_word</em> 是一个 <em>wire</em> ，连接到了 <em>control_register</em> 的信息：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	w_status_word = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The ABORT_KEY needs to be chosen so as not to look</span></span><br><span class="line">	<span class="comment">// like these bits, lest someone read from the register</span></span><br><span class="line">	<span class="comment">// and write back to it accidentally aborting any transaction</span></span><br><span class="line">	w_status_word[<span class="number">31</span>] = r_busy;</span><br><span class="line">	w_status_word[<span class="number">30</span>] = r_err;</span><br><span class="line">	w_status_word[<span class="number">29</span>] = r_complete;</span><br><span class="line">	w_status_word[<span class="number">28</span>] = r_continuous;</span><br><span class="line">	w_status_word[<span class="number">27</span>] = !r_increment;</span><br><span class="line">	w_status_word[<span class="number">26</span>] = !tlast_syncd;</span><br><span class="line">	w_status_word[<span class="number">25</span>:<span class="number">23</span>] = r_errcode;</span><br><span class="line">	w_status_word[<span class="number">22</span>] = cmd_abort;</span><br><span class="line">	w_status_word[<span class="number">20</span>:<span class="number">16</span>] = LGFIFO;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h3 id="2-CMD-ADDRLO-CMD-ADDRHI-√"><a href="#2-CMD-ADDRLO-CMD-ADDRHI-√" class="headerlink" title="2.   CMD_ADDRLO &amp; CMD_ADDRHI (√)"></a>2. <code>  CMD_ADDRLO &amp; CMD_ADDRHI</code> (√)</h3><p><em>axi-lite</em> 的数据位宽是 <em>32bits</em> ，<em>wide_address</em> 的位宽是 <code>2*axilite_data_width </code>，意图通过两次 <em>axil read operation</em> 读取较长的 <em>axifull address</em> ，长度是<code>[C_AXI_ADDR_WIDTH-1:($clog2(C_AXI_DATA_WIDTH)-3)]</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>	[<span class="number">2</span>*C_AXIL_DATA_WIDTH-<span class="number">1</span>:<span class="number">0</span>]	</span><br><span class="line">				wide_address, </span><br><span class="line">				wide_current_address;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>CMD_ADDTLO</code> ：地址为 <code>x10-14</code>，长度为 <em>4Byte</em></li>
<li><code>CMD_ADDRHI</code> ：地址为 <code>x14-17</code>，长度为 <em>4Byte</em></li>
</ul>
<blockquote>
<p>If <strong>idle</strong>, this is address <u><em>the core will write to when it starts</em></u>.</p>
<p>If <strong>busy</strong>, this is the address of <u><em>either the current or next address the core will request writing to</em></u>.</p>
</blockquote>
<p>Upon <strong>completion</strong>, the address either <u><em>returns to the starting address (if r_continuous is clear)</em></u>, or otherwise becomes <u><em>the address where the core left off</em></u>. 如果是不是连续操作，那么完成的时候返回的地址是操作开始的地址，否则返回的是最后一个结束的地址。</p>
<p>根据上面的描述可以知道 <em>idle state</em> 状态下的 <em>start address</em> 存放在 <em>register wide_address</em>中。<em>core</em> 在 <em>r_busy</em> 状态下读取的地址存放在 <em>register wide_current_address</em> 中。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CMD_ADDRLO: <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span> (!r_busy)</span><br><span class="line">		axil_read_data &lt;= wide_address[C_AXIL_DATA_WIDTH-<span class="number">1</span>:<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		axil_read_data &lt;= wide_current_address[C_AXIL_DATA_WIDTH-<span class="number">1</span>:<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">CMD_ADDRHI: <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span> (!r_busy)</span><br><span class="line">		axil_read_data &lt;= wide_address[<span class="number">2</span>*C_AXIL_DATA_WIDTH-<span class="number">1</span>:C_AXIL_DATA_WIDTH];</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		axil_read_data &lt;= wide_current_address[<span class="number">2</span>*C_AXIL_DATA_WIDTH-<span class="number">1</span>:C_AXIL_DATA_WIDTH];</span><br><span class="line">	<span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h3 id="3-CMD-LENLO-CMD-LENHI-√"><a href="#3-CMD-LENLO-CMD-LENHI-√" class="headerlink" title="3. CMD_LENLO &amp; CMD_LENHI (√)"></a>3. <code>CMD_LENLO &amp; CMD_LENHI</code> (√)</h3><p><strong>Purp</strong> ：**<u><em>The size of the transfer in bytes</em></u>**.  </p>
<p><strong>Attention</strong>：Only accepts aligned addresses, therefore bits <code>[($clog2(C_AXI_DATA_WIDTH)-3):0]</code> will always be forced to zero.  </p>
<pre><code>reg	[2*C_AXIL_DATA_WIDTH-1:0]	
                    wide_length,
                    wide_len_remaining;
</code></pre>
<ul>
<li><code>CMD_LENLO</code> ：地址为 <code>x18-1B</code>，长度为 <em>4Byte</em></li>
<li><code>CMD_LENHI</code> ：地址为 <code>x1C-1F</code>，长度为 <em>4Byte</em></li>
</ul>
<p>To find out <u><em>what size</em></u> bus this core is conencted to, or the <u><em>maximum transfer length</em></u>, write a -1 to this value and read the returning result.  <font color="red">我的理解是：1.如果是 单次单次的传输，每次只需要传输axifull_data_width的位宽，得到的数据就是<em>axifull_data_width</em>2.如果是连续的传输，那么得到的数据就是一共传输的 bytes 总数</font>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CMD_LENLO: <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span> (!r_busy)</span><br><span class="line">		axil_read_data &lt;= wide_length[C_AXIL_DATA_WIDTH-<span class="number">1</span>:<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		axil_read_data &lt;= wide_len_remaining[C_AXIL_DATA_WIDTH-<span class="number">1</span>:<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">CMD_LENHI: <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span> (!r_busy)</span><br><span class="line">		axil_read_data &lt;= wide_length[<span class="number">2</span>*C_AXIL_DATA_WIDTH-<span class="number">1</span>:C_AXIL_DATA_WIDTH];</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		axil_read_data &lt;= wide_len_remaining[<span class="number">2</span>*C_AXIL_DATA_WIDTH-<span class="number">1</span>:C_AXIL_DATA_WIDTH];</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">default</span>:     axil_read_data &lt;= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>While the core is <strong>busy</strong>, reads from this address will return <u><em>the number of items still to be written to the bus</em></u>.</p>
</blockquote>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h1 id="5-data-FIFO"><a href="#5-data-FIFO" class="headerlink" title="5. data FIFO"></a>5. data FIFO</h1><h2 id="5-1-reset-read-write-FIFO-√"><a href="#5-1-reset-read-write-FIFO-√" class="headerlink" title="5.1 reset &amp; read &amp; write FIFO (√)"></a>5.1 reset &amp; read &amp; write FIFO (√)</h2><blockquote>
<ul>
<li><p><strong>[31] r_busy</strong> : True if the core is in the middle of a transaction；</p>
</li>
<li><p><strong>[30] r_err</strong> ： <strong>True</strong> if the core has detected an error, a bus error while the FIFO is reading. Writing a ‘1’ to this bit while the core is idle will <strong>clear</strong> it. New transfers <strong>will not start until</strong> this bit is cleared.<em>当核心处于空闲状态时，向这个位写入’1’将会清除它，也就是将它设置为假（False）。只有当这个位被清除（设置为假）后，新的传输才会开始。</em></p>
</li>
<li><p><strong>[28] r_continuous</strong> :</p>
<p><strong>Normally</strong> the FIFO gets cleared and reset between operations.</p>
<p>However, if you <strong>set</strong> r_continuous, <em>the core will then expect a second operation to take place following the first one</em>. In this case, the operation will complete <em>but the FIFO won’t get cleared</em>. <font color="red"><strong>During this time, the FIFO will not fill further</strong>.</font></p>
<p>Any write to the <code>CMD_CONTROL</code> register while the core is <strong>not</strong> busy will adjust this bit.</p>
<ul>
<li><code>r_continuous</code>：这是一个标志位，用于控制是否在操作之间清除和重置FIFO。</li>
<li>如果<code>r_continuous</code>为假，那么在每次操作之后，FIFO队列会被清除和重置。这是正常的操作模式。</li>
<li>如果<code>r_continuous</code>为真，那么核心（core）会期望在第一个操作完成后立即进行第二个操作。在这种情况下，第一个操作会完成，但FIFO队列不会被清除。<font color="red"><strong>在这段时间内，FIFO队列不会进一步填充</strong>。</font></li>
<li>当核心处于空闲状态时，对<code>CMD_CONTROL</code>寄存器的写操作会调整<code>r_continuous</code>位</li>
</ul>
</li>
</ul>
</blockquote>
<p><em><strong>Reset the FIFO between bursts, as long as <code>r_continuous</code> isn’t set</strong></em></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> reset_fifo = i_reset || (!r_busy &amp;&amp; (!r_continuous || r_err));</span><br></pre></td></tr></table></figure>

<p>如果输入复位信号<code>i_reset</code>为真，或者核心不忙碌且（不进行连续读取或检测到错误），那么<code>reset_fifo</code>将被设置为真。</p>
<p><strong>Q</strong> : <font color="red">至于这里在 <code>!r_busy == 1</code> 的情况下 r_continuous 和 r_err的变化，我暂时不知道</font></p>
<p><strong>A</strong> ：当不忙碌的时候 <em>! busy</em> ，如果发现 <em>r_continuous no set</em> (e.g. r_continuous &#x3D;&#x3D; 0) , 那么会直接 <code>clear FIFO</code>；</p>
<p><strong>A</strong> ：当没有设置连续突发寄存器的时候，如果 <em>the idle core detect r_err happens</em> ，那么也需要<code>clear FIFO</code>；</p>
<hr>
<blockquote>
<ul>
<li><p><strong>[26]  ! tlast_syncd</strong> (wire type)</p>
<p><u><em><strong>Read only status indicator</strong></em></u>.  Reads 0 if <code>OPT_TLAST_SYNC</code> isn’t set.  If <code>OPT_TLAST_SYNC</code> is set, then this bit indicates whether or not the memory transfer is currently aligned with any stream packets, or whether it is out of synchronization and waiting to sync with the incoming stream.  (只读状态指示器的。如果 <code>OPT_TLAST_SYNC</code> 没有被设置，那么这个状态指示器的值为0。如果 <code>OPT_TLAST_SYNC</code> 被设置了，那么这个位就会指示内存传输是否与任何流数据包对齐，或者它是否处于非同步状态并等待与传入流同步。)</p>
<p>If the IP is <u><em>out of alignment</em></u> and <code>OPT_TLAST_SYNC</code> is set, then the core will synchronize itself automatically by <u><em><strong>holding <code>TREADY</code> high</strong></em></u> and *<u><strong>ignoring data until the first sample after <code>TLAST</code></strong></u>*.</p>
</li>
</ul>
<p><font color="red">如何使用这个功能，需要在后续的过程中不断实践</font></p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span>	write_to_fifo  = </span><br><span class="line">		 sskd_valid </span><br><span class="line">	&amp;&amp; sskd_ready </span><br><span class="line">	&amp;&amp; tlast_syncd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span>	read_from_fifo = </span><br><span class="line">		 M_AXI_WVALID  </span><br><span class="line">	&amp;&amp; M_AXI_WREADY</span><br><span class="line">	&amp;&amp; !axi_abort_pending;</span><br></pre></td></tr></table></figure>

<p>可以暂时的忽略 <em>wite_to_fifo</em> 信号中的 <code>talst_syncd</code> 参数设置。对于 <em>read fifo</em>，只要没有发生<em>abort_pending</em>那么就正常读数据。</p>
<p>∂∂</p>
<h2 id="5-2-sskd-ready-√"><a href="#5-2-sskd-ready-√" class="headerlink" title="5.2  sskd_ready (√)"></a>5.2  sskd_ready (√)</h2><p>关于 [stream_last_signal](#3.1 last_signal )的信息可以参考链接。</p>
<p>本小结关注于， <em>core</em> 如何产生 <em>sskd_ready</em> 接受信号，什么时候接受 <em>axi_stream</em> 的信息。</p>
<blockquote>
<p>We are ready if the FIFO isn’t full and …</p>
<ul>
<li><p>if <u><em><strong>OPT_TREADY_WHILE_IDLE</strong></em></u> is <code>true</code> at which point we ignore incoming data when we aren’t busy,  详细信息见链接 [1.2 parameter](#1.2 parameter)   </p>
</li>
<li><p>if we aren’t resetting the FIFO–that is, if data is actually going into the FIFO</p>
</li>
<li><p>if we are ever out of synchronization–then we can <u><em><strong>ignore data until the next TLAST comes, where we must realign ourselves</strong></em></u> <font color="red">暂时不理解</font></p>
</li>
</ul>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span>	sskd_ready  = </span><br><span class="line">   	<span class="comment">// core_is_active , and the FIFO is not full , can still be writen</span></span><br><span class="line">   	clk_active &amp;&amp; !fifo_full</span><br><span class="line">		&amp;&amp; (OPT_TREADY_WHILE_IDLE</span><br><span class="line">			|| !reset_fifo </span><br><span class="line">       || !tlast_syncd);</span><br></pre></td></tr></table></figure>

<p>clk_active 信号数据 <em>clock gating</em> 的部分不需要理会。</p>
<h2 id="5-3-OPT-TLAST-SYNC"><a href="#5-3-OPT-TLAST-SYNC" class="headerlink" title="5.3 OPT_TLAST_SYNC"></a>5.3 OPT_TLAST_SYNC</h2><p>一个 <code>C code</code>不一定正确，但是方便理解逻辑行为。在这个例子中，当 <code>OPT_TLAST_SYNC</code> 参数被设置为1时，内存地址 <code>addr</code> 只有在接收到 <code>TLAST</code> 信号时才会增加，这样就能确保写操作与传入的数据包保持同步。如果 <code>OPT_TLAST_SYNC</code> 参数被设置为0，那么内存地址 <code>addr</code> 将在每次接收到有效数据时增加，无论 <code>TLAST</code> 信号是否被接收（不过这个部分的 <code>C</code>代码并没有被体现出来）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">end <span class="keyword">else</span> <span class="title">if</span> <span class="params">(tvalid_in &amp;&amp; tready_out)</span> begin</span></span><br><span class="line"><span class="function">    data &lt;</span>= data_in;</span><br><span class="line">    write_enable &lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (OPT_TLAST_SYNC &amp;&amp; tlast_in) begin  <span class="comment">//有问题，不过不妨碍理解</span></span><br><span class="line">        addr &lt;= addr + <span class="number">4</span>;</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>下面涉及到了一个新的寄存器 <code>r_tlast_syncd</code> 使用，首先还是一个简单的但是不一定正确的C代码进行解释：</p>
<ul>
<li>首先检查 <code>OPT_TLAST_SYNC</code> 是否被设置。</li>
<li>如果设置了，我们就检查数据流的最后一个值是否是 <code>TLAST</code>。</li>
<li>如果是，我们就把 <code>r_tlast_syncd</code> 设置为 <code>1</code>。</li>
<li>然后，如果数据流接受了一个新的值，但 FIFO 没有接受，我们就把 <code>r_tlast_syncd</code> 设置为 <code>0</code>，表示数据流失去了同步。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们有一个数据流和一个FIFO</span></span><br><span class="line">reg [<span class="number">7</span>:<span class="number">0</span>] data_stream;</span><br><span class="line">reg [<span class="number">7</span>:<span class="number">0</span>] fifo;</span><br><span class="line">reg r_tlast_syncd;</span><br><span class="line">reg OPT_TLAST_SYNC;</span><br><span class="line"></span><br><span class="line">always @(posedge clk) begin</span><br><span class="line">  <span class="comment">// 如果用户设置了OPT_TLAST_SYNC</span></span><br><span class="line">  <span class="keyword">if</span> (OPT_TLAST_SYNC) begin</span><br><span class="line">    <span class="comment">// 如果数据流的最后一个值是TLAST</span></span><br><span class="line">    <span class="keyword">if</span> (data_stream == TLAST) begin</span><br><span class="line">      r_tlast_syncd &lt;= <span class="number">1&#x27;b</span>1;  <span class="comment">// 设置r_tlast_syncd为1</span></span><br><span class="line">    end</span><br><span class="line">    <span class="comment">// 如果数据流接受了一个新的值，但FIFO没有接受</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (data_stream != fifo) begin</span><br><span class="line">      r_tlast_syncd &lt;= <span class="number">1&#x27;b</span>0;  <span class="comment">// 设置r_tlast_syncd为0，表示数据流失去了同步</span></span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<hr>
<blockquote>
<p>If the user has set <code>OPT_TLAST_SYNC</code>, then he wants to make certain that <u><em><strong>we don’t start writing until the first stream value after the TLAST packet</strong></em></u> indicating an end of packet.</p>
<p>For this cause, we’ll maintain an <code>r_tlast_syncd</code> value <strong>indicating</strong> that the last value was a <code>TLAST</code>.  If, at any time <strong><u><em>afterwards</em></u></strong>, <u><em><strong>a value is accepted into the stream but not  into the FIFO</strong></em></u>, then the stream is now <u><em><strong>out of sync</strong></em></u> and <code>r_tlast_syncd</code> <em><u>will drop.</u></em></p>
<p>Note, this doesn’t catch the case where the FIFO can’t keepup.  Lost data (might be) caught by overflow below.</p>
</blockquote>
<ul>
<li><p><strong>[26]  ! tlast_syncd</strong></p>
<p><u><em><strong>Read only status indicator</strong></em></u>.  </p>
<p>Reads 0 if <code>OPT_TLAST_SYNC</code> isn’t set.  If <code>OPT_TLAST_SYNC</code> is set, then this bit indicates whether or not the memory transfer is currently aligned with any stream packets, or whether it is out of synchronization and waiting to sync with the incoming stream.  (只读状态指示器的。如果 <code>OPT_TLAST_SYNC</code> 没有被设置，那么这个状态指示器的值为0。如果 <code>OPT_TLAST_SYNC</code> 被设置了，那么这个位就会指示内存传输是否与任何流数据包对齐，或者它是否处于非同步状态并等待与传入流同步。)</p>
<p>If the IP is <u><em>out of alignment</em></u> and <code>OPT_TLAST_SYNC</code> is set, then the core will synchronize itself automatically by <u><em><strong>holding <code>TREADY</code> high</strong></em></u> and *<u><strong>ignoring data until the first sample after <code>TLAST</code></strong></u>*.</p>
</li>
</ul>
<p>如果用户设置了<code>OPT_TLAST_SYNC</code>，则代码会确保在接收到表示数据包结束的<code>TLAST</code>信号后的第一个数据流值之前不会开始写入。为此，代码维护了一个<code>r_tlast_syncd</code>值，表示最后一个值是否为<code>TLAST</code>。如果在此后的任何时间，一个值被接受到数据流中但没有被接受到FIFO中，那么数据流现在就会失去同步，<code>r_tlast_syncd</code>就会被清零。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">generate</span> <span class="keyword">if</span> (OPT_TLAST_SYNC)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">reg</span>	r_tlast_syncd;</span><br><span class="line">	<span class="comment">// If the user has set OPT_TLAST_SYNC, then he wants to make</span></span><br><span class="line">	<span class="comment">// certain that we don&#x27;t start writing until the first stream</span></span><br><span class="line">	<span class="comment">// value after the TLAST packet indicating an end of packet.</span></span><br><span class="line">	<span class="comment">// For this cause, we&#x27;ll maintain an r_tlast_syncd value</span></span><br><span class="line">	<span class="comment">// indicating that the last value was a TLAST.  If, at any</span></span><br><span class="line">	<span class="comment">// time afterwards, a value is accepted into the stream but not</span></span><br><span class="line">	<span class="comment">// into the FIFO, then the stream is now out of sync and</span></span><br><span class="line">	<span class="comment">// r_tlast_syncd will drop.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Note, this doesn&#x27;t catch the case where the FIFO can&#x27;t keep</span></span><br><span class="line">	<span class="comment">// up.  Lost data (might be) caught by overflow below.</span></span><br><span class="line">	<span class="keyword">initial</span>	r_tlast_syncd = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">	<span class="keyword">if</span> (!S_AXI_ARESETN)</span><br><span class="line">		r_tlast_syncd &lt;= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (sskd_valid &amp;&amp; sskd_ready)</span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span> (sskd_last)</span><br><span class="line">			r_tlast_syncd &lt;= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (reset_fifo)</span><br><span class="line">			r_tlast_syncd &lt;= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">assign</span>	tlast_syncd = r_tlast_syncd;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// If the option isn&#x27;t set, then we are always synchronized.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="keyword">assign</span>	tlast_syncd = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Verilator lint_off UNUSED</span></span><br><span class="line">	<span class="keyword">wire</span> unused_tlast_sync;</span><br><span class="line">	<span class="keyword">assign</span>	unused_tlast_sync = &amp;&#123; <span class="number">1&#x27;b0</span>, sskd_last &#125;;</span><br><span class="line">	<span class="comment">// Verilator lint_on  UNUSED</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">endgenerate</span></span><br></pre></td></tr></table></figure>



<h2 id="5-4-sfifo"><a href="#5-4-sfifo" class="headerlink" title="5.4 sfifo"></a>5.4 <u>sfifo</u></h2><blockquote>
<p><code>OPT_ASYNCMEM</code>.  The default FIFO implementation uses an asynchronous memory read, which will return the result in the same clock it is requested within.  <u><em>This forces the FIFO to use distributed RAM</em></u>.  </p>
<p>For those architectures that don’t have distributed RAM, or those designs that need to use block RAM, <u><em>this flag should be set to zero</em></u>.</p>
</blockquote>
<h1 id="6-outgoing-AXI（full）protocol"><a href="#6-outgoing-AXI（full）protocol" class="headerlink" title="6. outgoing AXI（full）protocol"></a>6. outgoing AXI（full）protocol</h1><h2 id="6-1-Hiding-computations"><a href="#6-1-Hiding-computations" class="headerlink" title="6.1 Hiding computations"></a>6.1 Hiding computations</h2><h3 id="1-two-clock-cycle-computation"><a href="#1-two-clock-cycle-computation" class="headerlink" title="1. two clock cycle computation"></a>1. two clock cycle computation</h3><blockquote>
<p>our goal :</p>
<ul>
<li><p><strong>Our goal</strong> is to be able to maintain 100% throughput across our bus. That means that we should be able to transfer one beat of information, whether <code>WVALID &amp;&amp; WREADY</code> or <code>RVALID &amp;&amp; RREADY</code>, <u><em>on every clock cycle.</em></u> </p>
</li>
<li><p>Our goal is also to <u><em>issue bus requests as soon as</em></u> we either have the data available for any write requests, or alternatively as soon as we have the space available for any read requests. </p>
<p>If our burst length is going to be anything more than 2 beats, does it really matter if we take a clock or two to calculate these values as long as they are calculated and issued early enough so as not to impact performace?</p>
</li>
</ul>
</blockquote>
<p>​						<strong>（Fig 4. Hiding write address calculations）</strong></p>
<p><img src="https://zipcpu.com/img/axiaddr-limits/write-recycle.svg" alt="img"></p>
<p>我们默认为在 <code>AXI_AWVALID</code> 和 <code>AXI_WVALID</code> 同时 <em>asseted</em> 的时候，象征着 <em>start_burst</em> . 需要一个时钟周期计算下一个 <em>AW request awvalid</em> ，还需要一个时钟周期 <em>assert the next awvalid</em>。</p>
<blockquote>
<p>The burst would start by setting both <code>AWVALID</code> and <code>WVALID</code> at the same time. </p>
<p>The core could then <em><u>take one clock cycle to be able to regenerate the next <code>AWVALID</code></u>.</em> However, we wouldn’t set it until after sending <code>WLAST</code>. Therefore, <u><em><strong>as long as the burst is longer than two beats, we won’t suffer any loss.</strong></em></u> </p>
</blockquote>
<p>​					<strong>（Fig 5. Hiding read address calculations）</strong></p>
<p><img src="https://zipcpu.com/img/axiaddr-limits/write-recycle.svg" alt="img"></p>
<blockquote>
<p>Reads are similar, but having the primary difference that read requests are not synchronized with the read data. </p>
<p>If we can keep our processing down to every other clock cycle, then we should be able to issue multiple read requests before the first result is ever returned. Further, after issuing some (user design dependent) number of read requests, we’d have to pause anyway to wait for uncommitted space available for more read returns. (不过这些功能目前不能实现)</p>
</blockquote>
<p>小总结：上面的信息和图形向我们展示，最少两个时钟周期就可以将 <em>master request</em> 进行再次请求。如果一次 <em>burst</em> 的处理市场大于两个时钟周期，那么这一段计算的时间就可以被掩盖，仿佛计算并没有花费时间。</p>
<h3 id="2-phantom"><a href="#2-phantom" class="headerlink" title="2. phantom"></a>2. phantom</h3><p><strong>Q</strong> : What would happen if the slave <u><em>didn’t accept our <code>AxVALID</code> signal immediately</em></u>? </p>
<p><strong>A</strong>: it could impact our throughput <u><em><strong>if we waited for the burst to be accepted before calculating the next burst’s parameters</strong></em></u>.</p>
<blockquote>
<p>the idle came out <code>phantom signal</code></p>
<p>Author started using <code>phantom</code> signals  named something like <code>phantom_read</code>, <code>phantom_write</code>, or perhaps even <code>phantom_start</code>. The idea is that <u><em><strong>all of our burst calculation logic can take place when the <code>phantom</code> signal is true</strong></em></u>. We can then <u><em><strong>hide this logic inside any potential stall signals</strong></em></u>.</p>
</blockquote>
<p>​								<strong>(Fig 6.”Phantom” start signals)</strong></p>
<p><img src="https://zipcpu.com/img/axiaddr-limits/phantom-starts.svg" alt="img"></p>
<ol>
<li><p>First, we’d have our <code>start_transaction</code> signal–whatever it is. This is a <code>combinatorial signal</code>, and <u><em><strong>simply tells us that it’s time to start a new burst</strong></em></u>.</p>
</li>
<li><p>Then, <font color="red">on the next cycle</font>, <code>AxVALID</code> would be high–indicating <u><em><strong>a registered transaction start</strong></em></u>. On this same cycle, <font color="red">the <code>phantom_write</code> or <code>phantom_read</code> signal would also be high–<u><em>but only for one cycle only</em></u></font>. This would be a signal internal to the design that registered values (not the actual AXI protocol signals) can be adjusted <u>as though(好像)</u> the <u><em>burst request had actually taken place</em></u>.</p>
</li>
<li><p>On the <u><em><strong>third cycle</strong></em></u>, the <code>phantom</code> signal would be <font color="red">low again–even though <code>AxVALID</code> might stay high until the channel was no longer stalled.</font> <strong><font color="orange">This is the clock we’ll take to recycle our addressing</font></strong>. It’s also the first cycle where the <code>start_transaction</code> <u><em><strong>combinatorial signal might be high again</strong></em></u>.(靠后的几个时钟周期就是这样， 信号<em>start_transaction</em> 拉低之后，一个虚假的 <u><em>registered phantom signal</em></u> 仅仅会拉高一个时钟周期，无论真正的 <em>valid</em> 信号是否被接收，这个信号只是预示新的 <em>axi_request</em> 信号可以开始计算了，在下下个时钟信号的时候 <em>start transaction</em> 在此拉高表示又可以开始了。)</p>
<p>This is partially what’s being shown in Fig. 6 above. The <code>phantom_read</code> signal is <strong><font color="orange">only high for one clock tick, but on the first clock of any new read request cycle</font></strong>. That way, if it takes a couple cycles for the read to be acknowledged, we’ll be ready for the next cycle at that time.</p>
</li>
<li><p>Once the <code>AxVALID &amp;&amp; AxREADY</code> indicates a request has been accepted, we then can set <code>start_transaction</code> on the next cycle and the process repeats until the transfer is complete.</p>
</li>
</ol>
<h2 id="6-2-Example-S2MM"><a href="#6-2-Example-S2MM" class="headerlink" title="6.2 Example: S2MM"></a>6.2 Example: S2MM</h2><p>参考的链接：<a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2020/06/16/axiaddr-limits.html">https://zipcpu.com/blog/2020/06/16/axiaddr-limits.html</a></p>
<blockquote>
<p>This figure shows a memory copy of nine words, where the first burst <code>isn’t aligned</code> on a burst boundary, and so <em><u>it takes two clock cycles</u></em>. </p>
</blockquote>
<img src="https://zipcpu.com/img/axiaddr-limits/s2mm-trace.svg" alt="img" style="zoom:67%;" />

<p>首先 <em>core</em> 的启动之前，需要写入一些配置数据，这些数据包括：需要写入的地址、写入数据的长度。最后用一个 <em>start</em> 信号(e.g. 图中的 <strong>GO</strong> 信号)。</p>
<blockquote>
<p>This one also starts with a user <u><em><strong>issuing a configuration command</strong></em></u> containing the <strong>memory address</strong> to copy to as well as <strong>the length</strong> <u><em>of the memory copy</em></u>. This configuration <u><em>ends with the user issuing a command to start</em></u>.</p>
</blockquote>
<h3 id="1-new-address-4KB"><a href="#1-new-address-4KB" class="headerlink" title="1. new_address &amp; 4KB"></a>1. new_address &amp; 4KB</h3><ul>
<li><strong><u>One flag</u></strong>, <code>aw_needs_alignment</code>, records whether or not <em><strong><font color="red">the first burst </font></strong> will be artificially limited to the burst boundary</em>.</li>
<li><strong><u>One flag</u></strong> checks for <u><em>multiple bursts</em></u> assuming that <u><em>the addresses will be incrementing and bursts will be 256 beats in length</em></u>, whereas the other flag checks whether the transfer would require multiple bursts of 16-beats in length.</li>
<li><strong>Two other flags</strong> record whether or not the user has <u><em>asked for multiple bursts</em></u>.</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aw_multiple_full_bursts  &lt;= |new_widelen[LGLEN-<span class="number">1</span>:(ADDRLSB+LGMAXBURST)];</span><br><span class="line">aw_multiple_fixed_bursts &lt;= |new_widelen[LGLEN-<span class="number">1</span>:(ADDRLSB+LGMAX_FIXED_BURST)];</span><br></pre></td></tr></table></figure>

<p>这两个信号很好理解。 如果是检查是否有 <em>multiple_full_bursts</em> 多个突发传送发生 。首先知道 <code>LGLEN</code> 参数表示的是 <em>C_AXI_ADDR_WIDTH</em> 的 <em>axifull</em> 地址宽度， <code>ADDRLSB</code> 是 <code>log2(C_AXI_DATA_width)</code> ， 表示一次 <em>full_axi_data</em> <em>transfer</em> 将会传输的 <em>Byte</em> 数量。相关参数参考 [LGMAXBURST](#1.3 localparam)、[LGMAX_FIXED_BURST](#1.3 localparam)、 [ADDRLSB](#1.3 localparam)参考链接。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"> <span class="comment">//when we set the burst configuration ,the core_state is idle</span></span><br><span class="line"><span class="keyword">if</span> (!r_busy)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">   <span class="comment">// 这个信号表示， AW是否符合 address align</span></span><br><span class="line">	aw_needs_alignment &lt;= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (|new_wideaddr[ADDRLSB +: LGMAXBURST])</span><br><span class="line">   <span class="comment">// if this is ture ,</span></span><br><span class="line">   <span class="comment">//		means that : the address we want to write doesn&#x27;t align </span></span><br><span class="line">   <span class="comment">//		with the 4KB burst boundry , or the other burst boundary </span></span><br><span class="line">   <span class="comment">//		depend on FIFO size</span></span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span> (|new_widelen[LGLEN-<span class="number">1</span>:(LGMAXBURST+ADDRLSB)])</span><br><span class="line">       <span class="comment">//	the length of the burst will break the 4KB boundary</span></span><br><span class="line">			aw_needs_alignment &lt;= <span class="number">1</span>;</span><br><span class="line">     </span><br><span class="line">		<span class="keyword">if</span> (~new_wideaddr[ADDRLSB +: LGMAXBURST]</span><br><span class="line">				&lt; new_widelen[ADDRLSB +: LGMAXBURST])</span><br><span class="line">       <span class="comment">// the last address of this burst will break the 4KB boundary</span></span><br><span class="line">			aw_needs_alignment &lt;= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>We will get to know how many bytes added to the address named <code>new_widelen</code> can break the <code>4KB burst Boundary</code>。If situation ： <code>~new_wideaddr[ADDRLSB +: LGMAXBURST]</code> &lt; <code> new_widelen[ADDRLSB +: LGMAXBURST])</code> happen ,  the <u><em>last address of this burst</em></u> will over  the <code>4KB burst Boundary</code>。</p>
<h3 id="2-aw-remaining"><a href="#2-aw-remaining" class="headerlink" title="2.  aw__*__remaining"></a>2.  aw__*__remaining</h3><p>知道两个信号代表的意义：</p>
<ul>
<li><code>aw_none_remaining</code>， If this signal is <strong>set</strong> ,means there is no <u><em><strong>remained AW request</strong></em></u> should be handled. </li>
<li><code>aw_requests_remaining</code> , register the <u><em>number of aw write</em></u> burst remaining.</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	aw_none_remaining = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">initial</span>	aw_requests_remaining = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<hr>
<p>Then what happen if the core is idle (<em>e.g. the register r_busy &#x3D;&#x3D; 0</em> )</p>
<p>In the <u><em>beinning of one burst</em></u> , the siganl <code>aw_requests_remaining</code> is equal to <u><em>the axi-lite control cmd transfer length information named</em></u> <code>cmd_length_w</code> ; If the <code>cmd_length_w</code> is too large (e.g. <code>|cmd_length_w[LGLENW-1:LGMAXBURST+1 == 1]</code>) ,  means there are <u>multiple burst</u> the core should transfer , the number of burst is two or more.</p>
<blockquote>
<p>This core is a bit different from the others above in that it keeps track of an <code>aw_multiple_bursts_remaining</code> flag. </p>
<p>This <strong>flag</strong> is equivalent to whether or not two or more bursts are remaining. To maintain this equivalence, it is set and maintained together with <u><em>the counter containing the amount of remaining data left to transfer</em></u> (e.g. <code>aw_requests_remaining</code>).</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!r_busy)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	aw_requests_remaining &lt;= cmd_length_w;</span><br><span class="line">	aw_none_remaining     &lt;= zero_length;</span><br><span class="line">	aw_multiple_bursts_remaining &lt;= |cmd_length_w[LGLENW-<span class="number">1</span>:LGMAXBURST+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p><font color="red">后续需要在此看看 zero_length 是什么</font></p>
<p><font color="red"> cmd_abort 的逻辑不太清楚，需要回顾</font></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (cmd_abort || axi_abort_pending)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	aw_requests_remaining &lt;= <span class="number">0</span>;</span><br><span class="line">	aw_none_remaining &lt;= <span class="number">1</span>;</span><br><span class="line">	aw_multiple_bursts_remaining &lt;= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>The <u><em>remaining length</em></u> is <strong>updated</strong> any time <u><em>a new burst request is issued</em></u>. What’s not apparent from <a target="_blank" rel="noopener" href="https://github.com/ZipCPU/wb2axip/blob/3fd18664246707f06924fddc5c8a5de4b62517fc/rtl/axis2mm.v#L965-L972">these lines</a> is that the number of items remaining is <a target="_blank" rel="noopener" href="https://github.com/ZipCPU/wb2axip/blob/3fd18664246707f06924fddc5c8a5de4b62517fc/rtl/axis2mm.v#L917-L929">calculated combinatorially from the current number of items minus the number in <code>AWLEN</code></a>. </p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	aw_next_remaining = aw_requests_remaining</span><br><span class="line">		+ &#123; &#123;(LGLENW-<span class="number">8</span>)&#123;phantom_start&#125;&#125;,</span><br><span class="line">				(phantom_start) ? ~M_AXI_AWLEN : <span class="number">8&#x27;h00</span>&#125;;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>That way I can use one new remaining length signal in three separate non-blocking assignments.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (phantom_start)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	aw_requests_remaining &lt;= aw_next_remaining;</span><br><span class="line">	aw_none_remaining			&lt;= !aw_multiple_bursts_remaining &amp;&amp;</span><br><span class="line">   												 (aw_next_remaining[LGMAXBURST:<span class="number">0</span>] == <span class="number">0</span>);</span><br><span class="line">	aw_multiple_bursts_remaining</span><br><span class="line">												&lt;= |aw_next_remaining[LGLENW-<span class="number">1</span>:LGMAXBURST+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="6-3-FIFO-Space-available"><a href="#6-3-FIFO-Space-available" class="headerlink" title="6.3 FIFO (Space available)"></a>6.3 FIFO (Space available)</h2><blockquote>
<p><strong>purpose</strong> : you don’t want to start a transaction <u><em>until you know you can finish it</em></u>. </p>
<ul>
<li>For writes, this means you don’t want to start the transaction until you have the data available somewhere–likely in a local FIFO. </li>
<li>For reads, you don’t want to issue the read request until there’s somewhere for the returned data to go.</li>
</ul>
</blockquote>
<p><strong><font color="red">means you need to keep track of a counter of either the data available to be written, or the space available to be read into.</font></strong>(下面的代码可能是伪代码)</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// For writes, the amount of data available in the FIFO which can be</span></span><br><span class="line"><span class="comment">// sent across the interface</span></span><br><span class="line"><span class="keyword">assign</span>	data_available = fifo_fill;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For reads, the amount of empty space available in the FIFO which</span></span><br><span class="line"><span class="comment">// can be filled with a subsequent read.</span></span><br><span class="line"><span class="keyword">assign</span>	space_available = FIFO_SIZE - fifo_fill;</span><br></pre></td></tr></table></figure>

<p>对于 <em>write</em> 的部分代码大致如下，<font color="red">不过，通过我的前期了解，这里的 AW outstanding 最大只能是1，burst 之间只能保持 back on back 的状态。</font></p>
<h3 id="1-fifo-write"><a href="#1-fifo-write" class="headerlink" title="1. fifo write"></a>1. <u>fifo write</u></h3><blockquote>
<p>Data then enters the FIFO any time <code>fifo_write</code> is true. Once enough data has accumulated to form a burst write request, the <code>data_available</code> counter is dropped by the length of that request–<u><em><strong><font color="red">even before the data is read out of the FIFO</font></strong></em></u>.</p>
<p>确保FIFO的写入请求是基于当前积累的数据，而不受之前写入的数据的影响。通过在实际数据读取之前减去计数器，确保计数器的值总是代表FIFO中实际可用的数据量。</p>
</blockquote>
<p>​									<strong>（Fig 7. Data Available）</strong></p>
<img src="https://zipcpu.com/img/axiaddr-limits/data-available.svg" alt="img" style="zoom:50%;" />

<p>作者的比喻如下：</p>
<blockquote>
<p>You might think of this like a chemical production factory, as depicted in Fig. 7. </p>
<p>As new product is <strong>created</strong>, it gets placed into a giant tank. As that product gets <strong>sold</strong>, the amount of product remaining in the tank that hasn’t yet been sold is the amount that’s available to be sold to the next customer. Hence, <u><em>even if the tank is full, there might not be a full tank’s worth of product available to be sold</em></u>. </p>
<p><u><em><strong>The amount available for sale, or in this case transfer, is what we keep track of.</strong></em></u> <font color="red">这才是 <code>fifo counter</code> 在一直追踪的数据</font></p>
</blockquote>
<hr>
<h3 id="2-fifo-read"><a href="#2-fifo-read" class="headerlink" title="2. fifo read"></a>2. <u>fifo read</u></h3><blockquote>
<p><strong>Purpose</strong> : Counting uncommitted <em>empty</em> space. </p>
<p>That count would start with the full FIFO’s size as space available, and would then be <strong><u>decremented</u></strong> on any <code>phantom_read</code> signal. Once the data was (later) read out of the FIFO (e.g. the siganl phantom is <strong>true</strong>), you could return it to the count of uncommitted space available.					</p>
</blockquote>
<p>​						<strong>（Fig 8. Uncommitted Space Available）</strong></p>
<img src="https://zipcpu.com/img/axiaddr-limits/space-available.svg" alt="img" style="zoom: 50%;" />

<blockquote>
<p>黄色部分代表已经被送入 FIFO的部分数据</p>
<p>灰色部分代表已经被接受 request ，但是还没有传输进入 FIFO 的数据</p>
<p>白色部分代表剩余的可用空间。</p>
</blockquote>
<p>对于这个也有一个比喻：This counter would be analogous to something like a coal bin at a power plant. </p>
<p>One of the responsibilities of the staff at the power plant is to make certain that it never runs out of coal while in operation. They will therefore purchase train loads of coal to fill up the coal bin. <u><em><strong><font color="red">It costs money, however, for the train to have to wait in order to unload</font></strong></em></u>. </p>
<p>Therefore, you <u><em><strong><font color="red">wouldn’t request a new trainload of coal until there’s room in the coal bin for not only the new trainload</font></strong></em></u>, but also for <u><em><strong>all other trains to empty in the bin that may have been previously ordered but not (yet) arrived</strong></em></u>. That’s the idea behind the “space available” calculation used with reads.</p>
<blockquote>
<p>不会在煤仓没有足够空间装下新的一车煤炭，以及可能已经预订但尚未到达的所有其他火车的煤炭时，又去请求新的一车煤炭。</p>
</blockquote>
<h3 id="3-whether-multiple-burst-data"><a href="#3-whether-multiple-burst-data" class="headerlink" title="3.  whether multiple burst data"></a>3.  whether <u>multiple burst data</u></h3><p>Combitorical ：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	new_data_available = data_available;</span><br><span class="line">	<span class="keyword">case</span>(&#123; fifo_write, phantom_write &#125;)</span><br><span class="line">	<span class="number">2&#x27;b00</span>: <span class="keyword">begin</span> <span class="keyword">end</span></span><br><span class="line">	<span class="number">2&#x27;b10</span>: new_data_available = data_available + <span class="number">1</span>;</span><br><span class="line">	<span class="number">2&#x27;b01</span>: new_data_available = data_available - AWLEN -<span class="number">1</span>;</span><br><span class="line">	<span class="number">2&#x27;b11</span>: new_data_available = data_available - AWLEN;</span><br><span class="line">	<span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>时序部分：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> S_AXI_ACLK)</span><br><span class="line"><span class="keyword">if</span> (!S_AXI_ARESETN)</span><br><span class="line">	data_available &lt;= <span class="number">0</span>;</span><br><span class="line">	multiple_bursts_available &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">	data_available &lt;= new_data_available;</span><br><span class="line">	multiple_bursts_available &lt;= |new_data_available[LGFIFO:LGMAXBURST];</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>







<h2 id="6-4-Counter-to-keep-track"><a href="#6-4-Counter-to-keep-track" class="headerlink" title="6.4 Counter to keep track"></a>6.4 Counter to keep track</h2><blockquote>
<p>Some counters to keep track of our state</p>
</blockquote>
<h3 id="1-Calculate-the-next-data-remaing"><a href="#1-Calculate-the-next-data-remaing" class="headerlink" title="1. Calculate the next data_remaing"></a>1. Calculate the next data_remaing</h3><blockquote>
<p>Count the number of <u>word writes left to be requested</u>, <strong>starting</strong> with the <u>overall command length</u> and then <strong>reduced</strong> by <code>M_AWLEN</code> on each address write</p>
</blockquote>
<p>the combitorical logic is as below:</p>
<ul>
<li>The <code>aw_next_remaing</code> is start with the number of <code>aw_request_remaing</code>(e.g. using the information of last transaction)</li>
<li>Then judge whether core should do more thing if the implication named phantom is asserted.<ul>
<li>其中的逻辑十分清楚，但是需要认真的研读。</li>
<li>每次触发 <code>phantom</code> 的时候需要减少 <code>awlen+1</code>的数据数量(e.g. <code>-(M_AXI_AWLEN+1)</code> )</li>
<li>对于有符号数据可以进行取反加1(e.g. <code>- AWLEN == (~M_AXI_AWLEN+1)</code> )</li>
<li>所以最终可以转化为 <code>(~M_AXI_AWLEN+1) - 1 == ~M_AXI_AWLEN</code></li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="comment">// aw_next_remaining = aw_requests_remaining;</span></span><br><span class="line">	<span class="comment">// if (phantom_start)</span></span><br><span class="line">	<span class="comment">//	aw_next_remaining = aw_requests_remaining</span></span><br><span class="line">	<span class="comment">//		+  (~&#123;&#123; (LGLENW-8)&#123;1&#x27;b0&#125;&#125;, M_AXI_AWLEN &#125;);</span></span><br><span class="line">	<span class="comment">//		// - (M_AXI_AWLEN+1)</span></span><br><span class="line">	<span class="comment">//		// + (~M_AXI_AWLEN+1) - 1</span></span><br><span class="line">	<span class="comment">//		// + ~M_AXI_AWLEN</span></span><br><span class="line">	aw_next_remaining = aw_requests_remaining</span><br><span class="line">		+ &#123; &#123;(LGLENW-<span class="number">8</span>)&#123;phantom_start&#125;&#125;,</span><br><span class="line">				(phantom_start) ? ~M_AXI_AWLEN : <span class="number">8&#x27;h00</span>&#125;;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>以上就是如何进行 <em>number of remaining write data</em> 的组合逻辑计算。</p>
<h3 id="2-r-pre-start"><a href="#2-r-pre-start" class="headerlink" title="2. r_pre_start"></a>2. r_pre_start</h3><blockquote>
<p>Purpose : Only once the user issues the start command do we know which of the two will limits will constrain us. That means we’re going to need <font color="red"><u><em><strong>a flag to let us know that this initial burst computation isn’t (quite) done yet</strong></em></u>.</font> </p>
<p>That’s the purpose of the <code>r_pre_start</code> flag</p>
</blockquote>
<img src="https://zipcpu.com/img/axiaddr-limits/s2mm-trace.svg" alt="img" style="zoom:60%;" />

<p>注意看上面 <code>r_pre_start</code>信号的波形图</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (!r_busy)</span><br><span class="line">	r_pre_start &lt;= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	r_pre_start &lt;= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>可以发现信号 <code>w_cmd_start</code> 该逻辑信号只 <em>keep one clokc cycle high along</em>。这个组合逻辑信号将会拉高 <em>r_busy</em> 信号，<em>r_busy</em> 信号也会在下一个时钟周期拉低 <em>r_pre_start</em> 信号，告诉了一个信息：预准备的时间过去了。</p>
<img src="https://github.com/xlxwzybds/X-Y-xlxwzybds-github-pages/blob/main/S2MM/s2mm_01.jpg?raw=true" alt="s2mm_01.jpg" style="zoom: 67%;" />

<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;signal: [</span><br><span class="line">  &#123;name: &#x27;clk&#x27;, wave: &#x27;P.....|...&#x27;&#125;,</span><br><span class="line">  &#123;name: &#x27;w_cmd_start&#x27; , wave : &#x27;<span class="number">0</span><span class="variable">.10</span>...&#x27;&#125;,</span><br><span class="line">  &#123;name: &#x27;r_busy&#x27; , wave : &#x27;<span class="number">0</span>.<span class="variable">.1</span>...&#x27;&#125;,</span><br><span class="line">  &#123;name: &#x27;r_pre_start&#x27; , wave : &#x27;<span class="number">1</span>..<span class="variable">.0</span>..&#x27;&#125;</span><br><span class="line">]&#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-aw-needs-alignment"><a href="#3-aw-needs-alignment" class="headerlink" title="3. aw_needs_alignment"></a>3. aw_needs_alignment</h3><ul>
<li><strong><u>One flag</u></strong>, <code>aw_needs_alignment</code>, records whether or not <em><strong><font color="red">the first burst </font></strong> will be artificially limited to the burst boundary</em>.</li>
<li><strong><u>One flag</u></strong> checks for <u><em>multiple bursts</em></u> assuming that <u><em>the addresses will be incrementing and bursts will be 256 beats in length</em></u>, whereas the other flag checks whether the transfer would require multiple bursts of 16-beats in length.</li>
<li><strong>Two other flags</strong> record whether or not the user has <u><em>asked for multiple bursts</em></u>.</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aw_multiple_full_bursts  &lt;= |new_widelen[LGLEN-<span class="number">1</span>:(ADDRLSB+LGMAXBURST)];</span><br><span class="line">aw_multiple_fixed_bursts &lt;= |new_widelen[LGLEN-<span class="number">1</span>:(ADDRLSB+LGMAX_FIXED_BURST)];</span><br></pre></td></tr></table></figure>

<p>这两个信号很好理解。 如果是检查是否有 <em>multiple_full_bursts</em> 多个突发传送发生 。首先知道 <code>LGLEN</code> 参数表示的是 <em>C_AXI_ADDR_WIDTH</em> 的 <em>axifull</em> 地址宽度， <code>ADDRLSB</code> 是 <code>log2(C_AXI_DATA_width)</code> ， 表示一次 <em>full_axi_data</em> <em>transfer</em> 将会传输的 <em>Byte</em> 数量。相关参数参考 [LGMAXBURST](#1.3 localparam)、[LGMAX_FIXED_BURST](#1.3 localparam)、 [ADDRLSB](#1.3 localparam)参考链接。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"> <span class="comment">//when we set the burst configuration ,the core_state is idle</span></span><br><span class="line"><span class="keyword">if</span> (!r_busy)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">   <span class="comment">// 这个信号表示， AW是否符合 address align</span></span><br><span class="line">	aw_needs_alignment &lt;= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (|new_wideaddr[ADDRLSB +: LGMAXBURST])</span><br><span class="line">   <span class="comment">// if this is ture ,</span></span><br><span class="line">   <span class="comment">//		means that : the address we want to write doesn&#x27;t align </span></span><br><span class="line">   <span class="comment">//		with the 4KB burst boundry , or the other burst boundary </span></span><br><span class="line">   <span class="comment">//		depend on FIFO size</span></span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span> (|new_widelen[LGLEN-<span class="number">1</span>:(LGMAXBURST+ADDRLSB)])</span><br><span class="line">       <span class="comment">//	the length of the burst will break the 4KB boundary</span></span><br><span class="line">			aw_needs_alignment &lt;= <span class="number">1</span>;</span><br><span class="line">     </span><br><span class="line">		<span class="keyword">if</span> (~new_wideaddr[ADDRLSB +: LGMAXBURST]</span><br><span class="line">				&lt; new_widelen[ADDRLSB +: LGMAXBURST])</span><br><span class="line">       <span class="comment">// the last address of this burst will break the 4KB boundary</span></span><br><span class="line">			aw_needs_alignment &lt;= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>We will get to know how many bytes added to the address named <code>new_widelen</code> can break the <code>4KB burst Boundary</code>。If situation ： <code>~new_wideaddr[ADDRLSB +: LGMAXBURST]</code> &lt; <code> new_widelen[ADDRLSB +: LGMAXBURST])</code> happen ,  the <u><em>last address of this burst</em></u> will over  the <code>4KB burst Boundary</code>。</p>
<h2 id="burst-outstanding"><a href="#burst-outstanding" class="headerlink" title="burst outstanding"></a>burst outstanding</h2><blockquote>
<p><strong>Purpose</strong> : three flag signal telling the core: </p>
<ul>
<li><p>if the core is dealing with the <strong><u><em>last</em></u></strong> burst transaction ?</p>
</li>
<li><p>if the core has <u><strong>no more</strong></u> burst transaction left to be  handled ?</p>
</li>
<li><p><u><em><strong>how many burst are still waited</strong></em></u> to be handled this clock cycle ?</p>
</li>
</ul>
<p><strong>Description</strong> :   Count the <u>number of bursts outstanding</u>–these are the number of <code>AWVALIDs</code> that have been accepted, but for which the <code>BVALID</code> has not (yet) been returned.</p>
<p>(实际上好像只有支持 back on back 的 <em>AW outstanding</em>)  </p>
</blockquote>
<p>Signal declaration and the  data initialized as below :</p>
<ul>
<li><code>aw_last_outstanding</code> , if asserted means only one <u>AW write request</u> left to be handled.</li>
<li><code>aw_none_outstanding</code>, if asserted means no more <u>AW write request</u> need to be handled.</li>
<li><code>aw_bursts_outstanding</code>, the <u>number of burst</u> in aw channel left to be accepted.</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	aw_last_outstanding   = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">initial</span>	aw_none_outstanding   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">initial</span>	aw_bursts_outstanding = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>下面的代码中 <code>phantom</code> imply that there is <u>a outstanding address</u> request should be handled later.  The situation(e.g. <code>M_AXI_BVALID &amp;&amp; M_AXI_BREADY</code>) means a request has been dealed.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">case</span> (&#123; phantom_start, M_AXI_BVALID &amp;&amp; M_AXI_BREADY &#125;)</span><br></pre></td></tr></table></figure>

<p>Let’s begin !</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2&#x27;b01</span>:	<span class="keyword">begin</span></span><br><span class="line">   <span class="comment">// this clock the core doesn&#x27;t recognize that an outstanding write request</span></span><br><span class="line">   <span class="comment">// but recognize there is a handshake happen on the B channel.</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// the number of burst waited to be transfer should minus 1.</span></span><br><span class="line">	aw_bursts_outstanding &lt;= aw_bursts_outstanding - <span class="number">1</span>;</span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// if the number of burst waited to be transfered is equal to 1, on the next</span></span><br><span class="line">   <span class="comment">// clock there will be no more write_address request need to accepted.</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// aw_none_outstanding &lt;= 1; means no more AW channel request</span></span><br><span class="line">	aw_none_outstanding &lt;= (aw_bursts_outstanding == <span class="number">1</span>);</span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// if the number of burst is equal to 2 , the next clock there will only be 1</span></span><br><span class="line">   <span class="comment">// AW request left. If this siganl , aw_last_outstanding is high , means there</span></span><br><span class="line">   <span class="comment">// is only one AW request should to be accepted !</span></span><br><span class="line">	aw_last_outstanding &lt;= (aw_bursts_outstanding == <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="number">2&#x27;b10</span>:	<span class="keyword">begin</span></span><br><span class="line">   <span class="comment">// a phantom siganl imply the core still has request to be accpeted</span></span><br><span class="line">	aw_none_outstanding &lt;= <span class="number">0</span>;</span><br><span class="line">   <span class="comment">// the burst number add one.</span></span><br><span class="line">	aw_bursts_outstanding &lt;= aw_bursts_outstanding + <span class="number">1</span>;</span><br><span class="line">   <span class="comment">// add a request , which will be the last one handled</span></span><br><span class="line">	aw_last_outstanding   &lt;= (aw_bursts_outstanding == <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">default</span>: <span class="keyword">begin</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>



<h2 id="w-complete-（x）"><a href="#w-complete-（x）" class="headerlink" title="w__complete （x）"></a>w__complete （x）</h2><blockquote>
<p><strong>Description</strong> :We can’t just look for the last <code>BVALID</code>, since … it might be possible to receive an abort before the FIFO is full enough to  initiate the first burst. (不能仅仅依赖于最后一个<code>BVALID</code>信号来判断一个操作是否完成，因为在FIFO队列还没有满到足以启动第一个数据传输（burst）之前，就可能收到一个中止（abort）信号。这意味着，即使我们看到了<code>BVALID</code>信号，也不能确定所有的数据都已经成功传输。)</p>
<p><strong><font color="red">不是很理解这种方法和意义</font></strong></p>
</blockquote>
<h2 id="axi-abort-pending"><a href="#axi-abort-pending" class="headerlink" title="axi_abort_pending"></a>axi_abort_pending</h2><p>这个部分是时序控制逻辑，而不是组合逻辑(combinatorcal logic)。</p>
<p><code>axi_abort_pending</code>，用于表示是否有要中止的操作。一开始，它被初始化为0，即没有中止操作。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>			axi_abort_pending;</span><br><span class="line"><span class="keyword">initial</span>	axi_abort_pending = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><code>if (i_reset || !r_busy)</code>：如果出现复位信号 <code>i_reset</code> 或者当前状态 <code>r_busy</code> 不再繁忙，那么将 <code>axi_abort_pending</code> 设置为0，表示没有中止操作。这部分逻辑可能是在检测到复位或者繁忙状态结束时，重置中止操作的标志。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (i_reset || !r_busy)</span><br><span class="line">   <span class="comment">// </span></span><br><span class="line">   <span class="comment">// the idle state there is no axi_abort_pending asserted.</span></span><br><span class="line">	axi_abort_pending &lt;= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>if the core is <code>r_busy</code> , not in the idle command control state.  The core should assert <code>axi_abort_pending</code> signal in three situations:</p>
<ul>
<li><p>a handshake happen is B channel , but the response  <code>M_AXI_BRESP[1]</code> is high. </p>
<p>( <code>M_AXI_BRESP</code> 的第二位为1（通常表示响应为”SLVERR”，即Slave Error），则将 <code>axi_abort_pending</code> 设置为1。这可能是在检测到写事务出现错误时触发中止操作。)</p>
</li>
<li><p>a command abort from user side , that is <code>cmd_abort  == 1</code>;</p>
<p>(外部请求中止操作时触发的)</p>
</li>
<li><p><code>err</code> in the core.</p>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span> (M_AXI_BVALID &amp;&amp; M_AXI_BREADY &amp;&amp; M_AXI_BRESP[<span class="number">1</span>])</span><br><span class="line">		axi_abort_pending &lt;= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (cmd_abort)</span><br><span class="line">		axi_abort_pending &lt;= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (r_err)</span><br><span class="line">		axi_abort_pending &lt;= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="initial-burstlen"><a href="#initial-burstlen" class="headerlink" title="initial_burstlen"></a>initial_burstlen</h2><blockquote>
<p>The <strong>first step</strong> is to calculate (combinatorially) <u><em>the distance to the next burst boundary</em></u>.</p>
</blockquote>
<p>This is roughly equivalent to <code>(1&lt;&lt;(LGMAXBURST+ADDRLSB)-cmd_addr)</code>. I have to separate it out for <strong>special treatment</strong> here for two reasons. </p>
<ul>
<li>First, I want to make certain that the operation is limited to <code>LGMAXBURST</code> bits–not <code>LGMAXBURST+1</code> bits, so we <font color="red"><strong>drop a bit</strong></font> here.  （因为操作 <code>1&lt;&lt;(LGMAXBURST+ADDRLSB)</code>会有 <em>LGMAXBURST+1</em> 数量的位宽，需要 <em>minus 1</em> 得到 <em>111__…..__111</em> 的大小 ）</li>
<li>The second reason is that I want to<font color="red"> <u><em>drop the lower sub-word address bits</em></u> </font>from this calculation.</li>
</ul>
<blockquote>
<p>Calculate the maximum possible burst length, ignoring 4kB boundaries</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line">		addralign = <span class="number">1</span>+(~cmd_addr[ADDRLSB +: LGMAXBURST]);</span><br></pre></td></tr></table></figure>

<p>the initial burst length is the full size.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	initial_burstlen = (<span class="number">1</span>&lt;&lt;LGMAXBURST);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>If we are going to be using FIXED addressing, then we need to limit ourselves to a maximum of 16 beats, not 256. Moreover, if we aren’t doing multiple bursts, we’ll limit the burst length to one burst only.</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fixed burst transfer</span></span><br><span class="line"><span class="keyword">if</span> (!r_increment)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// the fixed burst length is limited in 16 beats</span></span><br><span class="line">	initial_burstlen = MAX_FIXED_BURST;</span><br><span class="line">	<span class="keyword">if</span> (!aw_multiple_fixed_bursts)</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// no multiple fixed burst happen</span></span><br><span class="line">      <span class="comment">// the length will limited to one burst length only</span></span><br><span class="line">		initial_burstlen = &#123; <span class="number">1&#x27;b0</span>, cmd_length_w[LGMAXBURST-<span class="number">1</span>:<span class="number">0</span>] &#125;;</span><br></pre></td></tr></table></figure>

<p>第一个传输将地址对齐：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">end else if (aw_needs_alignment)</span><br><span class="line">	initial_burstlen = &#123; 1&#x27;b0, addralign &#125;;</span><br></pre></td></tr></table></figure>

<p><font color="red">So, from four flags and two lengths, we’ve been able to determine our initial burst length. </font></p>
<h2 id="r-max-burst"><a href="#r-max-burst" class="headerlink" title="r_max_burst"></a>r_max_burst</h2><blockquote>
<p><strong>Purpose</strong> : From here, we get to define the <u>maximum burst length</u> we can process. This is <u>initially set</u> by the clock <u>following the start command</u> to the initial value we just calculated above.</p>
</blockquote>
<p>参数 <code>LGMAXBURST</code>可以参考链接 ：[LGMAXBURST描述](#1.3 localparam ) ， 不超过 4KB 的最大 <em>burst length</em>.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>    [LGMAXBURST:<span class="number">0</span>]      r_max_burst;</span><br></pre></td></tr></table></figure>











<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="Count-W-valid-left"><a href="#Count-W-valid-left" class="headerlink" title="Count W_valid left"></a>Count W_valid left</h2><blockquote>
<p><strong>Purpose</strong> : Count the number of <code>WVALIDs</code>  <font color="red"><em><strong>yet</strong></em></font> to be sent on the write channel</p>
</blockquote>
<p>认识两个 <em>registered signal</em> 使用目的。</p>
<ul>
<li><p><code>initial wr_none_pending = 1;</code>：<font color="red"><em><strong>a flag singal</strong></em></font> , 表示<u><em><strong>是否存在待发送的 WVALID 信号</strong></em></u>。一开始，它被初始化为**<font color="red">1</font>**，<u><em><strong>即没有待发送的 WVALID 信号</strong></em></u>。</p>
</li>
<li><p><code>initial wr_writes_pending = 0;</code>：用于记录待发送的写事务的数量。一开始，它被初始化为0。</p>
<p>需要注意的是 <em>wr_write_pending</em> 这个信号的位宽是 <code>LGMAXBURST</code> (这个参数的单位是 <em><code>C_AXI_DATA_WIDTH</code></em> ) ， 所以这个信号表示： <font color="red">还有多少个 <em>beat need to be transfered</em> </font></p>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>	[LGMAXBURST:<span class="number">0</span>]	wr_writes_pending;</span><br><span class="line"><span class="keyword">reg</span>									wr_none_pending;</span><br><span class="line"><span class="keyword">initial</span>	wr_none_pending = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">initial</span>	wr_writes_pending = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<hr>
<p>在复位时将 <code>wr_writes_pending</code> 设置为<code>0</code>，表示没有待发送的写事务；</p>
<p>同时将 <code>wr_none_pending</code> 设置为1，表示没有待发送的 <code>WVALID</code> 信号。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (i_reset)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	wr_writes_pending &lt;= <span class="number">0</span>; <span class="comment">// no number of write_data left</span></span><br><span class="line">   wr_none_pending   &lt;= <span class="number">1</span>; <span class="comment">// no write_data pending(e.g. no w_data </span></span><br><span class="line">   												<span class="comment">//	waited to be writen)</span></span><br></pre></td></tr></table></figure>

<p>信号 <em>phantom_start</em> 表示后面还有一个 <em>AW request waited to be accepted</em> . <code>M_AXI_WVALID &amp; M_AXI_WREADY</code> 表示 <em>A handshake happen in W channel</em>.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">case</span> (&#123; phantom_start,</span><br><span class="line">		M_AXI_WVALID &amp;&amp; M_AXI_WREADY &#125;)</span><br></pre></td></tr></table></figure>

<p>对于不同的采样值 ，对于信号有不同的操作。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2&#x27;b00</span>: <span class="keyword">begin</span> <span class="keyword">end</span></span><br><span class="line"><span class="number">2&#x27;b01</span>: <span class="keyword">begin</span></span><br><span class="line">  	<span class="comment">//</span></span><br><span class="line">   <span class="comment">//	handshake in the B channel</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">//	the number of write_data minus one</span></span><br><span class="line">	wr_writes_pending &lt;= wr_writes_pending - <span class="number">1</span>;</span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// if the last clock there is just one wirte_data left,</span></span><br><span class="line">   <span class="comment">// this handshake will lead to assert the flag telling the core :</span></span><br><span class="line">   <span class="comment">// next clock cycle no more data is waiting to be transfered !</span></span><br><span class="line">	wr_none_pending   &lt;= (wr_writes_pending == <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="number">2&#x27;b10</span>: <span class="keyword">begin</span></span><br><span class="line">   <span class="comment">// &#123;&#123;</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// No handshake on the W channel , but the &quot;phantom&quot; imply there is</span></span><br><span class="line">   <span class="comment">// another AW request need to be accpeted.</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// The write_pending should add the &quot;length of AXI_control_information&quot;</span></span><br><span class="line">	wr_writes_pending &lt;= wr_writes_pending + (M_AXI_AWLEN[LGMAXBURST-<span class="number">1</span>:<span class="number">0</span>] + <span class="number">1</span>);</span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// telling the core , has datas are waiting.</span></span><br><span class="line">	wr_none_pending   &lt;= <span class="number">0</span>;</span><br><span class="line">   <span class="comment">// &#125;&#125;</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="number">2&#x27;b11</span>: <span class="keyword">begin</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// new AW request , and handshake on the W channel.</span></span><br><span class="line">   <span class="comment">// &#123;&#123;</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// The added pending should minus one , and add AXI_LEN</span></span><br><span class="line">	wr_writes_pending &lt;= wr_writes_pending + (M_AXI_AWLEN[LGMAXBURST-<span class="number">1</span>:<span class="number">0</span>]);</span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// Once we accept the WLAST(e.g. the last data per burst) </span></span><br><span class="line">   <span class="comment">// signal of one transaction , we will asser the wr_none_pending </span></span><br><span class="line">	wr_none_pending   &lt;= (M_AXI_WLAST);</span><br><span class="line">   <span class="comment">// &#125;&#125;</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>



<h2 id="Count-monitor-Address"><a href="#Count-monitor-Address" class="headerlink" title="Count monitor Address"></a>Count monitor Address</h2><blockquote>
<p>So that we can monitor <u><em><strong>where we are at</strong></em></u>, and perhaps restart it later, keep track of <u><em><strong>the current address used</strong></em></u> by the <u><strong>W-channel</strong></u>   </p>
</blockquote>
<p>The address the core monitor is <u><em>the axi full address</em></u>.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the axi_full_address we monitor</span></span><br><span class="line"><span class="keyword">reg</span>	[C_AXI_ADDR_WIDTH-<span class="number">1</span>:<span class="number">0</span>]	axi_addr;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	the command control address user write to the core</span></span><br><span class="line"><span class="comment">//	or the address read from.</span></span><br><span class="line"><span class="keyword">reg</span>	[C_AXI_ADDR_WIDTH-<span class="number">1</span>:<span class="number">0</span>]	cmd_addr;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">initial</span>	axi_addr = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>if the core is idle (e.g. !r_busy &#x3D;&#x3D; 1 ) , the <code>axi_addr</code> will  read  control_register <code>cmd_addr</code>.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span> (!r_busy)</span><br><span class="line">		axi_addr &lt;= cmd_addr;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>If <code>!r_increment</code> is <strong>set</strong>, the core writes to the same address throughout the transaction.  This is useful if you want to <u><em><strong>copy data to a FIFO</strong></em></u> or <strong><u><em>other device living at a single address</em></u></strong> in the memory map.</p>
</blockquote>
<p>如果发生了 <em>axi_abort_pending</em> 或者一直向同一个地址写数据，那么 <em>axi_addr</em> 地址不发生变化</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (axi_abort_pending || !r_increment)</span><br><span class="line">	<span class="comment">// Stop incrementing the address following an abort</span></span><br><span class="line">	axi_addr &lt;= axi_addr;</span><br></pre></td></tr></table></figure>

<p>如果发生了一次 <em>handshake</em> ， <em>address</em> 增加 <em>one_beat</em> 长度(e.g. <code>C_AXI_DATA_WIDTH</code> )</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (M_AXI_WVALID &amp;&amp; M_AXI_WREADY)</span><br><span class="line">	axi_addr &lt;= axi_addr + (<span class="number">1</span>&lt;&lt;ADDRLSB);</span><br></pre></td></tr></table></figure>

<p>如果设置了 <em>align</em> 那么地位低位必须保持为 <code>0</code></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span> (!OPT_UNALIGNED)</span><br><span class="line">		axi_addr[ADDRLSB-<span class="number">1</span>:<span class="number">0</span>] &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="Count-remaining-words"><a href="#Count-remaining-words" class="headerlink" title="Count remaining words"></a>Count remaining words</h2><blockquote>
<p>Count the number of words <u><em>remaining to be written</em></u> on the <u><em>W channel</em></u></p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Maximum number of bytes that can ever be transferred, in</span></span><br><span class="line"><span class="comment">// log-base 2.  Hence LGLEN=20 will transfer 1MB of data.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// parameter	LGLEN  = C_AXI_ADDR_WIDTH-1,</span></span><br><span class="line"><span class="comment">// localparam	LGLENW  = LGLEN  - ADDRLSB;</span></span><br><span class="line"><span class="keyword">reg</span>	[LGLENW-<span class="number">1</span>:<span class="number">0</span>]		r_remaining_w;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// the initial word to be writen will be set zero</span></span><br><span class="line"><span class="keyword">initial</span>	r_remaining_w = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>the <code>i_reset</code> signal will also set the register.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line">	<span class="keyword">if</span> (i_reset)</span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		r_remaining_w &lt;= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>if this core is <code>idle</code> , the register <code>r_maining_w</code> should set the <u><em>data of axi-lite command data length</em></u> <code>cmd_length_w</code>. Maybe we need <u><em>two clock cycle</em></u> to set the <code>cmd_length_w</code> right , but the core will always set the data of this register right before starting to work.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (!r_busy)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	r_remaining_w&lt;= cmd_length_w;</span><br></pre></td></tr></table></figure>

<p>Every time a handshake happens on the <u>W channel</u> , the number of <u><em>the remaining data waited to be transfered</em></u> will minus one.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (M_AXI_WVALID &amp;&amp; M_AXI_WREADY)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	r_remaining_w &lt;= r_remaining_w - <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// r_none_remaining &lt;= (r_remaining_w == 1);</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h2 id="phantom-implement"><a href="#phantom-implement" class="headerlink" title="phantom implement"></a>phantom implement</h2><blockquote>
<p><strong>Purpose</strong> : understand wire signal <code>w_phantom_start</code> and register signal <code>phantom_start</code></p>
<p><strong>Description</strong> :</p>
<p>Since we can’t use the <code>xREADY</code> signals in our signaling（e.g. <code>xREADY</code> 信号除了 Bready，其他的不能被控制）, we have to be ready to generate both <code>AWVALID</code> and <code>WVALID</code> <u><em>on the same cycle</em></u>, and then hold <code>AWVALID</code> until it has been accepted.  </p>
<p>This means we can’t use <code>AWVALID</code> as our burst start signal like <u>we could in the slave</u>.  Instead, we’ll use a “phantom” start signal.  This signal is local here in our code.  **<font color="red"><u><em>When this signal goes high, <code>AWVALID</code> and <code>WVALID</code> go high at the same time.</em></u> </font>** </p>
<p>Then, if <code>AWREADY</code> isn’t held, we can still update all of our internal counters as though it were, based upon the <code>phantom_start</code> signal, and continue as though(好像) <code>AWVALID</code> were accepted on its first clock period.</p>
</blockquote>
<p>两个关键信号声明：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>				w_phantom_start; <span class="comment">// the wire signal</span></span><br><span class="line"><span class="keyword">reg</span>	 			phantom_start;</span><br></pre></td></tr></table></figure>

<p>The combitorical logic :</p>
<ul>
<li><strong><font color="red">Assert wire_phantom_start when <u>aw request</u> is remaining !</font></strong></li>
</ul>
<blockquote>
<p>We start again if there’s more information to transfer</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">	<span class="comment">// We start again if there&#x27;s more information to transfer</span></span><br><span class="line">   <span class="comment">// aw_none_remaining， If this signal is set ,means there </span></span><br><span class="line">   <span class="comment">// is no remained AW request should be handled. </span></span><br><span class="line">	w_phantom_start = !aw_none_remaining;</span><br></pre></td></tr></table></figure>

<p>这意味着如果是 <u>multiple burst transfer</u> ，那么只要不是最后一个 <em>burst</em> 那么这个信号会一个 <em>assert</em> ，肯定有问题，需要其他逻辑部分进行控制。</p>
<ul>
<li><strong><font color="red">Do not wire_phantom_start  if the fifo doesn’t full</font></strong></li>
</ul>
<blockquote>
<p>But not if the amount of information we need <strong>isn’t (yet)</strong>  in the FIFO.  </p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// But not if the amount of information we need isn&#x27;t (yet)</span></span><br><span class="line"><span class="comment">// in the FIFO.</span></span><br><span class="line"><span class="keyword">if</span> (!sufficiently_filled)</span><br><span class="line">		wire_phantom_start = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><font color="red">Do not wire_phantom_start  if there is already has a start signal</font></strong></li>
</ul>
<blockquote>
<p>Insist on <u><em><strong>a minimum of one clock between burst starts</strong></em></u>,  since our <u><em>burst length calculation takes a clock to do</em></u></p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (phantom_start || r_pre_start)</span><br><span class="line">	w_phantom_start = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>回顾这个 <code>register_pre_start</code> 信号大概(我猜测)是一个<em>预准备</em> 的信号。在 <code>idle</code>状态下 set ， <code>busy</code>状态下 low.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	r_pre_start = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (!r_busy)</span><br><span class="line">	r_pre_start &lt;= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	r_pre_start &lt;= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><font color="red">Do not wire_phantom_start  if AW channel valid_before_ready</font></strong></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (M_AXI_AWVALID &amp;&amp; !M_AXI_AWREADY)</span><br><span class="line">	w_phantom_start = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><font color="red">Do not wire_phantom_start  if only the last transaction should be transfered</font></strong></li>
</ul>
<blockquote>
<p>If we’re still <u><em>writing the last burst</em></u>, then <u><em>don’t start</em></u> any new ones.</p>
</blockquote>
<p>仍在写入上一个突发传输（最后一次突发）时，防止启动新的突发传输。具体来说，如果当前写入信号（<code>M_AXI_WVALID</code>）为真且（最后一次写入标志 <code>M_AXI_WLAST</code> 为假或者写入准备就绪标志 <code>M_AXI_WREADY</code> 为假），则将虚拟起始标志 <code>w_phantom_start</code> 设为0，以阻止启动新的突发传输。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (M_AXI_WVALID &amp;&amp; (!M_AXI_WLAST || !M_AXI_WREADY))</span><br><span class="line">	w_phantom_start = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><font color="red">r_busy &amp; abort situation</font></strong></li>
</ul>
<blockquote>
<p>Finally, don’t start any new bursts if we aren’t already busy transmitting, or if we are in the process of aborting our transfer.</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span> (!r_busy || cmd_abort || axi_abort_pending)</span><br><span class="line">		w_phantom_start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p>每一个时钟上升边沿对 <em>wire</em> 逻辑信号进行 <em>sample</em> 采样</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	phantom_start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (i_reset)</span><br><span class="line">	phantom_start &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	phantom_start &lt;= w_phantom_start;</span><br></pre></td></tr></table></figure>



<h2 id="WLAST"><a href="#WLAST" class="headerlink" title="WLAST"></a>WLAST</h2><p>the first situation , if the transaction has only one beat to be transfered (e.g. detect the user control information <em>cmd_length_w</em> is equal to <code>1</code> ) , the <code>axi_wlast</code> should be asserted at onece.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (!r_busy)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	axi_wlast &lt;= (cmd_length_w == <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>When the core is <code>busy / working</code> , and the W channel has <u><em><strong>no valid before ready</strong></em></u> block situation , the logic is as below :</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (!M_AXI_WVALID || M_AXI_WREADY)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span> (w_phantom_start)</span><br><span class="line">		axi_wlast &lt;= (r_max_burst == <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (phantom_start)</span><br><span class="line">		axi_wlast &lt;= (M_AXI_AWLEN == <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		axi_wlast &lt;= (wr_writes_pending == <span class="number">1</span> + (M_AXI_WVALID ? <span class="number">1</span>:<span class="number">0</span>));</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><strong><font color="red">目前对这些不怎么了解</font></strong></p>
<h2 id="Calculate-for-next-AWVALID（x）"><a href="#Calculate-for-next-AWVALID（x）" class="headerlink" title="Calculate for next AWVALID（x）"></a>Calculate for next AWVALID（x）</h2><blockquote>
<p><strong>Purpose</strong> : Calculate <code>AWLEN</code> and <code>AWADDR</code> for the next <code>AWVALID</code> </p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// FIFO signals</span></span><br><span class="line"><span class="keyword">wire</span>		reset_fifo, </span><br><span class="line">				write_to_fifo,</span><br><span class="line">				read_from_fifo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>			[LGFIFO:<span class="number">0</span>]		data_available;</span><br><span class="line"><span class="keyword">wire</span>		[LGFIFO:<span class="number">0</span>]		fifo_fill;</span><br><span class="line"><span class="keyword">initial</span>								data_available = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="1-data-available"><a href="#1-data-available" class="headerlink" title="1. data_available"></a>1. data_available</h3><p>参数 <code>LGFIFO</code>是 <em>32bits_register</em> 的地址 <code>[20:16]</code>， </p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (reset_fifo)</span><br><span class="line">   <span class="comment">// fifo reset will clear the number of data in FIFO</span></span><br><span class="line">	data_available &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (axi_abort_pending)</span><br><span class="line">	data_available &lt;= fifo_fill + (write_to_fifo ? <span class="number">1</span>:<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><font color="red">不清楚这里 axi_abort_pending 为什么可以出现？？</font></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">case</span>(&#123; write_to_fifo, phantom_start &#125;)</span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"> <span class="comment">// No double_start cmd , if write_to_fifo , the data</span></span><br><span class="line"> <span class="comment">// available plus one.</span></span><br><span class="line"><span class="number">2&#x27;b10</span>: data_available &lt;= data_available + <span class="number">1</span>;</span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"> <span class="comment">// onece start transaction , the data_available minus</span></span><br><span class="line"> <span class="comment">// (M_AXI_AWLEN + 1)</span></span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"><span class="comment">// Verilator lint_off WIDTH</span></span><br><span class="line"><span class="number">2&#x27;b01</span>: data_available &lt;= data_available - (M_AXI_AWLEN+<span class="number">1</span>);</span><br><span class="line"> <span class="comment">// if write_2_fifo and start new transaction</span></span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"><span class="number">2&#x27;b11</span>: data_available &lt;= data_available - (M_AXI_AWLEN);</span><br><span class="line"><span class="comment">// Verilator lint_on  WIDTH</span></span><br><span class="line"><span class="keyword">default</span>: <span class="keyword">begin</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>



<h3 id="2-sufficiently-filled"><a href="#2-sufficiently-filled" class="headerlink" title="2. sufficiently_filled"></a>2. sufficiently_filled</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// actually , it&#x27;s a wire type signal</span></span><br><span class="line"><span class="keyword">reg</span>			sufficiently_filled; </span><br></pre></td></tr></table></figure>

<p>The combinatorical logic , the <code>aw_requests_remaining</code> 可以参考信息链接[aw_requests_remaining信息](#2.  aw__*__remaining)</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line">   <span class="comment">// the aw_requests_remaining is equal to the initial cmd_length(idle state), or</span></span><br><span class="line">   <span class="comment">// the reaming whole number of data should transfer</span></span><br><span class="line"><span class="keyword">if</span> (|aw_requests_remaining[LGLENW-<span class="number">1</span>:LGMAXBURST])</span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// the high bits of r_data_available is not all zero ,</span></span><br><span class="line">   <span class="comment">// means the number of data requirement that should be transfered </span></span><br><span class="line">   <span class="comment">// in one transaction is met.</span></span><br><span class="line">	sufficiently_filled = |data_available[LGFIFO:LGMAXBURST];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   sufficiently_filled = </span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// the data_available remaining in one transaction</span></span><br><span class="line">   (data_available[LGMAXBURST-<span class="number">1</span>:<span class="number">0</span>] &gt;= </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    aw_requests_remaining[LGMAXBURST-<span class="number">1</span>:<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<h2 id="axi-signal"><a href="#axi-signal" class="headerlink" title="axi_signal"></a>axi_signal</h2><h3 id="1-axi-awlen"><a href="#1-axi-awlen" class="headerlink" title="1. axi_awlen"></a>1. axi_awlen</h3><p>如果参数 <em>LGMAXBURST</em> 参数大于等于 <em>8</em> ，那么 <em>axi_awlen</em> 支持的突发长度比较大。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">generate</span> <span class="keyword">if</span> (LGMAXBURST &gt;= <span class="number">8</span>)</span><br><span class="line"><span class="keyword">begin</span> : GEN_BIG_AWLEN</span><br></pre></td></tr></table></figure>



<h3 id="2-awvalid"><a href="#2-awvalid" class="headerlink" title="2. awvalid"></a>2. awvalid</h3><p>If the <u><em>situation valid before ready</em></u> do not happen in AW channel , register <code>axi_awvalid</code> sample <code>w_phantom_start</code> wire siganl.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AWVALID</span></span><br><span class="line"><span class="keyword">initial</span>	axi_awvalid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (i_reset)</span><br><span class="line">	axi_awvalid &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!M_AXI_AWVALID || M_AXI_AWREADY)</span><br><span class="line">   <span class="comment">// sample the wire type signal, not the R_**</span></span><br><span class="line">	axi_awvalid &lt;= w_phantom_start;</span><br></pre></td></tr></table></figure>



<h3 id="3-wvalid"><a href="#3-wvalid" class="headerlink" title="3. wvalid"></a>3. wvalid</h3><h3 id="4-axi-wstrb"><a href="#4-axi-wstrb" class="headerlink" title="4. axi_wstrb"></a>4. axi_wstrb</h3><p>the data width of axi_wstrb , the number of bytes.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [C_AXI_DATA_WIDTH/<span class="number">8</span>-<span class="number">1</span>:<span class="number">0</span>]	axi_wstrb;</span><br></pre></td></tr></table></figure>

<p>if abort , every bytes in axi_data won’t be valid ro write , otherwise all bytes will be writen into core.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (!M_AXI_WVALID || M_AXI_WREADY)</span><br><span class="line">	axi_wstrb &lt;= (axi_abort_pending) ? <span class="number">0</span>:-<span class="number">1</span>;</span><br></pre></td></tr></table></figure>



<h3 id="5-fixed-bus-values"><a href="#5-fixed-bus-values" class="headerlink" title="5. fixed bus values"></a>5. fixed bus values</h3><p>as below,</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span>	M_AXI_AWVALID= axi_awvalid;</span><br><span class="line"><span class="keyword">assign</span>	M_AXI_AWID   = AXI_ID;</span><br><span class="line"><span class="keyword">assign</span>	M_AXI_AWADDR = axi_awaddr;</span><br><span class="line"><span class="keyword">assign</span>	M_AXI_AWLEN  = axi_awlen;</span><br><span class="line"><span class="comment">// Verilator lint_off WIDTH</span></span><br><span class="line"><span class="keyword">assign</span>	M_AXI_AWSIZE = <span class="built_in">$clog2</span>(C_AXI_DATA_WIDTH)-<span class="number">3</span>;</span><br><span class="line"><span class="comment">// Verilator lint_on  WIDTH</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// the type of burst , only pay attention to the lower bit</span></span><br><span class="line"><span class="keyword">assign</span>	M_AXI_AWBURST= &#123; <span class="number">1&#x27;b0</span>, r_increment &#125;;</span><br><span class="line"><span class="keyword">assign</span>	M_AXI_AWLOCK = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">assign</span>	M_AXI_AWCACHE= <span class="number">4&#x27;h3</span>;</span><br><span class="line"><span class="keyword">assign</span>	M_AXI_AWPROT = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">assign</span>	M_AXI_AWQOS  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span>	M_AXI_WVALID = axi_wvalid;</span><br><span class="line"><span class="keyword">assign</span>	M_AXI_WSTRB  = axi_wstrb;</span><br><span class="line"><span class="keyword">assign</span>	M_AXI_WLAST  = axi_wlast;</span><br><span class="line"><span class="comment">// M_AXI_WLAST = ??</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span>	M_AXI_BREADY = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>











<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span>	aw_none_remaining = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">initial</span>	aw_requests_remaining = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (!r_busy)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	aw_requests_remaining &lt;= cmd_length_w;</span><br><span class="line">	aw_none_remaining     &lt;= zero_length;</span><br><span class="line">	aw_multiple_bursts_remaining &lt;= |cmd_length_w[LGLENW-<span class="number">1</span>:LGMAXBURST+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (cmd_abort || axi_abort_pending)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	aw_requests_remaining &lt;= <span class="number">0</span>;</span><br><span class="line">	aw_none_remaining &lt;= <span class="number">1</span>;</span><br><span class="line">	aw_multiple_bursts_remaining &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (phantom_start)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	aw_requests_remaining &lt;= aw_next_remaining;</span><br><span class="line">	aw_none_remaining&lt;= !aw_multiple_bursts_remaining</span><br><span class="line">		&amp;&amp;(aw_next_remaining[LGMAXBURST:<span class="number">0</span>] == <span class="number">0</span>);</span><br><span class="line">	aw_multiple_bursts_remaining</span><br><span class="line">			&lt;= |aw_next_remaining[LGLENW-<span class="number">1</span>:LGMAXBURST+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// &#125;&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Calculate the maximum possible burst length, ignoring 4kB boundaries</span></span><br><span class="line"><span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line">	addralign = <span class="number">1</span>+(~cmd_addr[ADDRLSB +: LGMAXBURST]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	initial_burstlen = (<span class="number">1</span>&lt;&lt;LGMAXBURST);</span><br><span class="line">	<span class="keyword">if</span> (!r_increment)</span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		initial_burstlen = MAX_FIXED_BURST;</span><br><span class="line">		<span class="keyword">if</span> (!aw_multiple_fixed_bursts)</span><br><span class="line">			initial_burstlen = &#123; <span class="number">1&#x27;b0</span>, cmd_length_w[LGMAXBURST-<span class="number">1</span>:<span class="number">0</span>] &#125;;</span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (aw_needs_alignment)</span><br><span class="line">		initial_burstlen = &#123; <span class="number">1&#x27;b0</span>, addralign &#125;;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!aw_multiple_full_bursts)</span><br><span class="line">		initial_burstlen = &#123; <span class="number">1&#x27;b0</span>, cmd_length_w[LGMAXBURST-<span class="number">1</span>:<span class="number">0</span>] &#125;;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span>	r_max_burst = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (!r_busy || r_pre_start)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="comment">// Force us to align ourself early</span></span><br><span class="line">	<span class="comment">//   That way we don&#x27;t need to check for</span></span><br><span class="line">	<span class="comment">//   alignment (again) later</span></span><br><span class="line">	r_max_burst &lt;= initial_burstlen;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (phantom_start)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="comment">// Verilator lint_off WIDTH</span></span><br><span class="line">	<span class="keyword">if</span> (r_increment || LGMAXBURST &lt;= LGMAX_FIXED_BURST)</span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span> (!aw_multiple_bursts_remaining</span><br><span class="line">			&amp;&amp; aw_next_remaining[LGMAXBURST:<span class="number">0</span>] &lt; (<span class="number">1</span>&lt;&lt;LGMAXBURST))</span><br><span class="line">			r_max_burst &lt;= &#123; <span class="number">1&#x27;b0</span>, aw_next_remaining[<span class="number">7</span>:<span class="number">0</span>] &#125;;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			r_max_burst &lt;= (<span class="number">1</span>&lt;&lt;LGMAXBURST);</span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span> (!aw_multiple_bursts_remaining</span><br><span class="line">			&amp;&amp; aw_next_remaining[LGMAXBURST:<span class="number">0</span>] &lt; MAX_FIXED_BURST)</span><br><span class="line">			r_max_burst &lt;= &#123; <span class="number">1&#x27;b0</span>, aw_next_remaining[<span class="number">7</span>:<span class="number">0</span>] &#125;;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			r_max_burst &lt;= MAX_FIXED_BURST;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="comment">// Verilator lint_on WIDTH</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// &#125;&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Count the number of bursts outstanding--these are the number of</span></span><br><span class="line"><span class="comment">// AWVALIDs that have been accepted, but for which the BVALID has not</span></span><br><span class="line"><span class="comment">// (yet) been returned.</span></span><br><span class="line"><span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line"><span class="keyword">initial</span>	aw_last_outstanding   = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">initial</span>	aw_none_outstanding   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">initial</span>	aw_bursts_outstanding = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (i_reset)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	aw_bursts_outstanding &lt;= <span class="number">0</span>;</span><br><span class="line">	aw_none_outstanding &lt;= <span class="number">1</span>;</span><br><span class="line">	aw_last_outstanding &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">case</span> (&#123; phantom_start, M_AXI_BVALID &amp;&amp; M_AXI_BREADY &#125;)</span><br><span class="line"><span class="number">2&#x27;b01</span>:	<span class="keyword">begin</span></span><br><span class="line">	aw_bursts_outstanding &lt;= aw_bursts_outstanding - <span class="number">1</span>;</span><br><span class="line">	aw_none_outstanding &lt;= (aw_bursts_outstanding == <span class="number">1</span>);</span><br><span class="line">	aw_last_outstanding &lt;= (aw_bursts_outstanding == <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="number">2&#x27;b10</span>:	<span class="keyword">begin</span></span><br><span class="line">	aw_none_outstanding &lt;= <span class="number">0</span>;</span><br><span class="line">	aw_bursts_outstanding &lt;= aw_bursts_outstanding + <span class="number">1</span>;</span><br><span class="line">	aw_last_outstanding   &lt;= (aw_bursts_outstanding == <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">default</span>: <span class="keyword">begin</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="comment">// &#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure>

























</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">冰蒂斯</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/12/27/S2MM/">http://example.com/2023/12/27/S2MM/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">冰蒂斯のformula</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/AXI/">AXI</a><a class="post-meta__tags" href="/tags/master/">master</a></div><div class="post_share"><div class="social-share" data-image="/img/chainsaw_red.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/06/how2blog/" title="how2blog"><img class="cover" src="/img/reze.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">how2blog</div></div></a></div><div class="next-post pull-right"><a href="/2023/12/24/auto2-using/" title="auto2-using"><img class="cover" src="/img/chainsaw_makima04.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">auto2-using</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/11/15/5-1-1-basic-master/" title="5-1 basic_master(中)"><img class="cover" src="/img/chainsaw_makima04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-15</div><div class="title">5-1 basic_master(中)</div></div></a></div><div><a href="/2023/11/13/5-1-basic-master/" title="5-1 basic_master(上)"><img class="cover" src="/img/chainsaw_makima04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-13</div><div class="title">5-1 basic_master(上)</div></div></a></div><div><a href="/2023/11/23/5-1-2-basic-master/" title="5-1 basic_master(下)"><img class="cover" src="/img/chainsaw_makima04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-23</div><div class="title">5-1 basic_master(下)</div></div></a></div><div><a href="/2023/12/06/MM2S/" title="MM2S"><img class="cover" src="/img/chainsaw_red.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-06</div><div class="title">MM2S</div></div></a></div><div><a href="/2023/11/18/Property-master/" title="Property_axil-master"><img class="cover" src="/img/chainsaw_makima04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-18</div><div class="title">Property_axil-master</div></div></a></div><div><a href="/2023/11/25/axi-master-full/" title="axi(full)master(上)"><img class="cover" src="/img/chainsaw_makima04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-25</div><div class="title">axi(full)master(上)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">冰蒂斯</div><div class="author-info__description">螺旋上升的人生,也是多线程的人生</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-first-you-should-read"><span class="toc-number">1.</span> <span class="toc-text">1. first you should read</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-register-address"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 register address</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-parameter"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 parameter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-localparam"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 localparam</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-axis-skidbuffer"><span class="toc-number">2.</span> <span class="toc-text">2. axis skidbuffer</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-axi-lite-signaling"><span class="toc-number">3.</span> <span class="toc-text">3. axi-lite signaling</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Write-signaling"><span class="toc-number">3.1.</span> <span class="toc-text">3.1  Write signaling</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-AW-W-channel-signal"><span class="toc-number">3.1.1.</span> <span class="toc-text">1. AW W channel signal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-ready-bvalid-logic"><span class="toc-number">3.1.2.</span> <span class="toc-text">2. ready &amp; bvalid logic</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Read-signaling"><span class="toc-number">3.2.</span> <span class="toc-text">3.2  Read signaling</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-AR-channel"><span class="toc-number">3.2.1.</span> <span class="toc-text">1. AR channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Read-valid-logic"><span class="toc-number">3.2.2.</span> <span class="toc-text">2. Read_valid logic</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-axil-control-logic"><span class="toc-number">4.</span> <span class="toc-text">3. axil control logic</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-last-signal-%E2%88%9A"><span class="toc-number">4.1.</span> <span class="toc-text">3.1 last_signal (√)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Overflow-%E2%88%9A"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 Overflow (√)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-abort-command-%E2%88%9A"><span class="toc-number">4.3.</span> <span class="toc-text">3.3 abort command (√)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-wire-start-command-%E2%88%9A"><span class="toc-number">4.4.</span> <span class="toc-text">3.4 wire_start command (√)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-r-busy-r-complete-O"><span class="toc-number">4.5.</span> <span class="toc-text">3.5 r_busy &amp; r_complete (O?)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-o-int-O"><span class="toc-number">4.6.</span> <span class="toc-text">3.6 o_int (O?)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-r-err-X"><span class="toc-number">4.7.</span> <span class="toc-text">3.7 r_err (X)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-r-continuous-x"><span class="toc-number">4.8.</span> <span class="toc-text">3.8 r_continuous (x)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-wide"><span class="toc-number">5.</span> <span class="toc-text">4. wide_*</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-function%E2%80%93apply-wstrb-%E2%88%9A"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 function–apply_wstrb (√)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-wide-signal-%E2%88%9A"><span class="toc-number">5.2.</span> <span class="toc-text">4.2 wide__*   signal (√)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-configuration-%E2%88%9A"><span class="toc-number">5.2.1.</span> <span class="toc-text">1.  configuration (√)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-wide-address-current-address-length-%E2%88%9A"><span class="toc-number">5.2.2.</span> <span class="toc-text">2.wide_address , current_address &amp; length (√)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-new-wideaddr-widelen-%E2%88%9A"><span class="toc-number">5.2.3.</span> <span class="toc-text">3. new_wideaddr&#x2F;widelen (√)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-My-picture-%E2%88%9A"><span class="toc-number">5.2.4.</span> <span class="toc-text">4. My picture (√)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-set-command-%E2%88%9A"><span class="toc-number">5.3.</span> <span class="toc-text">4.3 set command (√)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-control-address-%E2%88%9A"><span class="toc-number">5.3.1.</span> <span class="toc-text">1. control &amp; address (√)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-cmd-len-high-low-%E2%88%9A"><span class="toc-number">5.3.2.</span> <span class="toc-text">2 . cmd_len_high&#x2F;low (√)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-busy-xx"><span class="toc-number">5.3.3.</span> <span class="toc-text">3. busy (xx??)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-axil-read-data-%E2%88%9A"><span class="toc-number">5.4.</span> <span class="toc-text">4.4  axil_read_data (√)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-CMD-CONTROL-%E2%88%9A"><span class="toc-number">5.4.1.</span> <span class="toc-text">1. CMD_CONTROL : (√)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-CMD-ADDRLO-CMD-ADDRHI-%E2%88%9A"><span class="toc-number">5.4.2.</span> <span class="toc-text">2.   CMD_ADDRLO &amp; CMD_ADDRHI (√)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-CMD-LENLO-CMD-LENHI-%E2%88%9A"><span class="toc-number">5.4.3.</span> <span class="toc-text">3. CMD_LENLO &amp; CMD_LENHI (√)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">5.4.3.1.</span> <span class="toc-text"></span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-data-FIFO"><span class="toc-number">6.</span> <span class="toc-text">5. data FIFO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-reset-read-write-FIFO-%E2%88%9A"><span class="toc-number">6.1.</span> <span class="toc-text">5.1 reset &amp; read &amp; write FIFO (√)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-sskd-ready-%E2%88%9A"><span class="toc-number">6.2.</span> <span class="toc-text">5.2  sskd_ready (√)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-OPT-TLAST-SYNC"><span class="toc-number">6.3.</span> <span class="toc-text">5.3 OPT_TLAST_SYNC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-sfifo"><span class="toc-number">6.4.</span> <span class="toc-text">5.4 sfifo</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-outgoing-AXI%EF%BC%88full%EF%BC%89protocol"><span class="toc-number">7.</span> <span class="toc-text">6. outgoing AXI（full）protocol</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-Hiding-computations"><span class="toc-number">7.1.</span> <span class="toc-text">6.1 Hiding computations</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-two-clock-cycle-computation"><span class="toc-number">7.1.1.</span> <span class="toc-text">1. two clock cycle computation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-phantom"><span class="toc-number">7.1.2.</span> <span class="toc-text">2. phantom</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-Example-S2MM"><span class="toc-number">7.2.</span> <span class="toc-text">6.2 Example: S2MM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-new-address-4KB"><span class="toc-number">7.2.1.</span> <span class="toc-text">1. new_address &amp; 4KB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-aw-remaining"><span class="toc-number">7.2.2.</span> <span class="toc-text">2.  aw__*__remaining</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-FIFO-Space-available"><span class="toc-number">7.3.</span> <span class="toc-text">6.3 FIFO (Space available)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-fifo-write"><span class="toc-number">7.3.1.</span> <span class="toc-text">1. fifo write</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-fifo-read"><span class="toc-number">7.3.2.</span> <span class="toc-text">2. fifo read</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-whether-multiple-burst-data"><span class="toc-number">7.3.3.</span> <span class="toc-text">3.  whether multiple burst data</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-Counter-to-keep-track"><span class="toc-number">7.4.</span> <span class="toc-text">6.4 Counter to keep track</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Calculate-the-next-data-remaing"><span class="toc-number">7.4.1.</span> <span class="toc-text">1. Calculate the next data_remaing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-r-pre-start"><span class="toc-number">7.4.2.</span> <span class="toc-text">2. r_pre_start</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-aw-needs-alignment"><span class="toc-number">7.4.3.</span> <span class="toc-text">3. aw_needs_alignment</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#burst-outstanding"><span class="toc-number">7.5.</span> <span class="toc-text">burst outstanding</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#w-complete-%EF%BC%88x%EF%BC%89"><span class="toc-number">7.6.</span> <span class="toc-text">w__complete （x）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#axi-abort-pending"><span class="toc-number">7.7.</span> <span class="toc-text">axi_abort_pending</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#initial-burstlen"><span class="toc-number">7.8.</span> <span class="toc-text">initial_burstlen</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#r-max-burst"><span class="toc-number">7.9.</span> <span class="toc-text">r_max_burst</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-1"><span class="toc-number">7.10.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Count-W-valid-left"><span class="toc-number">7.11.</span> <span class="toc-text">Count W_valid left</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Count-monitor-Address"><span class="toc-number">7.12.</span> <span class="toc-text">Count monitor Address</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Count-remaining-words"><span class="toc-number">7.13.</span> <span class="toc-text">Count remaining words</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#phantom-implement"><span class="toc-number">7.14.</span> <span class="toc-text">phantom implement</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WLAST"><span class="toc-number">7.15.</span> <span class="toc-text">WLAST</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Calculate-for-next-AWVALID%EF%BC%88x%EF%BC%89"><span class="toc-number">7.16.</span> <span class="toc-text">Calculate for next AWVALID（x）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-data-available"><span class="toc-number">7.16.1.</span> <span class="toc-text">1. data_available</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-sufficiently-filled"><span class="toc-number">7.16.2.</span> <span class="toc-text">2. sufficiently_filled</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#axi-signal"><span class="toc-number">7.17.</span> <span class="toc-text">axi_signal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-axi-awlen"><span class="toc-number">7.17.1.</span> <span class="toc-text">1. axi_awlen</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-awvalid"><span class="toc-number">7.17.2.</span> <span class="toc-text">2. awvalid</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-wvalid"><span class="toc-number">7.17.3.</span> <span class="toc-text">3. wvalid</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-axi-wstrb"><span class="toc-number">7.17.4.</span> <span class="toc-text">4. axi_wstrb</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-fixed-bus-values"><span class="toc-number">7.17.5.</span> <span class="toc-text">5. fixed bus values</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/01/07/skid-buffer/" title="skid_buffer"><img src="/img/chainsaw_power01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="skid_buffer"/></a><div class="content"><a class="title" href="/2024/01/07/skid-buffer/" title="skid_buffer">skid_buffer</a><time datetime="2024-01-07T12:48:03.000Z" title="发表于 2024-01-07 20:48:03">2024-01-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/06/how2blog/" title="how2blog"><img src="/img/reze.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="how2blog"/></a><div class="content"><a class="title" href="/2024/01/06/how2blog/" title="how2blog">how2blog</a><time datetime="2024-01-06T14:34:23.000Z" title="发表于 2024-01-06 22:34:23">2024-01-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/27/S2MM/" title="S2MM"><img src="/img/chainsaw_red.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="S2MM"/></a><div class="content"><a class="title" href="/2023/12/27/S2MM/" title="S2MM">S2MM</a><time datetime="2023-12-27T05:57:36.000Z" title="发表于 2023-12-27 13:57:36">2023-12-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/24/auto2-using/" title="auto2-using"><img src="/img/chainsaw_makima04.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="auto2-using"/></a><div class="content"><a class="title" href="/2023/12/24/auto2-using/" title="auto2-using">auto2-using</a><time datetime="2023-12-24T14:17:24.000Z" title="发表于 2023-12-24 22:17:24">2023-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/12/auto1-introduction/" title="auto1_introduction"><img src="/img/flower.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="auto1_introduction"/></a><div class="content"><a class="title" href="/2023/12/12/auto1-introduction/" title="auto1_introduction">auto1_introduction</a><time datetime="2023-12-12T06:18:40.000Z" title="发表于 2023-12-12 14:18:40">2023-12-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 冰蒂斯</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>