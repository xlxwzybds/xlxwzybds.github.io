<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>AXIL_test_script | 冰蒂斯のformula</title><meta name="author" content="冰蒂斯"><meta name="copyright" content="冰蒂斯"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. Purp参考：Adding an AXI-Lite interface to your Verilator test script (zipcpu.com) 1.1 Problem我想要是想一个大型的 SVD 算法，根据我的调研，打算使用 MM2S 以及 S2MM 对 SDRAM 中存储的矩阵数据进行计算。但是 MM2S 能找到的代码信号众多，无仿真 TB，无法有效快速的理解各个信号代表的含">
<meta property="og:type" content="article">
<meta property="og:title" content="AXIL_test_script">
<meta property="og:url" content="http://more_study@163.com/2023/12/09/AXIL-test-script/index.html">
<meta property="og:site_name" content="冰蒂斯のformula">
<meta property="og:description" content="1. Purp参考：Adding an AXI-Lite interface to your Verilator test script (zipcpu.com) 1.1 Problem我想要是想一个大型的 SVD 算法，根据我的调研，打算使用 MM2S 以及 S2MM 对 SDRAM 中存储的矩阵数据进行计算。但是 MM2S 能找到的代码信号众多，无仿真 TB，无法有效快速的理解各个信号代表的含">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://more_study@163.com/img/chainsaw_makima04.jpg">
<meta property="article:published_time" content="2023-12-09T02:51:39.000Z">
<meta property="article:modified_time" content="2024-01-03T03:13:59.384Z">
<meta property="article:author" content="冰蒂斯">
<meta property="article:tag" content="verilator">
<meta property="article:tag" content="script">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://more_study@163.com/img/chainsaw_makima04.jpg"><link rel="shortcut icon" href="/img/bloodborn_lib.png"><link rel="canonical" href="http://more_study@163.com/2023/12/09/AXIL-test-script/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'AXIL_test_script',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-03 11:13:59'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/reze.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="冰蒂斯のformula"><span class="site-name">冰蒂斯のformula</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">AXIL_test_script</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-09T02:51:39.000Z" title="发表于 2023-12-09 10:51:39">2023-12-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-03T03:13:59.384Z" title="更新于 2024-01-03 11:13:59">2024-01-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/verilator/">verilator</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/verilator/AXI/">AXI</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="AXIL_test_script"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-Purp"><a href="#1-Purp" class="headerlink" title="1. Purp"></a>1. Purp</h1><p>参考：<a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2020/04/08/axitb.html">Adding an AXI-Lite interface to your Verilator test script (zipcpu.com)</a></p>
<h2 id="1-1-Problem"><a href="#1-1-Problem" class="headerlink" title="1.1 Problem"></a>1.1 Problem</h2><p>我想要是想一个大型的 <em>SVD</em> 算法，根据我的调研，打算使用 <em>MM2S</em> 以及 <em>S2MM</em> 对 <em>SDRAM</em> 中存储的矩阵数据进行计算。但是 <em>MM2S</em> 能找到的代码信号众多，无仿真 <em>TB</em>，无法有效快速的理解各个信号代表的含义。这个状况大大降低了我的代码阅读效率，使得工作一直卡在理解 <em>MM2S</em> 上，无法继续推进。</p>
<p>经过查找，我发现可以通过 <em>verilator</em> 来对设计进行相关的仿真。</p>
<p>为什么需要使用费<em>verilator</em>工具来进行仿真，难道 <em>formal property</em> 提供的 <em>induciton</em> 和 <em>cover()</em> 不够吗？<strong>这个想法想陷入了一个我觉得是误区的地方</strong>： <em>assert</em> 和 <em>cover</em> 本身使用做确保 <em>design</em> 功能的正确执行，而不是用于仿真来观察各个信号之间是如何依赖的，不能有效理解代码的逻辑含义。为了更好，更快的理解代码，而不是盯着 <em>code</em> 一直看，应该观察动态 <em>wave</em> 。</p>
<p><font color="red">这也给我提醒了一下以后的代码规范：1.一眼看清逻辑；2.一眼看到assert等验证；3.留存有效的波形仿真驱动；</font></p>
<h2 id="1-2-Need"><a href="#1-2-Need" class="headerlink" title="1.2 Need"></a>1.2 Need</h2><p>这个小结是对原文作者内容的简单翻译。</p>
<p>To understand why you might want to drive a simulation  using an <a target="_blank" rel="noopener" href="https://zipcpu.com/formal/2018/12/28/axilite.html">AXI-Lite</a> control port, consider the task I was struggling with last month: I’d built an AXI DMA controller, and it wasn’t passing all of my <code>cover()</code> checks.</p>
<p><em>cover</em> 相对于 <em>asseert</em> 最大的区别之一是：如果你的 <em>cover</em> 内容没有被覆盖，仿真直接 <em>fail</em>，不会像<em>asseret</em> 那样停留在信号波形图报错的那一步。</p>
<p>To make matters worse, it’s not often clear what causes a <code>cover()</code> statement to fail. Unlike assertion failures, <code>cover()</code> failures don’t normally produce a trace  identifying the line of code and the step in your <a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2017/07/31/vcd.html">trace</a> where your design first failed. No, when a <code>cover()</code> statement fails it just fails. </p>
<p>Without a trace to <em>see</em> what was going on, I got lucky with a guess that figured out what was happening. I don’t want to depend on getting lucky. I needed another way of figuring out what was going on.</p>
<p><em>cover</em> 不能报错，不想把希望寄托在幸运上，所以作者需要看波形。</p>
<h2 id="1-3-axi-interconnet"><a href="#1-3-axi-interconnet" class="headerlink" title="1.3 axi interconnet"></a>1.3 axi interconnet</h2><blockquote>
<p>random components don’t do anyone any good. Something needs to connect them together, and that’s the purpose of the <a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2019/07/17/crossbar.html">AXI interconnect</a> we’ll add into our test set as well. Such an <a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2019/07/17/crossbar.html">interconnect</a> can be used to arbitrate between which component had access to the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> at any given time. </p>
</blockquote>
<p><font color="red">这里虽然提及到了 axi-interconnet， 但是并不是这里的重点，</font></p>
<p><font color="red">建议的解决方法：了解，但不深入</font></p>
<p>（Fig 2. Using an interconnect to connect components）</p>
<img src="https://zipcpu.com/img/axitb/axilite-simplified.svg" alt="img" style="zoom: 50%;" />





<h1 id="2-test-stream"><a href="#2-test-stream" class="headerlink" title="2. test stream"></a>2. test stream</h1><h2 id="2-1-stream-source"><a href="#2-1-stream-source" class="headerlink" title="2.1 stream source"></a>2.1 stream source</h2><blockquote>
<p><strong>Filename</strong>: 	autodata&#x2F;streamsrc.txt</p>
<p><strong>Project</strong>:   AXI DMA Check: A utility to measure AXI DMA speeds</p>
<p><strong>Purpose</strong>: Creates a stream, suitable for testing, consisting of only a simple counter.  From here, it should be easy to see if items in the stream go missing (or not). To test an <a target="_blank" rel="noopener" href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">AXI stream to memory copy</a>, we’ll need a <a target="_blank" rel="noopener" href="https://github.com/ZipCPU/axidmacheck/blob/master/autodata/streamsrc.txt">stream source</a> in addition to our <a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2019/05/29/demoaxi.html">memory component</a>.</p>
</blockquote>
<p>A simple counter will work nicely. That will also allow us to measure both how long the stream copy took, as well as whether or not any words were lost along the way.</p>
<p>The code for this is simple enough that we might just want to copy it directly into our <a target="_blank" rel="noopener" href="https://github.com/ZipCPU/axidmacheck/blob/master/rtl/main.v">main design file</a>. We can do that using the <code>MAIN.INSERT</code> tag in an <a target="_blank" rel="noopener" href="https://zipcpu.com/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a> <a target="_blank" rel="noopener" href="https://github.com/ZipCPU/axidmacheck/blob/75ca30f582491f5358e0881fb846f5cfd0f4b3cb/autodata/streamsrc.txt#L44-L63">configuration file</a>.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Creates a stream, suitable for testing, consisting of only a simple counter.  </span></span><br><span class="line"><span class="comment">//From here, it should be easy to see if items in the stream go missing (or not). </span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (i_reset)</span><br><span class="line">	@$(PREFIX)_tvalid &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	@$(PREFIX)_tvalid &lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line">	@$(PREFIX)_tlast = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span>	@$(PREFIX)_counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (i_reset)</span><br><span class="line">	@$(PREFIX)_counter &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	@$(PREFIX)_counter &lt;= @$(PREFIX)_counter + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> i_clk)</span><br><span class="line"><span class="keyword">if</span> (!@$(PREFIX)_tvalid || @$(PREFIX)_tready)</span><br><span class="line">	@$(PREFIX)_tdata &lt;= @$(PREFIX)_counter;</span><br></pre></td></tr></table></figure>

<p>The counter always counts up on every clock tick, eventually <strong>wrapping around</strong> at <code>2^32</code> clock ticks. The <code>TDATA</code> logic sets our data to be equal to the counter any time the source <strong>isn’t stalled</strong></p>
<blockquote>
<p>The result is that this stream source will <strong>gladly drop data values</strong> if the memory copy <strong>can’t keep up</strong>. Once the memory transfers start again, we’ll be able to tell from the counter how many clock ticks took place that did (or didn’t) transfer memory. 这个<em>source</em>如果仔细观察会发现，该逻辑会把 <em>counter</em> 数值一直往 <em>tdata</em> 中送，中间掉数据也不理会。</p>
</blockquote>
<h2 id="2-2-stream-sink"><a href="#2-2-stream-sink" class="headerlink" title="2.2 stream sink"></a>2.2 stream sink</h2><blockquote>
<p><strong>Filename</strong>:  <a target="_blank" rel="noopener" href="https://github.com/ZipCPU/axidmacheck/blob/master/rtl/streamcounter.v">axidmacheck&#x2F;rtl&#x2F;streamcounter.v at master · ZipCPU&#x2F;axidmacheck (github.com)</a></p>
<p><strong>Project</strong>:   WB2AXIPSP: bus bridges and other odds and ends</p>
<p><strong>Purpose</strong>: In a similar fashion, if we want to test <a target="_blank" rel="noopener" href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/aximm2s.v">a memory to stream copy</a>, we’d need a <a target="_blank" rel="noopener" href="https://github.com/ZipCPU/axidmacheck/blob/master/rtl/streamcounter.v">stream sink</a>. Perhaps we can build <a target="_blank" rel="noopener" href="https://github.com/ZipCPU/axidmacheck/blob/master/rtl/streamcounter.v">something that measures performance</a> in this case, so that we can see how well and fast <a target="_blank" rel="noopener" href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/aximm2s.v">our copy</a> works.</p>
</blockquote>
<p>使用 <em>FPGA</em> 观察波形能够很好的得到设计实现的速度能够达到多少速度。就算设计再好，也可能在总线的设计上使得速度落下风，所以需要查看总线的速度：</p>
<img src="https://zipcpu.com/img/axitb/stream-measures.svg" alt="img" style="zoom: 60%;" />

<blockquote>
<p>What measures might we use? I picked <strong>three</strong> simple ones.</p>
<ol>
<li>The number of beats of information that have been transferred in <strong>total</strong>. This would be a count of <code>TVALID &amp;&amp; TREADY</code> cycles.</li>
<li>The number of <strong>packets</strong>. This would be a count of <code>TVALID &amp;&amp; TREADY &amp;&amp; TLAST</code>.</li>
<li>The number of clocks taken <strong>from the first beat to the last</strong>. This would be a counter with a reset, that starts running upon the first beat of any transfer, and whose value gets copied on any <code>TVALID &amp;&amp; TREADY</code> clock cycle.</li>
</ol>
</blockquote>
<ul>
<li>Name:</li>
</ul>
<blockquote>
<p>First, we tell <a target="_blank" rel="noopener" href="https://zipcpu.com/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a> that we want to be a slave of an AXI-Lite bus that I’ve named <code>axil</code>, and that our design will have four addressable (word) registers within it.</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PREFIX=streamsink</span><br><span class="line">@NADDR=<span class="number">4</span></span><br><span class="line">@SLAVE<span class="variable">.BUS</span>=axil</span><br><span class="line">@SLAVE<span class="variable">.TYPE</span>=DOUBLE</span><br></pre></td></tr></table></figure>



<h1 id="3-AXI-TB-part1"><a href="#3-AXI-TB-part1" class="headerlink" title="3. AXI_TB part1"></a>3. AXI_TB part1</h1><img src="https://zipcpu.com/img/axitb/vfiles.svg" alt="img" style="zoom: 60%;" />

<p><strong>Emmmm, mmmmm</strong>其实这些东西都可以跳过去，我会在这里删减掉大多数的内容，<font color="red">把握住任务：怎么写 <em>verilator</em> 的 <em>axi script</em></font></p>
<blockquote>
<p>This C++ <code>AXI\_TB</code> class will need to wrap the <a target="_blank" rel="noopener" href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/main_tb.cpp">main test bench</a>. It will also provide us with simplified commands that we can use to access the AXI bus within the design from the perspective of an AXI master</p>
</blockquote>
<h2 id="3-1-class-defination"><a href="#3-1-class-defination" class="headerlink" title="3.1 class defination"></a>3.1 class defination</h2><p>不知道 <em>testb.h</em> ， <em>devbus.h</em> 的意思是什么。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;verilated.h&gt;</span> <span class="comment">// 引入Verilator仿真器的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;verilated_vcd_c.h&gt;</span> <span class="comment">// 引入Verilator仿真器的波形文件生成库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;testb.h&quot;</span> <span class="comment">// 引入测试台的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// devbus.h 提供了我们通用接口的定义</span></span><br><span class="line"><span class="comment">// devbus.h provides the definition of our common interface</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;devbus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在判断一个外设是否损坏之前的时钟周期数</span></span><br><span class="line"><span class="comment">// Number of clocks before deciding a peripheral is broken</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>	BOMBCOUNT = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个模板类AXI_TB，继承自DEVBUS类</span></span><br><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">TB</span>&gt;</span>	<span class="class"><span class="keyword">class</span>	<span class="title">AXI_TB</span> :</span> public DEVBUS &#123;</span><br><span class="line">	<span class="type">bool</span>	m_buserr;  <span class="comment">// 表示总线错误的布尔值</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>	INTERRUPTWIRE</span></span><br><span class="line">	<span class="type">bool</span>	m_interrupt; <span class="comment">// 表示中断的布尔值</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	VerilatedVcdC	*m_trace; <span class="comment">// 用于跟踪仿真过程的指针</span></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	<span class="comment">// m_tb包装了实际逻辑的测试台</span></span><br><span class="line">	<span class="comment">// m_tb wraps the TESTB wrapper of the actual logic</span></span><br><span class="line">	TB		*m_tb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为我们今天要使用的总线字定义一个类型别名BUSW</span></span><br><span class="line">	<span class="comment">// A 32-bit unsigned integer is a bus word for our purposes today</span></span><br><span class="line">	<span class="keyword">typedef</span>	<span class="type">uint32_t</span>	BUSW;</span><br><span class="line">	</span><br><span class="line">	<span class="type">bool</span>	m_bomb;  <span class="comment">// 表示某种错误或异常状态的布尔值</span></span><br></pre></td></tr></table></figure>



<h2 id="3-2-TESTB"><a href="#3-2-TESTB" class="headerlink" title="3.2 TESTB"></a>3.2 TESTB</h2><blockquote>
<p>This will give us access to a <code>tick()</code> method that <a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2018/09/06/tbclock.html">toggles our clock and advances simulation time</a>, while also encapsulating any <a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2017/07/31/vcd.html">trace file</a> generation routines. This class is automatically generated for us by <a target="_blank" rel="noopener" href="https://zipcpu.com/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>, to make sure that all clocks are properly modeled for us.</p>
</blockquote>
<p><font color="red">这个部分应该是由 autoFPGA 自动生成的，我猜测阅读性比较差，所以暂时不进行阅读，只需要知道这是一个 <em>wrap</em> 针对 <em>test</em> 文件</font></p>
<ul>
<li>参考：<a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2017/06/21/looking-at-verilator.html">Taking a New Look at Verilator (zipcpu.com)</a></li>
<li>参考： <a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2018/09/06/tbclock.html">Handling multiple clocks with Verilator (zipcpu.com)</a></li>
</ul>
<p>这里指的是，使用一个 <em>testbench</em> 的文件来 <em>wrap</em> 设计中的 <em>driver</em> 。</p>
<h2 id="3-3-MAIN-tb-模拟器"><a href="#3-3-MAIN-tb-模拟器" class="headerlink" title="3.3 MAIN_tb(模拟器)"></a>3.3 MAIN_tb(模拟器)</h2><p><font color="red">这个部分也是 autoFPGA 生成的，所以暂时也不深入代码</font></p>
<p><font color="red">为了理解这些东西，你可能需要</font>：<a target="_blank" rel="noopener" href="https://github.com/ZipCPU/autofpga/blob/5e8b431eecebbd51feaf308ee641e1fb58464881/doc/icd.txt#L262-L264">autofpga&#x2F;doc&#x2F;icd.txt at 5e8b431eecebbd51feaf308ee641e1fb58464881 · ZipCPU&#x2F;autofpga (github.com)</a></p>
<blockquote>
<p>这部分是一个 <code>Emulation Layer</code>。在这里，“emulator functions” 指的是模拟器函数.模拟器函数是一种特殊的函数，它们在模拟器软件中定义，用于模拟另一个系统（被称为“客体”系统）的行为.其中的<code>MAINTB() class</code> 将会告诉 <em>autoFPGA</em> 需要调用何种模拟器的行为。</p>
</blockquote>
<p>下面的话我认为是需要理解的概念：</p>
<p>As you may recall, <a target="_blank" rel="noopener" href="https://zipcpu.com/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a> is first a copy&#x2F;paste utility, and only then a bus compositor. Three particular AutoFPGA keys give you access to these functions.</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ZipCPU/autofpga/blob/5e8b431eecebbd51feaf308ee641e1fb58464881/doc/icd.txt#L262-L264"><code>SIM.CLOCK</code></a> defines the clock your core needs <a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2018/08/22/what-is-simulation.html">simulation</a> support at.</li>
<li><a target="_blank" rel="noopener" href="https://github.com/ZipCPU/autofpga/blob/5e8b431eecebbd51feaf308ee641e1fb58464881/doc/icd.txt#L237-L239"><code>SIM.INIT</code></a> can be used to define any C++ variables you need in <a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2018/08/22/what-is-simulation.html">simulation</a>, can be used to initialize any of these variables.</li>
<li>and <a target="_blank" rel="noopener" href="https://github.com/ZipCPU/autofpga/blob/5e8b431eecebbd51feaf308ee641e1fb58464881/doc/icd.txt#L245-L246"><code>SIM.TICK</code></a> can be used to define any logic that might need to happen on a clock tick.</li>
</ul>
<blockquote>
<p>Example : </p>
</blockquote>
<ul>
<li>首先将设计的库进行调用。<em>This would get placed at the top of the main_tb.cpp class file.</em> 这表示我们后面将要控制哪一个库中的设计。首先将设计的库进行调用。<em>This would get placed at the top of the <code>main_tb.cpp</code> class file.</em> 这表示我们后面将要控制哪一个库中的设计。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@SIM.INCLUDE=  </span><br><span class="line">                #include &quot;uartsim.h&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用指针，指向一个需要使用的 <em>design class type</em> ，方便后面控制设计中的具体信号。 这里定义了 <em>autoFPGA</em> 下的<strong>键值对</strong>，以后只需要使用 <code>UARTSUN</code> 就能调用 <code>*m_core</code>这个具体的设计。</p>
<p>使用了 <code>PREFIX</code>控制名称，方便设计。 </p>
<p>*Realistically, the name of the serial port could be anything–it doesn’t have to include the PREFIX tag of this component at all. I could’ve just called it UARTSIM *m_uart;. I just like to use the PREFIX tag here to help provide some ability to separate device names.</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@SIM.DEFNS=</span><br><span class="line">				UARTSIM *m_@$(PREFIX);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>初始化</strong>。将设计中的部分参数进行初始化。</p>
<p>这里我十分好奇，为什么需要使用 <em>new</em> 来额外分配这些地址空间，而不是直接使用原来定义的指针空间。解释如下：在 C++ 中，<code>new</code> 关键字用于动态分配内存。当你使用 <code>new</code> 创建一个对象时，C++ 运行时会在堆上为该对象分配内存，并返回一个指向该内存的指针。这个对象会一直存在，直到你使用 <code>delete</code> 关键字显式地释放它。在这个例子中，<code>new UARTSIM(FPGAPORT,UARTSETUP)</code> 创建了一个新的 <code>UARTSIM</code> 对象，并返回了一个指向该对象的指针。这个对象在堆上，而不是在栈上，所以它的生命周期不受函数或作用域的限制。这意味着，即使函数返回或作用域结束，这个对象仍然存在，可以在程序的其他部分中使用。</p>
<p>如果你直接使用现有的对象，而不是创建一个新的对象，那么你可能会遇到一些问题。例如，如果这个对象在栈上，那么当函数返回或作用域结束时，这个对象就会被销毁，你就不能再使用它了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@SIM.INIT=</span><br><span class="line">		m_@$(PREFIX) = <span class="keyword">new</span> <span class="built_in">UARTSIM</span>(FPGAPORT,UARTSETUP);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>TICK</code> <strong>push forward</strong>。后面的话不理解，暂时抄下来：<em>The <code>m_uart</code> C++ object then emulates a serial port–given the output serial port wire from the design, <code>o_uart_tx</code>, it produces the serial port input for the next time step, <code>i_uart_tx</code>.</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@SIM.TICK=</span><br><span class="line">		m_core-&gt;i_@$(PREFIX)_rx = (*m_@$(PREFIX))(m_core-&gt;o_@$(PREFIX)_tx);</span><br><span class="line">		<span class="comment">//m_core-&gt;i_uart_rx = (*m_uart)(m_core-&gt;o_uart_tx);</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="3-5-Assembly"><a href="#3-5-Assembly" class="headerlink" title="3.5 Assembly"></a>3.5 Assembly</h1><h1 id="4-AXI-TB-part2"><a href="#4-AXI-TB-part2" class="headerlink" title="4.AXI_TB part2"></a>4.AXI_TB part2</h1><blockquote>
<p><em>Supporting these emulation software calls is the purpose of the <code>main_tb.cpp</code> wrapper. For today’s DMA testing design, though, we won’t be using any of this emulation capability.</em> 在 <em>AXI</em> 相关的设计中，将不会设计到 <em>emulator layer</em> 层面</p>
<p>This C++ <code>AXI\_TB</code> class will need to wrap the <a target="_blank" rel="noopener" href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/main_tb.cpp">main test bench</a>. It will also <strong>provide us with simplified commands that we can use to access the AXI bus</strong> within the design <strong>from the perspective of an AXI master</strong></p>
</blockquote>
<h2 id="4-1-class-defination"><a href="#4-1-class-defination" class="headerlink" title="4.1 class defination"></a>4.1 class defination</h2><p><em>We’ll define this <code>AXI\_TB</code> class as a <strong>template class</strong>, defined using our <a target="_blank" rel="noopener" href="https://github.com/ZipCPU/axidmacheck/blob/master/rtl/main.v">test bench software</a>, herein called <code>TB</code>. (This would be the software containing any emulation layers that we just discussed before.)</em></p>
<p>Based on our <a target="_blank" rel="noopener" href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/main_tb.cpp"><code>MAIN\_TB</code> test bench</a>, wrapping the <a target="_blank" rel="noopener" href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/testb.h"><code>TESTB</code> helper class</a>, we’ll make a copy of whatever it is into <code>m_tb</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;verilated.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;verilated_vcd_c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;testb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// do not care this defination now, just ignore it</span></span><br><span class="line"><span class="comment">// devbus.h provides the definition of our common interface</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;devbus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// we will spend 32 clock cycle at most to figure out if the bus is broken</span></span><br><span class="line"><span class="comment">// Number of clocks before deciding a peripheral is broken</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>	BOMBCOUNT = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义了一个可以处理 class_TB 类型数据的方法，名字为 AXI_TB， 继承 DEBUS</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">TB</span>&gt;	<span class="keyword">class</span>	<span class="title class_">AXI_TB</span> : <span class="keyword">public</span> DEVBUS &#123;</span><br><span class="line">	</span><br><span class="line">  	<span class="type">bool</span>	m_buserr;			<span class="comment">//if busy or not</span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span>	INTERRUPTWIRE</span></span><br><span class="line">        <span class="type">bool</span>	m_interrupt;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    VerilatedVcdC	*m_trace;	<span class="comment">//track the wave</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// m_tb wraps the TESTB wrapper of the actual logic</span></span><br><span class="line">	TB		*m_tb;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将 unit32_t 数据类型定义累 BUSW</span></span><br><span class="line">	<span class="comment">// A 32-bit unsigned integer is a bus word for our purposes today</span></span><br><span class="line">	<span class="keyword">typedef</span>	<span class="type">uint32_t</span>	BUSW;</span><br><span class="line">	</span><br><span class="line">	<span class="type">bool</span>	m_bomb; <span class="comment">// if bus is broken </span></span><br></pre></td></tr></table></figure>





<h2 id="4-2-AXI-testbench-wrapper-objects"><a href="#4-2-AXI-testbench-wrapper-objects" class="headerlink" title="4.2 AXI testbench wrapper objects"></a>4.2 AXI testbench wrapper objects</h2><p>首先是 <em>AXI_TB(void)</em> 内部</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AXI_TB</span>(<span class="type">void</span>) &#123;</span><br><span class="line">		<span class="comment">// 建立一个数据结构在 堆 上，而不是stack上，这样可以让其他程序进行调用</span></span><br><span class="line">		<span class="comment">// Create a new test bench</span></span><br><span class="line">		m_tb = <span class="keyword">new</span> TB;</span><br><span class="line">		<span class="comment">// Notify Verilator that we might turn tracing on later</span></span><br><span class="line">		Verilated::<span class="built_in">traceEverOn</span>(<span class="literal">true</span>);</span><br><span class="line">		<span class="comment">// On startup, nothing has timed out (yet)</span></span><br><span class="line">		m_bomb = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>在这里我可以猜测，<em>m_tb</em> 是指向 <em>testbench</em> 的测试<em>class</em> ， <em>m_core</em> 指向 <em>the wrapption of the design</em> 。如果后面看到有不符合的地方，继续进行修改。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// Before reset, all VALIDs must be zero.  We&#x27;re also not</span></span><br><span class="line">		<span class="comment">// going to touch AxPROT again, so let&#x27;s give it a useful</span></span><br><span class="line">		<span class="comment">// value going forward.  (Most of my designs have ignored</span></span><br><span class="line">		<span class="comment">// AxPROT so far.)</span></span><br><span class="line">		m_tb-&gt;m_core-&gt;S_AXI_AWVALID = <span class="number">0</span>;</span><br><span class="line">		m_tb-&gt;m_core-&gt;S_AXI_AWPROT  = <span class="number">0</span>;</span><br><span class="line">		m_tb-&gt;m_core-&gt;S_AXI_WVALID  = <span class="number">0</span>;</span><br><span class="line">		m_tb-&gt;m_core-&gt;S_AXI_WSTRB   = <span class="number">0x0f</span>;<span class="comment">// the BUSW is uint_32t type</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		m_tb-&gt;m_core-&gt;S_AXI_ARVALID = <span class="number">0</span>;</span><br><span class="line">		m_tb-&gt;m_core-&gt;S_AXI_ARPROT  = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// Technically xREADY could be anything.  We&#x27;ll set it to</span></span><br><span class="line">		<span class="comment">// zero as well.</span></span><br><span class="line">		m_tb-&gt;m_core-&gt;S_AXI_BREADY  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		m_tb-&gt;m_core-&gt;S_AXI_RREADY  = <span class="number">0</span>;</span><br><span class="line">		m_buserr = <span class="literal">false</span>;  <span class="comment">// does it means there is no transaction ?</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>	INTERRUPTWIRE</span></span><br><span class="line">		<span class="comment">// If INTERRUPTWIRE is defined, it is defined to the</span></span><br><span class="line">		<span class="comment">// name of the interrupt output from the design.  If not,</span></span><br><span class="line">		<span class="comment">// we won&#x27;t support interrupt logic.</span></span><br><span class="line">		m_interrupt = <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-3-delete-trace-kill-eval"><a href="#4-3-delete-trace-kill-eval" class="headerlink" title="4.3 delete &amp; trace &amp; kill &amp; eval"></a>4.3 delete &amp; trace &amp; kill &amp; eval</h2><ul>
<li><code>~AXI_TB(void)</code>: 这是类<code>AXI_TB</code>的析构函数，当一个<code>AXI_TB</code>对象不再需要时，这个函数会被调用。在这个函数中，它删除了成员<code>m_tb</code>，这是一个动态分配的对象，需要在不再使用时删除以防止内存泄漏。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AXI_TB deconstructor</span></span><br><span class="line"><span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line"><span class="keyword">virtual</span>	~<span class="built_in">AXI_TB</span>(<span class="type">void</span>) &#123;</span><br><span class="line">	<span class="keyword">delete</span> m_tb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在 <em>main_TB.cpp</em> 代码中提供了如何去追中 <em>signal_vcd</em> 的<em>function</em>。<em>Since we’ve wrapped this interface, we’ll need to re-expose access to this function to the rest of the design.</em></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span>	<span class="type">void</span>	<span class="title">opentrace</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *vcdname)</span> </span>&#123;</span><br><span class="line">	m_tb-&gt;<span class="built_in">opentrace</span>(vcdname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>closetrace(void)</code>: 这个函数关闭了追踪。它调用了<code>m_tb</code>的<code>closetrace</code>函数。</li>
<li><code>close(void)</code>: 这个函数关闭了<code>m_tb</code>。它调用了<code>m_tb</code>的<code>close</code>函数。</li>
<li><code>kill(void)</code>: 这个函数调用了<code>close</code>函数，用于关闭<code>m_tb</code>。</li>
<li><code>eval(void)</code>: 这个函数评估了<code>m_tb</code>的<code>m_core</code>。它调用了<code>m_tb</code>的<code>m_core</code>的<code>eval</code>函数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// closetrace()</span></span><br><span class="line"><span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span>	<span class="type">void</span>	<span class="title">closetrace</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	m_tb-&gt;<span class="built_in">closetrace</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#125;&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// close()</span></span><br><span class="line"><span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span>	<span class="type">void</span>	<span class="title">close</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	m_tb-&gt;<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#125;&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// kill()</span></span><br><span class="line"><span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span>	<span class="type">void</span>	<span class="title">kill</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#125;&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// eval()</span></span><br><span class="line"><span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span>	<span class="type">void</span>	<span class="title">eval</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	m_tb-&gt;m_core-&gt;<span class="built_in">eval</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="4-4-tick"><a href="#4-4-tick" class="headerlink" title="4.4 tick( )"></a>4.4 tick( )</h2><h2 id="4-5-reset"><a href="#4-5-reset" class="headerlink" title="4.5 reset"></a>4.5 reset</h2><blockquote>
<p>Purpose:  We’ll use a special <code>reset()</code> call to <strong>place</strong> the design <strong>into</strong> reset. </p>
<p>Behavior: This resets all of the various <code>*VALID</code> signals and pulls <code>ARESETN</code> low.</p>
</blockquote>
<p>代码如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reset()</span></span><br><span class="line"><span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span>	<span class="type">void</span>	<span class="title">reset</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// m_tb-&gt;m_core-&gt;S_AXI_ARESETN = 0;</span></span><br><span class="line">	m_tb-&gt;m_core-&gt;i_reset = <span class="number">1</span>;</span><br><span class="line">	m_tb-&gt;m_core-&gt;S_AXI_AWVALID = <span class="number">0</span>;</span><br><span class="line">	m_tb-&gt;m_core-&gt;S_AXI_WVALID  = <span class="number">0</span>;</span><br><span class="line">	m_tb-&gt;m_core-&gt;S_AXI_ARVALID = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 因为要实现 16个时钟周期的复位，所以进行 16周期的 tick().</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;<span class="number">16</span>; k++)</span><br><span class="line">		<span class="built_in">tick</span>();</span><br><span class="line">	<span class="comment">//复位恢复， i_reset 高信号复位 ， 然后再 tick()</span></span><br><span class="line">	m_tb-&gt;m_core-&gt;i_reset = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">tick</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>There’s one other trick which <strong>isn’t obvious</strong>: once we clear the reset, we have to have a whole clock tick with the reset clear. (See <a target="_blank" rel="noopener" href="https://zipcpu.com/doc/axi-spec.pdf">Fig. A3-1</a>.)</p>
<p>在进行<em>16</em>周期的高信号复位之后，需要一个时钟周期进行 <em>clear reset</em> ！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	m_tb-&gt;m_core-&gt;S_AXI_ARESETN = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">tick</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-6-tickcount"><a href="#4-6-tickcount" class="headerlink" title="4.6 tickcount"></a>4.6 tickcount</h2><p>定义了一个名为 <code>tickcount</code> 的函数，它返回一个 <code>unsigned long</code> 类型的值。这个函数的作用是获取当前的时钟计数（tick count）。</p>
<p>具体来说，<code>m_tb-&gt;m_time_ps</code> 是一个模拟时间，单位是皮秒（picoseconds）。这个时间被除以 <code>10000l</code>（10000 长整型），所以返回的结果单位是 10 纳秒（10 nanoseconds）。这意味着 <code>tickcount</code> 函数返回的是当前模拟时间（以 10 纳秒为单位）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tickcount()</span></span><br><span class="line"><span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span>	<span class="title">tickcount</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> m_tb-&gt;m_time_ps / <span class="number">10000l</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="4-7-idle-cnt"><a href="#4-7-idle-cnt" class="headerlink" title="4.7 idle(cnt)"></a>4.7 idle(cnt)</h2><blockquote>
<p>Purpose:<br><code>idle(cnt)</code>, is also a helper function. </p>
<p>Because we are running in a simulated environment, if you just call AXI read&#x2F;write commands, you might <strong>push the bus harder</strong> than you ever would in practice. For this reason, <code>idle()</code> just holds the entire design in an idle state for some number of counts.</p>
</blockquote>
<p>尚且不知道这个函数的具体作用是什么？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// idle() -- pass a tick w/o doing anything</span></span><br><span class="line"><span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line"><span class="function"><span class="type">void</span>	<span class="title">idle</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> counts = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">	m_tb-&gt;m_core-&gt;S_AXI_AWVALID = <span class="number">0</span>;</span><br><span class="line">	m_tb-&gt;m_core-&gt;S_AXI_WVALID  = <span class="number">0</span>;</span><br><span class="line">	m_tb-&gt;m_core-&gt;S_AXI_BREADY  = <span class="number">0</span>;</span><br><span class="line">	m_tb-&gt;m_core-&gt;S_AXI_ARVALID = <span class="number">0</span>;</span><br><span class="line">	m_tb-&gt;m_core-&gt;S_AXI_RREADY  = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">unsigned</span> k=<span class="number">0</span>; k&lt;counts; k++) &#123;</span><br><span class="line">		<span class="built_in">tick</span>();</span><br><span class="line">		<span class="built_in">assert</span>(!m_tb-&gt;m_core-&gt;S_AXI_RVALID);</span><br><span class="line">		<span class="built_in">assert</span>(!m_tb-&gt;m_core-&gt;S_AXI_BVALID);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure>























<h1 id="4-Simulation-script"><a href="#4-Simulation-script" class="headerlink" title="4. Simulation script"></a>4. Simulation script</h1><p>上面的内容太多了，抓住关键点，使用 <em>verilator</em> 进行 <em>MM2S simulation</em> ，查看相关的波形，了解其中的逻辑。 </p>
<h2 id="4-1-marco"><a href="#4-1-marco" class="headerlink" title="4.1 marco"></a>4.1 marco</h2><blockquote>
<p>首先是关于 RAM macro 的使用</p>
</blockquote>
<p><em>We’ll use a couple of macros to help drive the script. One of them is this <code>test bench RAM macro</code>, or <code>TBRAM</code> for short. With this macro, we can then treat the RAM elements within the design as though they were actually elements of our C++ project–which in effect they are.</em></p>
<p>we’ll first need to define an <a target="_blank" rel="noopener" href="https://github.com/ZipCPU/axidmacheck/blob/c93f8672734ccf7095aba107f6949547faf93cbd/sim/main_tb.cpp#L64-L73">AXIRAM</a> macro to get us from the <a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2017/06/21/looking-at-verilator.html">Verilator</a> design to the <a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2019/05/29/demoaxi.html">AXI block RAM</a>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compatibility definitions for Verilator 3.8 to 3.9</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span>	VVAR</span></span><br><span class="line">	<span class="meta">#<span class="keyword">ifdef</span>	NEW_VERILATOR</span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span>	VVAR(A)	main__DOT_ ## A</span></span><br><span class="line">	<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span>	VVAR(A)	v__DOT_ ## A</span></span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	AXIRAM	VVAR(_axiram_mem)</span></span><br><span class="line"><span class="comment">//#define	VVAR(A)	main__DOT_ ## A</span></span><br><span class="line"><span class="comment">//#define	AXIRAM	VVAR(_axiram_mem)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>#define VVAR(A) main__DOT_ ## A</code>：<ul>
<li>这是定义了一个名为 <code>VVAR</code> 的宏，它接受一个参数 <code>A</code>。当这个宏被使用时，它会被替换为 <code>main__DOT_</code> 和参数 <code>A</code> 的连接。<code>##</code> 是 C&#x2F;C++ 预处理器的连接运算符，用于连接两个记号。</li>
</ul>
</li>
<li><code>#define AXIRAM VVAR(_axiram_mem)</code>：<ul>
<li>这是定义了一个名为 <code>AXIRAM</code> 的宏，它没有参数。当这个宏被使用时，它会被替换为 <code>VVAR(_axiram_mem)</code> 的结果，也就是 <code>main__DOT__axiram_mem</code>。</li>
</ul>
</li>
</ul>
<blockquote>
<p>Second marco to reference the AXIRAM from the top of our script</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>	TBRAM	m_tb-&gt;m_core-&gt;AXIRAM</span></span><br></pre></td></tr></table></figure>

<p>现在使用 <code>TBRAM</code>就意味着在 <em>C</em> 代码中从顶层 <em>design</em> 直接映射到 <em>AXIRAM</em></p>
<h1 id="5-Reading-f-king-code"><a href="#5-Reading-f-king-code" class="headerlink" title="5. Reading f**king code"></a>5. Reading f**king code</h1><h2 id="5-1-sim-testb-h"><a href="#5-1-sim-testb-h" class="headerlink" title="5.1 sim&#x2F;testb.h"></a>5.1 sim&#x2F;testb.h</h2><p>虽然这个代码是电脑生成的，为了方便对上层代码的理解，目前觉得这些代码还是有必要去了解的。</p>
<h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><ul>
<li><p>链接：<a target="_blank" rel="noopener" href="https://zipcpu.com/zipcpu/2017/10/05/autofpga-intro.html">A Brief Introduction to AutoFPGA (zipcpu.com)</a></p>
<ul>
<li><p>使用自动化的方法对一些设计进行命名</p>
</li>
<li><p>自动 <em>copy</em> 一些声明：</p>
<p>If you browse through the <a target="_blank" rel="noopener" href="https://github.com/ZipCPU/axidmacheck/blob/master/autodata/streamsrc.txt">configuration file</a>, you’ll notice only two other tags defined. Those are the <a target="_blank" rel="noopener" href="https://github.com/ZipCPU/axidmacheck/blob/75ca30f582491f5358e0881fb846f5cfd0f4b3cb/autodata/streamsrc.txt#L38"><code>PREFIX</code> tag</a>, giving a name to our element, and the <a target="_blank" rel="noopener" href="https://github.com/ZipCPU/axidmacheck/blob/75ca30f582491f5358e0881fb846f5cfd0f4b3cb/autodata/streamsrc.txt#L39-L43"><code>MAIN.DEFNS</code> tag</a>–allowing us to copy our register definitions to the top of our <a target="_blank" rel="noopener" href="https://github.com/ZipCPU/axidmacheck/blob/75ca30f582491f5358e0881fb846f5cfd0f4b3cb/rtl/main.v#L164-L167">main.v</a> logic file.</p>
</li>
</ul>
</li>
<li><p>链接：<a target="_blank" rel="noopener" href="https://zipcpu.com/zipcpu/2019/08/30/subbus.html">Connecting lots of slaves to a bus without using a lot of logic (zipcpu.com)</a></p>
<ul>
<li>this will be a <a target="_blank" rel="noopener" href="https://zipcpu.com/zipcpu/2019/08/30/subbus.html"><em>simplified</em> AXI-lite slave that can share it’s bus logic with other AXI-lite slaves</a>.</li>
</ul>
</li>
<li><p>链接：<a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2017/05/22/a-vision-for-controlling-fpgas.html">A Vision for Controlling FPGA Logic (zipcpu.com)</a></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zipcpu.com/blog/2017/05/22/a-vision-for-controlling-fpgas.html">The basic control vision</a> involves a <a target="_blank" rel="noopener" href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/axi_tb.h">C++ class implementing</a> an <a target="_blank" rel="noopener" href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/devbus.h">interface to the design</a>. This <a target="_blank" rel="noopener" href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/devbus.h">interface</a> has six primary functions.</li>
</ul>
</li>
</ul>
<p>如果是连续的错做</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://more_study@163.com">冰蒂斯</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://more_study@163.com/2023/12/09/AXIL-test-script/">http://more_study@163.com/2023/12/09/AXIL-test-script/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://more_study@163.com" target="_blank">冰蒂斯のformula</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/verilator/">verilator</a><a class="post-meta__tags" href="/tags/script/">script</a></div><div class="post_share"><div class="social-share" data-image="/img/chainsaw_makima04.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/12/10/Verilator-NEW-LOOK/" title="Verilator-NEW-LOOK"><img class="cover" src="/img/flower.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Verilator-NEW-LOOK</div></div></a></div><div class="next-post pull-right"><a href="/2023/12/06/MM2S/" title="MM2S"><img class="cover" src="/img/chainsaw_red.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MM2S</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/12/10/Verilator-NEW-LOOK/" title="Verilator-NEW-LOOK"><img class="cover" src="/img/flower.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-10</div><div class="title">Verilator-NEW-LOOK</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">冰蒂斯</div><div class="author-info__description">螺旋上升的人生,也是多线程的人生</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/more_study@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Purp"><span class="toc-number">1.</span> <span class="toc-text">1. Purp</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-Problem"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 Problem</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Need"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 Need</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-axi-interconnet"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 axi interconnet</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-test-stream"><span class="toc-number">2.</span> <span class="toc-text">2. test stream</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-stream-source"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 stream source</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-stream-sink"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 stream sink</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-AXI-TB-part1"><span class="toc-number">3.</span> <span class="toc-text">3. AXI_TB part1</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-class-defination"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 class defination</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-TESTB"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 TESTB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-MAIN-tb-%E6%A8%A1%E6%8B%9F%E5%99%A8"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 MAIN_tb(模拟器)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-5-Assembly"><span class="toc-number">4.</span> <span class="toc-text">3.5 Assembly</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-AXI-TB-part2"><span class="toc-number">5.</span> <span class="toc-text">4.AXI_TB part2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-class-defination"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 class defination</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-AXI-testbench-wrapper-objects"><span class="toc-number">5.2.</span> <span class="toc-text">4.2 AXI testbench wrapper objects</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-delete-trace-kill-eval"><span class="toc-number">5.3.</span> <span class="toc-text">4.3 delete &amp; trace &amp; kill &amp; eval</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-tick"><span class="toc-number">5.4.</span> <span class="toc-text">4.4 tick( )</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-reset"><span class="toc-number">5.5.</span> <span class="toc-text">4.5 reset</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-tickcount"><span class="toc-number">5.6.</span> <span class="toc-text">4.6 tickcount</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-idle-cnt"><span class="toc-number">5.7.</span> <span class="toc-text">4.7 idle(cnt)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Simulation-script"><span class="toc-number">6.</span> <span class="toc-text">4. Simulation script</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-marco"><span class="toc-number">6.1.</span> <span class="toc-text">4.1 marco</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Reading-f-king-code"><span class="toc-number">7.</span> <span class="toc-text">5. Reading f**king code</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-sim-testb-h"><span class="toc-number">7.1.</span> <span class="toc-text">5.1 sim&#x2F;testb.h</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB"><span class="toc-number">8.</span> <span class="toc-text">推荐阅读</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/03/09/axilite-mux/" title="axilite-mux"><img src="/img/makima.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="axilite-mux"/></a><div class="content"><a class="title" href="/2024/03/09/axilite-mux/" title="axilite-mux">axilite-mux</a><time datetime="2024-03-09T03:30:56.000Z" title="发表于 2024-03-09 11:30:56">2024-03-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/26/cocotbaxi-01-try/" title="cocotbaxi-01-try"><img src="/img/makima.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="cocotbaxi-01-try"/></a><div class="content"><a class="title" href="/2024/02/26/cocotbaxi-01-try/" title="cocotbaxi-01-try">cocotbaxi-01-try</a><time datetime="2024-02-26T13:55:25.000Z" title="发表于 2024-02-26 21:55:25">2024-02-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/11/AXI-Master-bursting/" title="difficult of AXI Master Bursting"><img src="/img/chainsaw_makima04.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="difficult of AXI Master Bursting"/></a><div class="content"><a class="title" href="/2024/01/11/AXI-Master-bursting/" title="difficult of AXI Master Bursting">difficult of AXI Master Bursting</a><time datetime="2024-01-11T08:52:33.000Z" title="发表于 2024-01-11 16:52:33">2024-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/10/Plan-XJY/" title="Plan_XJY"><img src="/img/chainsaw_power01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Plan_XJY"/></a><div class="content"><a class="title" href="/2024/01/10/Plan-XJY/" title="Plan_XJY">Plan_XJY</a><time datetime="2024-01-10T07:46:33.000Z" title="发表于 2024-01-10 15:46:33">2024-01-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/07/skid-buffer/" title="skid_buffer"><img src="/img/chainsaw_power01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="skid_buffer"/></a><div class="content"><a class="title" href="/2024/01/07/skid-buffer/" title="skid_buffer">skid_buffer</a><time datetime="2024-01-07T12:48:03.000Z" title="发表于 2024-01-07 20:48:03">2024-01-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 冰蒂斯</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>